<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[source_docs]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>source_docs</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 12 Oct 2025 18:50:11 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 12 Oct 2025 18:49:51 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[v1-visual-effects]]></title><description><![CDATA[This document captures visual rendering techniques from V1 to inform V2 renderer design. V1's render shader contained sophisticated visual effects that created distinct, animated appearances for different tile types.Source: Analysis of V1 render shader (src/graphics/shaders/render.wgsl)
Status: Reference material for V2 visual design decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 rendering code and hasn't been reviewed by the team.V1 Water Effect: Complex wave system using multiple sine functionsWave components (observed):
- Wave 1: sin(worldUV.x * 3.2 + time * 1.03) * 0.5 (primary horizontal)
- Wave 2: sin(worldUV.y * 14.0 - time * 1.3) * 0.25 (vertical fine)
- Wave 3: sin(worldUV.y * 8.3 + time * 1.5) * 0.25 (vertical medium)
- Wave 4: sin((worldUV.x + worldUV.y) * 13.7 - time * 0.8) * 0.15 (diagonal)
- Wave 5: sin((2.43 * worldUV.x + 3.0 * worldUV.y) * 15.5 - time * 1.2) * 0.12 (complex)
- Wave 6: sin((worldUV.x - 1.3 * worldUV.y) * 16.7 - time * 0.7) * 0.1 (counter-diagonal)
Personal Assessment: This created realistic water movement with multiple overlapping wave patterns.Color Blending System:Base colors: Deep blue (#0099CC) to cyan (#33CCFF)
Height mapping: Wave height influences color interpolation
Highlight system: White foam on wave peaks using smoothstep
My Interpretation: The multi-wave approach created natural-looking water with depth variation.Personal Note: V2 should consider similar layered animation techniques for environmental immersion.V1 Grass Blade Technique: Individual blade rendering within each tileBlade positioning: Offset by sine(time + worldUV.y * 2) for wind effect
Blade dimensions: Triangle-based blade shapes with height variation
Dual blade system: Two offset blade patterns per tile for density
Blade Generation Algorithm:Blade coordinate mapping: (worldUV * 10) % 1 for repeating pattern
Blade shape: 1 - abs(bladepos.x - 0.5) * 2 (triangle profile)
Height variation: bladepos.y-based cutting for blade tips
Wind animation: X-offset by sine function creates swaying
Personal Assessment: This created convincing grass appearance at the tile level.Color System:Base colors: Dark green (#1A4D33) to bright green (#19FF19)
Height-based mixing: Taller blade portions lighter
Highlight integration: White highlights on blade tips
My Interpretation: The procedural approach provided detailed grass without requiring texture assets.V1 Lava Effect: Similar wave system to water but with different parametersWave pattern: Subset of water waves (4 components instead of 6)
Color palette: Orange-red (#FF3300) to yellow-orange (#FFCC80)
Highlight system: Pink-magenta highlights (#FF80FF) on wave peaks
Personal Observation: Lava reused water's animation framework with different visual parameters.My Assessment: This suggests V2 could use unified animation systems with material-specific parameters.V1 Noise Functions: Multiple noise layers for various effectsBasic Perlin: Standard 2D Perlin noise with gradient interpolation
Fractal Brownian Motion (FBM): 4 octaves of layered noise
Hash function: Deterministic pseudo-random for gradient generation
Noise Applications Observed:
Mountain height maps with contour effects
Terrain distortion for organic tile boundaries
Texture variation within tile types
Personal Note: V2 should consider noise as a fundamental rendering primitive.V1 Distortion System: World UV coordinates modified by noiseDistortion calculation: Perlin noise at multiple scales
Application: UV += distortion_vector before tile sampling
Effect: Organic, non-grid-aligned visual boundaries
Personal Assessment: This helped disguise the underlying grid structure.Tile Edge Softening:Distance calculation: max(abs(tileUV.x-0.5), abs(tileUV.y-0.5)) * 2 - 0.2
Falloff function: 1 - pow(square_dist, 6.0)
Application: Multiply final color by falloff
My Interpretation: This created soft tile boundaries and visual cohesion.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These material observations need team consideration for V2 visual design.V1 Material Definitions:
Water: Blue spectrum with white foam highlights
Lava: Orange-red spectrum with magenta highlights
Magic: Purple-green spectrum (similar animation to water)
Grass: Green spectrum with procedural blade geometry
Void: Animated mountain texture with brown/purple palette
Personal Observation: Each material had distinct color relationships and animation characteristics.My Assessment: V2 should define similar material systems for consistent visual identity.V1 Color Blend Patterns:Height-based interpolation: mix(deepColor, lightColor, height_factor)
Highlight overlays: mix(baseColor, highlightColor, highlight_strength)
Time-based variation: Colors influenced by animation state
Personal Note: This created natural-looking material variation without texture sampling.Material Property System (inferred):
Base color ranges per material type
Animation amplitude and frequency per material
Highlight color and trigger thresholds per material
My Interpretation: V2 could benefit from similar parameterized material systems.V1 Shader Efficiency Patterns:
Switch statement for tile type selection (GPU-friendly branching)
Shared mathematical functions across material types
Single-pass rendering with material-specific logic branches
Personal Assessment: V1 balanced visual complexity with rendering performance.Mathematical Function Reuse:
Perlin noise used across multiple material types
Wave functions shared between water, lava, and magic
Color interpolation patterns repeated across materials
My Note: V2 should consider similar function reuse for consistency and performance.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Evidence: Complex mathematical calculations per pixel (6-wave water system, procedural grass, multi-octave noise)Personal Questions for V2:
Should V2 target similar visual complexity?
How will V2's 4-layer system affect rendering performance?
Will V2 support material-specific animation systems?
Research Needed: Performance testing of V1-style effects with V2's architecture.V1 Approach: Hardcoded material properties in shader switch statementsV2 Considerations:
Should V2 use similar hardcoded materials or data-driven systems?
How do V2's layers interact visually (transparency, blending)?
Will V2 support runtime material customization?
Personal Assessment: V2 might benefit from more flexible material systems than V1's hardcoded approach.V1 Time Usage: Global time parameter for synchronized animations across all tilesV2 Questions:]]></description><link>legacy/v1-visual-effects.html</link><guid isPermaLink="false">legacy/v1-visual-effects.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[v1-environmental-examples]]></title><description><![CDATA[This document captures environmental interaction patterns from V1 to inform V2 rule design. These examples demonstrate the complexity and emergent behaviors that V2's JSON compilation system should be capable of expressing.Source: Analysis of V1 game logic examples (src/game.ts lines 48-158)
Status: Reference patterns for V2 rule creationContributor: Claude Status: Individual analysis of V1 examplesPersonal Addition: This analysis of V1's environmental behaviors hasn't been discussed with the team.V1 Pattern Observed: Complex water behavior through multiple condition typesWater Flow Detection:Condition: Water north (distance 1) AND Water north (distance 2) AND NOT (Water northwest OR Water northeast)
Personal Interpretation: This created directional water flow by detecting "channels" without side branching.Water Pooling Detection:Condition: (Water north distance 1 OR 2) AND (Water east distance 1 OR 2) AND (Water south distance 1 OR 2)
My Assessment: This detected water collecting in corners or depressions.Water Pressure/Volume Detection:Condition: Water north AND Water east AND Water northeast AND (Water northwest OR Water southeast)
Personal Note: This seemed to detect "enough water pressure" for certain transformations.V1 Grass-to-Mud Pattern:
Trigger: Close to water (bias: +4, total reaction bias: -3)
Result: Net positive when water adjacent
Behavior: Grass becomes mud near water sources
V1 Mud-to-Water Pattern:
Multiple conditions: Water flow (+2), surrounded by water (+2), close to water (+5), close to sand (+2)
Base bias: -6 (requires multiple conditions to trigger)
Behavior: Mud liquefies under water pressure
V1 Mud-to-Grass Recovery:
Negative conditions: Close to water (-2), kind of close to water (-1), close to mud (-1)
Base bias: +2
Behavior: Mud dries to grass when water recedes
Personal Observation: This created realistic seasonal or drought cycles in terrain.V1 Water-to-Sand Pattern:
Negative scoring: All water-related conditions had negative values
Base bias: -1
Interpretation: Water became sand only when "water pressure" was low
V1 Sand-to-Water Pattern:
Condition: Surrounded by water (+2)
Base bias: -1
Behavior: Sand eroded when completely surrounded
V1 Sand-to-Grass Colonization:
Condition: Lots of grass nearby (+3)
Base bias: -2
Behavior: Vegetation gradually reclaimed sandy areas
Personal Assessment: This created believable geological processes.V1 Lava Spread Pattern:Condition: Lava northwest AND Lava northeast AND Lava north Pattern: Required 3 adjacent lava tiles in a row formation
Target: Grass tiles (turning them to lava)
Base bias: -1 (requiring the specific pattern to overcome)
Personal Interpretation: This created lava "fronts" that advanced in lines rather than randomly.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These behavioral observations need team discussion for V2 design.Multiple Transformations per Tile Type: V1 allowed each tile type to have multiple possible reactions with different conditions.Example - Grass Tile Transformations:
Grass → Mud (when near water)
Grass → Lava (when in lava line formation) Grass → Sand (when conditions met - though this was commented out)
Personal Observation: This created realistic environmental competition where multiple forces could affect the same terrain.Observed Pattern: Mud ↔ Grass ↔ Sand cycles
Wet seasons: Grass → Mud → Water
Dry seasons: Water → Sand, Mud → Grass
Vegetation recovery: Sand → Grass (slow colonization)
Personal Assessment: V1's bias system created natural environmental cycles without explicit seasonal programming.Pattern: Many transformations required specific neighbor counts or arrangements
Water flow: Exactly the right configuration
Lava spread: 3-tile line formation required
Vegetation growth: Multiple grass neighbors needed
My Interpretation: This prevented chaotic transformations and created stable intermediate states.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.Observed V1 Complexity:
Conditions checking multiple directions and distances
Logical combinations with AND, OR, NOT operators
Negative scoring for inhibitory effects
Distance-based neighbor detection (1 and 2 tiles away)
Personal Question: Can V2's JSON format express this level of spatial complexity?Example V1 Rule Expressed in Potential V2 JSON:{ "grass": [ { "id": "WaterFlow_Erosion", "action": {"type": "SetType", "new_type": "mud"}, "score_calculation": { "type": "Add", "children": [ {"type": "Constant", "value": -3}, { "type": "BooleanToValue", "condition": { "type": "AND", "children": [ {"type": "TileAt", "tile": "water", "direction": "N", "distance": 1}, {"type": "TileAt", "tile": "water", "direction": "N", "distance": 2}, { "type": "NOT", "child": { "type": "OR", "children": [ {"type": "TileAt", "tile": "water", "direction": "NW", "distance": 1}, {"type": "TileAt", "tile": "water", "direction": "NE", "distance": 1} ] } } ] }, "value_if_true": 4, "value_if_false": 0 } ] } } ]
}
Personal Concern: This JSON is already complex for a single V1 condition. V1 reactions had up to 16 conditions.V1 Optimization Evidence: Rules were pre-compiled into GPU textures
Complex conditions evaluated in parallel across all tiles
Shared memory caching for neighbor access
Personal Assessment: V2 needs comparable optimization strategies for similar environmental complexity.Research Needed: Performance testing of JSON compilation vs V1's direct GPU implementation.Identified by: Claude Status: Team input neededPersonal Assessment: V1 examples suggest specific environmental behavior goals that V2 should validate.
Geological cycles: Water erosion, sediment deposition, vegetation recovery
Competitive dynamics: Multiple environmental forces affecting same areas
Threshold stability: Avoiding chaotic oscillations between states
Directional flow: Water and lava following realistic propagation patterns
Team Discussion Needed: Should V2 target similar environmental realism?
How important are complex multi-condition interactions?
What level of rule complexity should V2 support?
V1 Evidence: Creating realistic environmental behaviors required intricate condition combinations and careful bias tuning.Personal Question: Will V2's visual editor be capable of creating rules of similar sophistication?Research Needed: UI/UX design for complex rule creation without overwhelming users.Personal Recommendations (not discussed with team):
Use V1 patterns as test cases for V2 JSON compilation system
Create V2 equivalents of key V1 environmental behaviors
Validate rule complexity limits early in V2 development
Design rule editor to handle spatial complexity observed in V1
Status: All recommendations need team review and design discussion.]]></description><link>legacy/v1-environmental-examples.html</link><guid isPermaLink="false">legacy/v1-environmental-examples.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[v1-gpu-patterns]]></title><description><![CDATA[This document captures GPU optimization strategies from V1 to inform V2 compute shader design. V1's reaction compute shader contained sophisticated optimization patterns that V2 developers should understand when designing the core engine's GPU architecture.Source: Analysis of V1 compute shader (src/graphics/shaders/reaction.wgsl)
Status: Reference material for V2 GPU architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 GPU code and hasn't been reviewed by the team.V1 Pattern Observed: Sophisticated neighborhood caching systemWorkgroup size: 8×8 threads (64 total)
Cache dimensions: 12×12 tiles (144 total)
Border padding: 2 tiles in each direction
Memory layout: array&lt;array&lt;u32, 12&gt;, 12&gt;
Caching Algorithm:
Each thread loads multiple cache pixels (144 pixels ÷ 64 threads = ~2.25 pixels per thread)
Linear cache index distribution across threads
Wrap-around coordinate calculation for world boundaries
Workgroup barrier synchronization before shared memory reads
Personal Assessment: This eliminated redundant texture reads for neighbor checks, likely providing significant performance benefits.My Interpretation: The 2-tile border allowed checking neighbors at distance 1 and 2 without additional texture fetches.V1 Coordinate Calculation Pattern:Global origin: workgroup_id * workgroup_size - cache_offset
Linear thread mapping: local_id.y * workgroup_size_x + local_id.x Wrap-around handling: (coord % tex_dims + tex_dims) % tex_dims
Personal Observation: This avoided branching and handled torus world topology efficiently.Cache Access Pattern:Cache position: local_coordinate + cache_offset + relative_neighbor_offset
No bounds checking: Relied on cache being large enough for all valid accesses
My Assessment: This trusted the cache dimensions to handle all possible neighbor accesses within the 2-tile radius.V1 Pattern: Dual texture approach for race condition prevention
Input texture: Read-only during compute pass
Output texture: Write-only during compute pass Swap textures between frames
Personal Note: This matches V2's planned ping-ponging strategy, validating the approach.Contributor: Claude Status: Individual analysis of GPU optimizationPersonal Addition: These observations from V1's data access patterns haven't been discussed with the team.V1 Approach: Minimize texture reads through strategic batchingRule data chunks: 3 texture reads for 9 leaf conditions (3 conditions per u32)
Chunk storage: array&lt;u32, 3&gt; for indexed access
Pre-computation: All rule data loaded before tree evaluation
Personal Interpretation: This reduced GPU memory bandwidth usage by batching related data.My Assessment: V2's rule compilation should consider similar data locality optimization.V1 Pattern: Efficient tree traversal without recursionNode results array: Fixed-size array for all tree nodes
Bottom-up evaluation: Leaves first (indices 7-15), then internal nodes (6 down to 0)
Loop-based traversal: Avoided GPU recursion limitations
Personal Note: This was a clever solution to GPU architectural constraints.My Concern: V2's JSON compilation needs similar tree evaluation efficiency.V1 Optimization: Early exit on symmetry successSymmetry loop: 8 iterations (rotations and reflections)
Early termination: Break immediately when any symmetry evaluates true
Result aggregation: OR operation across all symmetries
Personal Assessment: This reduced unnecessary computation when patterns matched early.What I Don't Know: Whether V2's compiled rules will include similar short-circuit optimizations.Contributor: Claude Status: Individual analysis of GPU synchronizationPersonal Addition: These synchronization observations need team consideration for V2.V1 Processing Phases:
Cache Loading Phase: All threads cooperatively load neighborhood data
Synchronization Barrier: workgroupBarrier() ensures cache completion
Independent Processing Phase: Each thread processes its assigned tile
Personal Observation: Clear separation between cooperative and independent work.My Interpretation: This maximized GPU efficiency by aligning with hardware capabilities.V1 Cache Loading Strategy:Work distribution: (cache_pixels + num_threads - 1) / num_threads // Ceiling division
Load balancing: Each thread loads 0-3 cache pixels depending on position
Bounds checking: Prevents threads from loading beyond cache dimensions
Personal Assessment: This ensured even work distribution across the workgroup.My Note: V2 should consider similar load balancing for any cooperative operations.V1 Synchronization Points:
Single workgroupBarrier() after cache loading
No additional barriers during tree evaluation
Independent tile processing without cross-thread communication
Personal Interpretation: Minimal synchronization overhead while ensuring data consistency.Personal Question: Will V2's active region system require additional synchronization?Contributor: Claude Status: Individual assessment needing team discussionPersonal Addition: These performance observations haven't been validated with actual measurements.V1 Work per Tile:
Reaction evaluation: Up to 8 reactions per tile type
Condition evaluation: Up to 16 conditions per reaction Symmetry testing: 8 geometric transformations per condition
Tree traversal: 7 internal nodes + 8 leaf evaluations
Personal Calculation: Worst case ~8×16×8×15 = 15,360 operations per tileMy Assessment: This suggests V1 could handle very complex environmental behaviors, but at computational cost.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations.V1 Memory Footprint per Workgroup:
Shared cache: 144 × 32-bit = 576 bytes
Node results array: 16 × 1-bit = 2 bytes (negligible)
Rule data cache: 3 × 32-bit = 12 bytes per condition
Personal Note: Shared memory usage was well within typical GPU limits.What I Don't Know: How V2's bit-packed tile format will affect memory access patterns.V1 Texture Access Patterns:
Input texture reads: 1 per cache pixel (coalesced across workgroup)
Rules texture reads: 4 per tile (base + 3 condition chunks)
Output texture writes: 1 per tile
Neighbor access: From cache (no additional texture reads)
Personal Assessment: Well-optimized memory access pattern with minimal bandwidth waste.My Concern: V2's 4-layer system may increase memory bandwidth requirements.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific GPU architecture considerations for V2.V1 Evidence: 8×8 workgroups with 12×12 cache worked well for 2-tile radius operationsResearch Questions for V2:
Should V2 use similar workgroup dimensions?
How does V2's active region system (32×32 chunks) align with workgroup sizes?
Will V2's tile operations require different neighbor access patterns?
Team Discussion Needed: Workgroup sizing based on V2's specific requirements.V1 Strategy: Heavy use of workgroup shared memory for cachingV2 Considerations:
Does V2's 4-layer system benefit from similar caching?
Should V2 cache active region metadata in shared memory?
How do V2's bit-packed tiles affect cache efficiency?
Research Needed: Performance testing of V2 memory access patterns.V1 Evidence: Minimal synchronization (single barrier) provided good performanceV2 Questions:
Will V2's physics integration require additional synchronization?
Does V2's active region updating need workgroup coordination?
Should V2 pipeline different processing phases differently?
Personal Assessment: V2 may need more complex synchronization than V1.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These design recommendations need team review before consideration.
Workgroup shared memory caching for neighbor access optimization
Phase-based processing with clear synchronization points Early exit optimizations where applicable
Texture ping-ponging (already planned for V2) Scale caching strategy for V2's 4-layer tile system
Integrate active region optimization with V1's workgroup patterns
Consider rule compilation targeting similar GPU optimization patterns Complexity vs Performance: V1 handled very complex rules - should V2 target similar capability?
Memory vs Computation: V1 used memory to reduce computation - is this optimal for V2?
Synchronization Overhead: Will V2's additional systems require more GPU barriers?
Status: All recommendations need team evaluation and design discussion.Personal Suggestions (not discussed with team):
Prototype V2 compute shaders using V1 optimization patterns as starting point
Benchmark memory access patterns for V2's bit-packed 4-layer system
Design active region processing to leverage V1's workgroup coordination strategies
Test synchronization requirements for V2's multi-system integration
Status: All suggestions need team review and implementation planning.]]></description><link>legacy/v1-gpu-patterns.html</link><guid isPermaLink="false">legacy/v1-gpu-patterns.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[v1-reference]]></title><description><![CDATA[This document captures fundamental concepts and mathematical algorithms from the V1 rules engine to inform V2 development. V1 contained sophisticated rule evaluation systems that V2 developers should understand when designing the JSON compilation pipeline.Source: Analysis of V1 legacy codebase (archived)
Status: Reference material for V2 design considerationContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 code and hasn't been reviewed by the team.V1 Approach: Rules were evaluated across 8 geometric transformations (4 rotations × 2 reflections) to create symmetric environmental behaviors.Mathematical Pattern Observed:Rotation calculation: (symmetry &gt;&gt; 1u) &lt;&lt; 1u // Even number rotations
Reflection: select(1, -1, (symmetry &amp; 1u) != 0u) // Flip on odd symmetries
Final position: scale * flip * base_direction_vector
My Assessment: This created natural-looking environmental effects where fire spreading, water flow, etc. worked consistently in all directions.Personal Concern: V2's JSON compilation needs to handle similar geometric transformations or environmental effects may look artificial.V1 Pattern: Complex conditions organized as binary trees with packed evaluation:
7 internal nodes (operators: AND, OR, NOR, NAND)
8 leaf nodes (spatial conditions)
Bottom-up evaluation from leaves to root
Data Packing Observed:
Internal node modes: 2 bits each, packed into 14 bits total
Leaf conditions: 9 bits each (5-bit tile type, 3-bit direction, 1-bit distance)
Evaluation results: Boolean array with indices mapping to tree structure
My Interpretation: This allowed arbitrarily complex logical conditions while maintaining GPU efficiency.Personal Question: How will V2's JSON compilation achieve similar complexity without runtime memory overhead?V1 Bias System:
Base reaction bias: signed 5-bit value (-16 to +15)
Condition contributions: signed values added when conditions met
Winning rule: highest total score after all conditions evaluated
Personal Observation: This created emergent behaviors where multiple environmental effects competed naturally (e.g., fire spreading vs water extinguishing).What I Don't Know: Whether V2's competitive scoring will replicate this mathematical sophistication.Contributor: Claude Status: Individual analysis of compute shaderPersonal Addition: These observations from V1's GPU implementation haven't been discussed with the team.V1 Pattern: 12×12 shared memory cache for 8×8 workgroup with 2-tile border
Each thread loads multiple cache pixels to fill neighborhood
Workgroup barrier synchronization before condition evaluation
Eliminates redundant texture reads for neighbor checks
My Assessment: This optimization was sophisticated and likely provided significant performance benefits.Personal Concern: V2 GPU shader design should consider similar caching strategies.V1 Approach: Pre-computed direction offset arrays with wrap-around handlingDirection offsets: 8 compass directions as vec2i
Wrap-around: (global_coord % tex_dims + tex_dims) % tex_dims
Cache position: local_coord + cache_offset + relative_position
Personal Note: This handled world boundaries elegantly while maintaining cache efficiency.V1 Pattern: Batch-loaded rule data chunks before evaluation
3 texture reads for all 9 possible leaf conditions
Stored in array for indexed access during tree evaluation
Minimized GPU texture bandwidth usage
My Interpretation: This was a carefully optimized memory access pattern.Contributor: Claude Status: Questions identified from V1 analysisPersonal Assessment: These issues need team discussion based on V1 complexity:Question: How will V2's JSON compilation handle the mathematical sophistication of V1's binary tree evaluation and 8-fold symmetry?V1 Evidence: Rules could express conditions like "fire spreads if 2+ fire neighbors AND no water within 2 tiles AND not in NW/NE corners"My Concern: V2 JSON format may need significant complexity to match V1 expressiveness.Question: Will V2 replicate V1's shared memory optimizations or use different strategies?V1 Evidence: Complex workgroup coordination and cache management in compute shaderPersonal Assessment: V2 might benefit from studying V1's memory access patterns before designing new shaders.Question: How will V2 ensure deterministic evaluation order that V1 achieved?V1 Evidence: Strict tile-by-tile processing with consistent neighbor checking orderWhat I Don't Know: Whether V2's approach will maintain this level of determinism.Identified by: Claude Status: Team input neededPersonal Assessment: V1 performance characteristics need measurement, but patterns suggest optimization priorities.
128×128 texture for rules (16,384 × 32-bit values = 64KB rule storage)
Workgroup shared memory: 144 × 32-bit values per workgroup
Dual texture ping-ponging: 2× map memory usage
My Interpretation: V1 traded memory for computational efficiency.Research Needed: Actual performance measurements and comparison with V2 targets.
8 symmetry evaluations per condition
Binary tree evaluation with up to 7 internal nodes
16 conditions maximum per reaction
8 reactions maximum per tile type
Personal Note: This suggests V1 could handle very complex environmental behaviors.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations for simplicity.Personal Recommendations (not discussed with team):
Study V1's mathematical patterns before finalizing JSON compilation approach
Consider V1's GPU optimization strategies for V2 shader architecture Evaluate whether V2 competitive scoring can achieve V1's sophistication
Plan for complexity testing to ensure V2 can handle intricate environmental behaviors
Status: All recommendations need team review and discussion.]]></description><link>legacy/v1-reference.html</link><guid isPermaLink="false">legacy/v1-reference.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[gameplay]]></title><description><![CDATA[Core game mechanics, rules, and design philosophy for Reaction v2.
<a class="internal-link" data-href="core-mechanics.md" href="gameplay/core-mechanics.html" target="_self" rel="noopener nofollow"><strong></strong></a>Core Mechanics - Victory conditions, timing, and elimination rules
Genre: Real-time PvP grid-based spellcasting game
Victory: Last player standing (avatar tile elimination)
Core Loop: Cast spells → Place runes → Transform environment → Tactical positioningNon-Turn-Based: Continuous simulation without traditional turns
Pre-Planning: Players can queue actions in advance
Dynamic Speed: Movement controlled by time delays between position updatesReactive World: Spells transform terrain according to rule-based systems
Terrain Types: Different tile types provide tactical advantages
Evolving World: Continuous world changes create evolving opportunitiesNo Scarcity: Unlimited mana regeneration - focus on timing over conservation
Recharge Timing: 3-turn recharge cycle provides natural rhythm
Allocation Choice: Specialization vs. flexibility in mana allocation]]></description><link>gameplay/gameplay.html</link><guid isPermaLink="false">gameplay/gameplay.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[legacy]]></title><description><![CDATA[Analysis of V1 system concepts and algorithms to inform V2 development decisions.
<a class="internal-link" data-href="v1-reference.md" href="legacy/v1-reference.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Rules Engine Reference - Mathematical algorithms and GPU optimization from rules system
<br><a class="internal-link" data-href="v1-environmental-examples.md" href="legacy/v1-environmental-examples.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Environmental Examples - Terrain interaction patterns and emergent behaviors
<br><a class="internal-link" data-href="v1-gpu-patterns.md" href="legacy/v1-gpu-patterns.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 GPU Optimization Patterns - Compute shader strategies and memory management
<br><a class="internal-link" data-href="v1-visual-effects.md" href="legacy/v1-visual-effects.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Visual Effects - Rendering techniques and material systems
<br><a class="internal-link" data-href="v1-data-strategies.md" href="legacy/v1-data-strategies.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Data Packing Strategies - Data organization and bit-packing techniques
Reference material extracted from V1 codebase to ensure V2 developers understand the complexity and sophistication of systems being replaced. ]]></description><link>legacy/legacy.html</link><guid isPermaLink="false">legacy/legacy.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[v1-data-strategies]]></title><description><![CDATA[This document captures data organization and packing techniques from V1 to inform V2's bit-packed tile system design. V1 demonstrated sophisticated GPU-optimized data structures that V2 developers should understand when designing the core engine's tile storage.Source: Analysis of V1 data structures (src/rules/rules.ts, src/core/types.ts, src/graphics/shaders/reaction.wgsl)
Status: Reference material for V2 data architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 data structures and hasn't been reviewed by the team.V1 Architecture: Rules stored as packed data in 128×128 GPU textureTexture format: r32uint (32-bit unsigned integers)
Total capacity: 16,384 × 32 bits = 64KB rule storage
Organization: 4 u32s horizontally per tile type, 16 vertically per reaction
Spatial Organization Pattern:X-axis: tile_type * 4 + data_column (0-3)
Y-axis: reaction_index * 16 + condition_index (0-15)
Data access: textureLoad(rules, vec2u(x_coord, y_coord))
Personal Assessment: This layout optimized GPU cache access for spatially-related rule queries.My Interpretation: The 4×16 block per reaction ensured related data stayed within GPU cache lines.V1 Condition Data Format (9 bits per leaf condition):Bit allocation:
- Tile type: 5 bits (0-31, accommodating enum value 20 for sand)
- Direction: 3 bits (8 compass directions) - Distance: 1 bit (1 or 2 tiles away) Packing formula: (tile_type &lt;&lt; 4) | (direction &lt;&lt; 1) | distance_bit
Personal Observation: This encoding maximized information density while staying within GPU bit manipulation capabilities.V1 Internal Node Encoding (2 bits per operator):Operator types: AND=0, OR=1, NOR=2, NAND=3
Packed format: 7 operators × 2 bits = 14 bits total
Storage: Combined with condition value in single u32
My Assessment: This allowed complex logical trees in minimal memory.V1 Reaction Block Format (4 u32s × 16 conditions):u32[0]: (modes &lt;&lt; 15) | (value &lt;&lt; 10) | (bias &lt;&lt; 5) | result_tile
u32[1]: leaf_conditions[0,1,2] packed as 3×9 bits + padding
u32[2]: leaf_conditions[3,4,5] packed as 3×9 bits + padding u32[3]: leaf_conditions[6,7,8] packed as 3×9 bits + padding
Personal Note: This distributed related data across multiple texture coordinates while maintaining efficient access.Packed Leaf Storage (3 conditions per u32):Bit layout per u32: [condition2][condition1][condition0][padding]
Bit offsets: 0, 9, 18 bits (LSB-first packing)
Extraction: (packed_data &gt;&gt; bit_offset) &amp; 0b111111111
My Interpretation: This maximized data density while allowing parallel condition evaluation.Contributor: Claude Status: Individual analysis of data flowPersonal Addition: These data access observations haven't been discussed with the team.V1 Rule Loading Strategy: Batch pre-fetch for condition evaluationRule queries per tile:
- Base reaction data: 1 texture read (bias, result_tile, modes)
- Leaf condition data: 3 texture reads (chunks 0-2, 3-5, 6-8)
- Total per condition: 4 texture reads maximum
Personal Assessment: This minimized GPU memory bandwidth by batching related reads.Cache-Friendly Access Pattern:Spatial locality: Consecutive X coordinates for condition chunks
Temporal locality: All rule data for one condition read together
Memory coalescing: Adjacent GPU threads access adjacent texture coordinates
My Interpretation: V1 was designed around GPU memory hierarchy optimization.V1 Initialization Approach: Pre-populate with "do nothing" defaultsDefault leaf value: tile=31, direction=0, distance=1 (encoded as 496)
Default packed chunk: 3 leaves = 130,277,872
Default condition modes: value=0, modes=0 (AND tree)
Personal Observation: This eliminated special case handling during rule evaluation.Bounds Safety Pattern:Out-of-bounds behavior: Default values ensure safe evaluation
Missing rules: "Do nothing" transformation (tile unchanged)
Invalid data: Graceful degradation rather than crashes
My Assessment: This defensive programming approach ensured robust GPU execution.Contributor: Claude Status: Individual analysis needing validationPersonal Addition: These efficiency observations need team discussion for V2 design.V1 Rule Capacity (calculated from observed limits):Maximum tile types: 32 (5-bit encoding)
Maximum reactions per type: 8
Maximum conditions per reaction: 16
Maximum tree complexity: 7 internal nodes + 8 leaves per condition
Storage Efficiency:Bits per condition: 32 × 4 = 128 bits
Information density: ~9 bits condition data + 14 bits modes + 10 bits scoring
Utilization: ~33 bits useful data / 128 bits storage ≈ 26% efficiency
Personal Assessment: V1 prioritized access speed over storage efficiency.My Interpretation: The 74% "waste" provided padding for GPU cache alignment and simplified addressing.V1 Memory Bandwidth Usage (estimated):Texture reads per tile evaluation:
- Rule base data: 1 × 32 bits = 32 bits
- Condition chunks: 3 × 32 bits = 96 bits - Shared cache reads: ~144 × 32 bits = 4,608 bits (amortized across workgroup)
Personal Calculation: ~128 bits rule data + ~72 bits shared cache per tileMy Assessment: V1's bandwidth usage was reasonable for the computational complexity achieved.V1 Scaling Limitations (observed):Rule texture size: Fixed 128×128 (no dynamic scaling)
Tile type limit: 32 types maximum (5-bit field)
Reaction complexity: 16 conditions maximum per reaction
Memory usage: Linear with rule complexity
Personal Concern: V1's fixed limits might not scale to V2's ambitions.Research Questions:
How do V1's limits compare to V2's requirements?
Should V2 use similar fixed-size allocations or dynamic scaling?
Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Approach: Complex multi-level packing with specialized extraction
V2 Planned: Bit-packed tiles with ~6 bits type + velocity + custom dataPersonal Questions:
Should V2 use V1's sophisticated bit manipulation techniques?
How will V2's 4-layer system affect packing complexity?
Will V2's real-time requirements allow V1-style complex unpacking?
My Assessment: V2 might benefit from simpler packing schemes than V1's intricate system.V1 Evidence: GPU texture storage with cache-optimized layout
V2 Plans: Texture ping-ponging with active region optimizationCompatibility Questions:
Can V2's active regions use V1's texture organization principles?
Should V2 pre-allocate like V1 or use dynamic allocation?
How do V2's performance targets compare to V1's memory usage patterns?
Team Discussion Needed: Memory allocation strategy for V2's different requirements.V1 Approach: Maximum density through complex bit manipulation
V2 Considerations: Balance between efficiency and implementation complexityPersonal Assessment: V1's approach was sophisticated but complex to implement and debug.Research Needed: Whether V2's requirements justify V1-level complexity.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific data design considerations for V2.V1 Evidence: Complex packing achieved high data density and good GPU performance
V2 Trade-offs: Implementation complexity vs memory/performance benefitsResearch Questions:
What are V2's memory constraints compared to V1?
How important is V1-level data density for V2's goals?
Should V2 prioritize development simplicity or runtime efficiency?
Team Discussion Needed: Performance requirements vs implementation complexity balance.V1 Success: Texture-based storage with spatial organization
V2 Considerations: How to adapt V1's principles to V2's 4-layer systemDesign Questions:
Should V2 layers share V1's texture organization approach?
How do V2's physics requirements affect data layout needs?
Will V2's active region system benefit from V1's spatial locality patterns?
Personal Assessment: V2 should consider adapting V1's spatial organization principles.V1 Limitations: Fixed sizes and hardcoded limits
V2 Opportunities: More flexible systems while preserving V1's efficiencyResearch Areas:
Dynamic data allocation vs V1's pre-allocation approach
Configurable complexity limits vs V1's hardcoded maximums
Runtime data modification vs V1's compile-time rule baking
Team Input Needed: V2's flexibility requirements vs performance constraints.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These data architecture recommendations need team review before consideration.
Spatial data organization for GPU cache efficiency
Batch data access to minimize memory bandwidth
Default value strategies for robust error handling
Bit-level packing where density justifies complexity Layer-aware organization for V2's 4-layer tile system
Active region integration with V1's spatial locality principles
Flexible scaling beyond V1's fixed limits
Simplified packing for easier development while preserving core efficiency Dynamic allocation instead of V1's fixed texture sizes
Configurable complexity instead of hardcoded limits
Development tools for debugging complex data structures
Performance monitoring for data access pattern optimization
Status: All recommendations need team evaluation and data architecture planning.Personal Suggestions (not discussed with team):
Prototype V2 bit-packing using lessons from V1's techniques
Benchmark data access patterns comparing V1 approaches with V2 requirements Design data validation tools to avoid V1's debugging complexity
Plan scalability testing for V2's data structures under various load scenarios
Status: All suggestions need team review and core engine architecture planning.]]></description><link>legacy/v1-data-strategies.html</link><guid isPermaLink="false">legacy/v1-data-strategies.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[development]]></title><description><![CDATA[Setup, workflow, and development processes for Reaction v2.
<a class="internal-link" data-href="getting-started.md" href="development/getting-started.html" target="_self" rel="noopener nofollow"><strong></strong></a>Getting Started - Project setup and first build
<br><a class="internal-link" data-href="DEVELOPMENT_PRINCIPLES.md" href="development/development_principles.html" target="_self" rel="noopener nofollow"><strong></strong></a>Development Principles - Core values and guidelines for contributors
<br><a class="internal-link" data-href="DOCUMENTATION_STRUCTURE.md" href="development/documentation_structure.html" target="_self" rel="noopener nofollow"><strong></strong></a>Documentation Structure - How to organize and navigate documentation <br><a class="internal-link" data-href="tasklist.md" href="development/tasklist.html" target="_self" rel="noopener nofollow"><strong></strong></a>Task List - Auto-generated TODO items, warnings, and documentation status
npm install
npm run dev # Development server
npm run test # Test suite npm run build # Production build
npm run lint # ESLint
npm run format # Prettier Core types: src/core/types.ts
Spell types: src/spell-system/types.ts
Documentation: docs/
Architecture: docs/architecture/
<br>See <a class="internal-link" data-href="DEVELOPMENT_PRINCIPLES.md" href="development/development_principles.html" target="_self" rel="noopener nofollow">Development Principles</a> for core values and <a class="internal-link" data-href="DOCUMENTATION_STRUCTURE.md" href="development/documentation_structure.html" target="_self" rel="noopener nofollow">Documentation Structure</a> for information organization guidelines.]]></description><link>development/development.html</link><guid isPermaLink="false">development/development.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[getting-started]]></title><description><![CDATA[Project setup and development environment configuration for Reaction v2.
Node.js: Latest LTS version recommended
npm: Comes with Node.js installation
WebGPU-compatible browser: Chrome 113+, Firefox 113+, or Safari Technology Preview GPU: WebGPU-compatible graphics card
Memory: 8GB+ RAM recommended for development
Storage: 2GB+ free space for dependencies and build artifacts
npm install
npm run dev
This starts the development server with hot reload and debugging enabled.
Open browser to development server URL (usually http://localhost:5173)
Check browser console for WebGPU support
Verify no initial compilation errors
npm run dev # Development server with hot reload
npm run test # Run test suite
npm run build # Production build
npm run lint # ESLint code checking npm run format # Prettier code formatting
.
├── src/ # Source code
│ ├── core/ # Core Engine module
│ ├── spell-system/ # Spell System module │ ├── physics-engine/ # Physics Engine module
│ ├── reaction-engine/ # Reaction Engine module
│ ├── renderer/ # Renderer module
│ └── tools/ # Development tools
├── docs/ # Documentation
├── tests/ # Test files
└── package.json # Project configuration
Problem: Browser doesn't support WebGPU
Solution: Use Chrome 113+, Firefox 113+, or enable experimental featuresProblem: TypeScript compilation errors
Solution: Run npm run lint and fix reported issuesProblem: Development server running slowly
Solution: Close other applications, check GPU drivers are updated
Read Architecture: Start with cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/overview.html" data-href="overview" aria-label="overview" data-tooltip-position="top" target="_self">Architecture Overview</a>
Explore Systems: Browse individual system documentation
Run Tests: Verify everything works with npm run test
Make Changes: Try modifying code and see hot reload in action
⚠️ SUGGESTION: Consider establishing:
IDE configuration and recommended extensions
WebGPU debugging extensions
Performance profiling tools
GPU shader debugging setup
]]></description><link>development/getting-started.html</link><guid isPermaLink="false">development/getting-started.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[tasklist]]></title><description><![CDATA[Automatically generated task list from all TODO items found in the documentation using Dataview.Summary of documentation completion status:Organized view of TODO items grouped by file:<a data-tooltip-position="top" aria-label="architecture/systems/config/config.md" data-href="architecture/systems/config/config.md" href="architecture/systems/config/config.html" class="internal-link" target="_self" rel="noopener nofollow">config</a>: Define configuration system architectureDocument configuration file formatsAdd runtime configuration managementDocument environment-specific settings<br><a data-tooltip-position="top" aria-label="docs.md" data-href="docs.md" href="docs.html" class="internal-link" target="_self" rel="noopener nofollow">docs</a>: Complete main documentation indexAdd project overview sectionAdd getting started quick links<br><a data-tooltip-position="top" aria-label="architecture/general/ghost-simulation.md" data-href="architecture/general/ghost-simulation.md" href="architecture/general/ghost-simulation.html" class="internal-link" target="_self" rel="noopener nofollow">ghost-simulation</a>: NEEDS IMPLEMENTATION: Performance benchmarking of different complexity levelsNEEDS IMPLEMENTATION: User experience testing of ghost feedback effectivenessNEEDS IMPLEMENTATION: Integration testing with action queue and timing systems<br><a data-tooltip-position="top" aria-label="architecture/general/state-management.md" data-href="architecture/general/state-management.md" href="architecture/general/state-management.html" class="internal-link" target="_self" rel="noopener nofollow">state-management</a>: NEEDS IMPLEMENTATION: Performance benchmarking of snapshot creation overheadNEEDS IMPLEMENTATION: Network bandwidth testing with delta compressionNEEDS IMPLEMENTATION: Cross-platform determinism validation suite<br><a data-tooltip-position="top" aria-label="architecture/systems/ui/ui.md" data-href="architecture/systems/ui/ui.md" href="architecture/systems/ui/ui.html" class="internal-link" target="_self" rel="noopener nofollow">ui</a>: Define UI system architectureDocument component hierarchyAdd interaction patternsDocument accessibility requirements<br><a data-tooltip-position="top" aria-label="architecture/general/variable-timing.md" data-href="architecture/general/variable-timing.md" href="architecture/general/variable-timing.html" class="internal-link" target="_self" rel="noopener nofollow">variable-timing</a>: NEEDS IMPLEMENTATION: Detailed performance benchmarking of time slice overheadNEEDS IMPLEMENTATION: Integration testing with existing Core Engine texture managementNEEDS IMPLEMENTATION: Multiplayer synchronization validationFiles with warnings or items requiring team discussion:<br><a data-tooltip-position="top" aria-label="architecture/general/data-flow.md" data-href="architecture/general/data-flow.md" href="architecture/general/data-flow.html" class="internal-link" target="_self" rel="noopener nofollow">data-flow</a>: OUTDATED DOCUMENT: Physics system has been updated and this document no longer reflects current architectural directionNEEDS TEAM DISCUSSION: Optimal time slice count (8 vs 4 vs 16)NEEDS TEAM DISCUSSION: Performance impact of deterministic GPU orderingNEEDS TEAM DISCUSSION: Ghost simulation complexity vs performance trade-offs<br><a data-tooltip-position="top" aria-label="architecture/general/ghost-simulation.md" data-href="architecture/general/ghost-simulation.md" href="architecture/general/ghost-simulation.html" class="internal-link" target="_self" rel="noopener nofollow">ghost-simulation</a>: PROPOSED SYSTEM: Predictive action visualization system shows players their queued actionsNEEDS TEAM DISCUSSION: Default simulation complexity level (minimal/basic/detailed)NEEDS TEAM DISCUSSION: Ghost prediction accuracy vs performance trade-offsNEEDS TEAM DISCUSSION: Visual design for ghost representation (transparency, colors, indicators)<br><a data-tooltip-position="top" aria-label="architecture/general/state-management.md" data-href="architecture/general/state-management.md" href="architecture/general/state-management.html" class="internal-link" target="_self" rel="noopener nofollow">state-management</a>: PROPOSED SYSTEM: Unified state management approach serves both single-player and multiplayerNEEDS TEAM DISCUSSION: Snapshot retention policy (current proposal: 5 seconds)NEEDS TEAM DISCUSSION: Delta compression vs full snapshot frequency (current proposal: every 60 frames)NEEDS TEAM DISCUSSION: Rollback window limits for client prediction<br><a data-tooltip-position="top" aria-label="architecture/general/variable-timing.md" data-href="architecture/general/variable-timing.md" href="architecture/general/variable-timing.html" class="internal-link" target="_self" rel="noopener nofollow">variable-timing</a>: PROPOSED SYSTEM: Time slice scheduling system enables variable player action timingNEEDS TEAM DISCUSSION: Optimal slice count (current proposal: 8 slices per frame)NEEDS TEAM DISCUSSION: Speed multiplier ranges (current proposal: 0.1x to 10x)NEEDS TEAM DISCUSSION: Ghost prediction complexity vs performance trade-offsFiles marked as stubs that need to be completed:Note: This task list is automatically generated using Dataview queries. Add todo: fields to any documentation file's frontmatter to have items appear here automatically.Usage: Add TODO items to file frontmatter: todo: ["Item 1", "Item 2"]
Mark files as stubs: status: stub
Items will automatically appear in the appropriate sections above
]]></description><link>development/tasklist.html</link><guid isPermaLink="false">development/tasklist.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[core-mechanics]]></title><description><![CDATA[Elimination: Last player standing wins. Players are eliminated when their avatar tile is destroyed.Duration: Unlimited match length - games end only when elimination occurs
Player Count: Variable player count, limited only by performance constraints
Real-Time Execution: Continuous simulation without traditional turnsNon-Turn-Based: Game runs continuously with different processes at different frequencies
Pre-Planning: Players queue actions in advance
Execution Timing: Player actions execute at regular intervals determined by game state
Dynamic Speed: Object movement speed controlled by time delays between tile position updates
Status Effects: Players can be slowed, frozen, or otherwise affected by spells and environmentPlayer → Spell → World → Player: Clear action consequence chain
Player casts spell
Spell affects world tiles and environment
World changes affect all players through environmental interactions
Player Tiles: Players exist as tiles on the object layer
Physics Only: Player avatars affected by physics (velocity, collisions, forces) but never transform into other tile types
Damage System: Players can take damage and be destroyed but maintain their tile type while alive
Movement: Players move using same physics system as other object layer tilesDamage Sources: Tiles can deal damage, apply slow effects, or other status conditions to players
Healing: Either no healing mechanics, or healing through specific terrain tiles
Regeneration Strategy: No health regeneration vs. tile-based healing zones (to be playtested)
Destruction: Players eliminated when health reaches zero, but tile type never changesPhysics-Driven: Maps generated through built-in physics simulation and tile reactions
Emergent Terrain: World evolves naturally through rule-based transformations
Dynamic Environment: Continuous world changes create evolving strategic opportunitiesStrategic Terrain: Different tile types provide tactical advantages and challenges
Reactive Tiles: Special tiles that explode, ignite, or transform when targeted by spells
Environmental Interactions: Terrain affects tactical gameplay
Spell-Terrain Synergy: Spells designed to interact meaningfully with terrain typesSize: To be determined through playtesting for optimal performance and gameplay balance
Performance Scaling: Map size limited by ability to maintain 60 FPS with active player countNo Scarcity: Unlimited mana flower regeneration - focus on timing and positioning over resource conservation
Mana Recharge: 3-turn recharge cycle provides natural pacing without creating resource pressureTile-Based Escalation: Environmental changes naturally create pressure and opportunities
No Regeneration Alternative: Potential no-healing system to ensure permanent consequences
Environmental Pressure: Reactive terrain and ongoing world changes prevent static positioningBalanced Design: Spells designed for diverse strategies
Situational Advantage: Different spells excel in different terrain and tactical situations
No Power Creep: Focus on interesting combinations rather than raw damage scaling
Terrain Understanding: Learning different tile type behaviors
Spell Combinations: Combining rune effects Positioning: Tactical movement and area control
Timing: Execution of pre-planned actions at optimal moments
Environmental Prediction: Anticipating world changes and terrain evolution Rule Interactions: Complex behaviors arising from rule combinations
Adaptive Strategy: Changing world state requires flexible tactical adaptation
Risk/Reward: Curse system and aggressive positioning create choices
Long-term Planning: Pre-planning system rewards strategic foresight
]]></description><link>gameplay/core-mechanics.html</link><guid isPermaLink="false">gameplay/core-mechanics.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[tools]]></title><description><![CDATA[Status: Incomplete documentation The Tools system provides development utilities and visual editing capabilities for Reaction v2.The tools system includes:
Visual rule editor for creating and testing transformation rules
Development debugging utilities
Performance profiling tools
Asset management utilities
Documentation incomplete - editor interface and functionality to be detailedDocumentation incomplete - debugging and profiling tools to be documentedDocumentation incomplete - asset processing and management tools to be added]]></description><link>architecture/systems/tools/tools.html</link><guid isPermaLink="false">architecture/systems/tools/tools.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[ui]]></title><description><![CDATA[Status: 🚧 Stub - This system documentation needs completionUser interface system for game controls, HUD elements, and player interaction.TODO: Add links to UI components when implemented:
Interface layout and component hierarchy
Input handling and interaction patterns
HUD elements and game overlays
Menu systems and navigation
TODO: Document UI system responsibilities:
Game HUD: Mana flowers, spell hand, player status indicators
Game Controls: Spell casting interface, movement controls, action queuing
Menu Systems: Main menu, settings, deck building, game lobby
Visual Feedback: Action confirmations, error states, loading indicators
TODO: Define major UI components:
Mana Flower Display: Visual representation of mana types and recharge status
Spell Hand Interface: Spell selection and casting controls
Grid Overlay: Tile highlighting, targeting cursors, range indicators
Action Queue Visualization: Preview of queued player actions
Game Status: Timer, player health, elimination status
TODO: Add design guidelines:
Clarity: Clear visual hierarchy and information priority
Responsiveness: Immediate feedback for all player actions
Accessibility: Keyboard navigation, screen reader support, color accessibility
Scalability: Support for different screen sizes and resolutions
TODO: Document system integrations:
Input System: Mouse, keyboard, and touch input handling
Renderer: UI rendering pipeline and performance considerations
Game State: Real-time updates from game simulation
Spell System: Integration with spell casting and mana management
🚧 This file is a stub and needs completion]]></description><link>architecture/systems/ui/ui.html</link><guid isPermaLink="false">architecture/systems/ui/ui.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[DEVELOPMENT_PRINCIPLES]]></title><description><![CDATA[
Never fabricate performance numbers, statistics, or benchmarks
Mark personal ideas as such - don't present speculation as team decisions
Say "I don't know" when you don't know
Uncertainty is better than false confidence Code should explain itself through naming and structure
If you need extensive comments to explain what code does, rewrite it
Magic numbers and unclear constants are tech debt
Optimize for the next person who reads your code Distinguish between your ideas and team decisions
Make it easy for others to understand and build on your work
Ask questions when design decisions aren't clear
Share context behind your choices Use descriptive names for functions, variables, and files
Handle error cases explicitly - don't ignore or hide failures
Prefer simple, obvious solutions over clever optimizations
Document the "why" behind non-obvious business logic Be honest about what's decided vs. what you're proposing
Include enough context for someone to understand and challenge your reasoning
Avoid inventing performance claims or user behavior assumptions
Note when something needs team input or further research Understand the problem before jumping to solutions
Consider the person who will maintain this code in 6 months
Choose consistency with existing patterns over personal preference
Measure performance claims rather than guessing Write clear, descriptive commit messages that explain the "why" not just the "what"
Make atomic commits - each commit should represent one logical change
Never commit broken code or failing tests to main branch
Use branches for feature development and merge via pull requests
Review your own changes before committing - check diffs carefully
Keep commits focused - avoid mixing unrelated changes
Test your changes locally before pushing
Before committing work, ask:
Can someone else understand this without asking me questions?
Am I making any claims I can't back up?
Is this the simplest solution that solves the actual problem?
Have I clearly indicated what needs team discussion?
Are my commit messages clear and descriptive?
Have I tested my changes locally?
The goal is sustainable development where team members can confidently build on each other's work.]]></description><link>development/development_principles.html</link><guid isPermaLink="false">development/DEVELOPMENT_PRINCIPLES.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[DOCUMENTATION_STRUCTURE]]></title><description><![CDATA[Documentation should function as a navigational search tree where each level provides just enough information to guide readers to the right destination.Parent nodes are signposts, not encyclopedias
Overview documents help readers navigate to specifics
Include enough detail to make informed navigation choices
Avoid comprehensive coverage at high levels
No redundant information
Each piece of information has one authoritative location
Link to sources rather than copying content
Update links when information moves
Hierarchical information flow
Overview → Category → Implementation Details
General concepts → Specific examples
Architecture → Component details
Overview Documents
List what's covered and where to find it
Provide context for understanding relationships
Include links to detailed documentation
Don't duplicate content from linked pages
Category Documents
Explain concepts specific to that category
Direct readers to implementation details
Show how pieces relate within the category
Link to related categories when relevant
Detail Documents
Contain complete implementation information
Reference but don't duplicate architectural context
Link back to parent concepts when helpful
Focus on specific, actionable content
Top-Down Discovery
Start with high-level goals or concepts
Follow links to increasingly specific information
Each level adds detail without repeating previous levels
Cross-Referencing
Link to related concepts at the same level
Reference authoritative sources for shared information
Avoid circular documentation dependencies
Maintenance
When information changes, update it in one place
Check that navigation paths remain clear
Remove or redirect broken internal links
Ensure new content fits the existing hierarchy
The goal is that readers can efficiently find exactly what they need without encountering duplicate or outdated information.]]></description><link>development/documentation_structure.html</link><guid isPermaLink="false">development/DOCUMENTATION_STRUCTURE.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[spells]]></title><description><![CDATA[Player-controlled spellcasting, mana management, and rune interactions.Player-controlled spellcasting with resource management and rune interactions.Design Goal: CPU-based processing allows flexible spell logic without GPU shader constraints.
Mana flower economy and recharge timers
Spell validation and execution
Rune lifecycle management (placement, delay, triggering, combinations)
Deck building and curse system
Player customization options <a class="internal-link" data-href="mana-system.md" href="architecture/systems/spells/mana-system.html" target="_self" rel="noopener nofollow"><strong></strong></a>Mana System - Flower economy and recharge mechanics
<br><a class="internal-link" data-href="spells-and-runes.md" href="architecture/systems/spells/spells-and-runes.html" target="_self" rel="noopener nofollow"><strong></strong></a>Spells and Runes - Casting mechanics and rune lifecycle
<br><a class="internal-link" data-href="customization.md" href="architecture/systems/spells/customization.html" target="_self" rel="noopener nofollow"><strong></strong></a>Customization - Deck building and curse system
<br><a class="internal-link" data-href="cpu-architecture.md" href="architecture/systems/spells/cpu-architecture.html" target="_self" rel="noopener nofollow"><strong></strong></a>CPU Architecture - Processing model and integration
See individual component documentation for detailed mechanics:
<br><a class="internal-link" data-href="mana-system.md" href="architecture/systems/spells/mana-system.html" target="_self" rel="noopener nofollow">Mana System</a> - Resource management and recharge cycles
<br><a class="internal-link" data-href="spells-and-runes.md" href="architecture/systems/spells/spells-and-runes.html" target="_self" rel="noopener nofollow">Spells and Runes</a> - Casting mechanics and rune interactions Pre-game Selection: Choose spells from available collection
Deck Constraints: ⚠️ NEEDS DISCUSSION - Specific deck building rules TBD
Spell Relationships: ⚠️ SUGGESTION - Consider thematic spell interactions Risk/Reward: Power vs. risk trade-offs
Build Balance: ⚠️ NEEDS DISCUSSION - Balance between pure and cursed builds
Implementation: ⚠️ NEEDS DESIGN - Specific curse mechanics and effects
<br>CPU-Only Design: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/technical-decisions.html" data-href="technical-decisions" target="_self">technical-decisions</a> for processing architecture rationale.
Core Engine: Direct texture writes to rune layer KeyValue
Physics Engine: Queue forces for tile movement
Player Input: Immediate response to spell casting actions Core Engine: Required for rune placement and tile data access
User Interface: Integration with spell hand and mana flower display
]]></description><link>architecture/systems/spells/spells.html</link><guid isPermaLink="false">architecture/systems/spells/spells.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[spells-and-runes]]></title><description><![CDATA[Casting mechanics, rune lifecycle, and spell combinations.
Selection: Player chooses spell from hand
Validation: Check mana cost and target range
Execution: Place runes according to spell pattern
Cost: Exhaust required mana flowers
Cooldown: Start mana flower recharge timers Mana Cost: Specific mana types and quantities required
Range: Maximum targeting distance from caster
Pattern: Grid layout of runes placed around target
Effects: Rune types, forces, and delays in pattern
Mana Requirements: Must have sufficient flowers of correct types
Range Limits: Target must be within spell's maximum range
Obstruction Checks: ⚠️ NEEDS DESIGN - Line of sight or other targeting restrictions
Cooldown Status: Cannot cast if required mana flowers still recharging
Type: Determines transformation effects (fire, ice, force, etc.)
Force: Velocity applied when triggered Delay: Countdown timer before activation Placement: Created by spell casting on rune layer
Delay: Countdown each CPU processing cycle
Triggering: Apply transformations and forces when delay reaches zero
Combination: Merge with other runes on same tile
Removal: Clean up spent runes after effects applied
Purpose: Create spell combinations.Automatic Merging: Multiple runes on same tile combine automatically
Force Combination: Result has combined force vectors
Delay Resolution: Combined rune uses minimum delay of components
Type Resolution: New type determined by combination rules table⚠️ NEEDS SPECIFICATION: Detailed combination rules and outcomesFire + Water: Steam rune with area effect
Earth + Air: Dust storm with movement effects
Force + Force: Amplified knockback effects
Conflicting Types: Some combinations may cancel forces or produce no runeSimple Rules: Basic combination table creates complex interactions
Strategic Depth: Players can plan multi-spell combinations
Unpredictable Results: Opponent spells can interfere with combinations
Hand Size: ⚠️ TBD based on UI and gameplay needs
Replenishment: Draw from personal spell deck each turn
Deck Construction: Pre-game selection from available spells
Turn-based Drawing: New spells available each turn
Deck Cycling: ⚠️ NEEDS DESIGN - What happens when deck is exhausted?
Hand Limits: Maximum spells available at once for UI and balanceForce Application: Runes queue forces for physics processing
Timing Coordination: Rune triggers coordinate with physics updates
Movement Effects: Spell effects can alter tile velocitiesEnvironmental Triggers: Runes can trigger environmental transformations
Rule Interactions: Spell effects interact with world transformation rules
Compound Effects: Spells + environment create complex interactionsRune Placement: Direct texture writes to rune layer
State Queries: Read tile data for spell validation
Layer Coordination: Ensure proper interaction between spell effects and world stateComplex Logic: Conditional spell rules without shader limitations
Easy Debugging: Step-through debugging of spell logic
Immediate Response: No GPU compilation delays for spell modifications
Dynamic Rules: Runtime spell behavior changes possible⚠️ FUTURE CONSIDERATION: Moving some spell processing to GPU if CPU becomes bottleneck
Simple rune countdown could be GPU-accelerated
Complex combination logic likely remains CPU-bound
⚠️ NEEDS RESOLUTION:
Hand Size Balancing: Too many spells overwhelming, too few limiting strategy
Deck Exhaustion: What happens when player runs out of spells?
Combination Complexity: How complex should rune interactions become?
Performance Scaling: CPU spell processing vs. large numbers of active runes
]]></description><link>architecture/systems/spells/spells-and-runes.html</link><guid isPermaLink="false">architecture/systems/spells/spells-and-runes.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[systems]]></title><description><![CDATA[Complete documentation for the Reaction v2 game engine.
<a class="internal-link" data-href="core/core.md" href="architecture/systems/core/core.html" target="_self" rel="noopener nofollow"><strong></strong></a>Core Engine - Central coordination and tile data management
<br><a class="internal-link" data-href="spells/spells.md" href="architecture/systems/spells/spells.html" target="_self" rel="noopener nofollow"><strong></strong></a>Spell System - Player spellcasting and mana management
<br><a class="internal-link" data-href="physics/physics.md" href="architecture/systems/physics/physics.html" target="_self" rel="noopener nofollow"><strong></strong></a>Physics Engine - GPU-accelerated tile movement and collisions
<br><a class="internal-link" data-href="reactions/reactions.md" href="architecture/systems/reactions/reactions.html" target="_self" rel="noopener nofollow"><strong></strong></a>Reaction Engine - Rule-based environmental transformations
<br><a class="internal-link" data-href="rendering/rendering.md" href="architecture/systems/rendering/rendering.html" target="_self" rel="noopener nofollow"><strong></strong></a>Renderer - Visual display and UI rendering
<br><a class="internal-link" data-href="multiplayer/multiplayer.md" href="architecture/systems/multiplayer/multiplayer.html" target="_self" rel="noopener nofollow"><strong></strong></a>Multiplayer - Real-time PvP networking and client prediction
<br><a class="internal-link" data-href="ui/ui.md" href="architecture/systems/ui/ui.html" target="_self" rel="noopener nofollow"><strong></strong></a>User Interface - Game controls, HUD elements, and player interaction
<br><a class="internal-link" data-href="config/config.md" href="architecture/systems/config/config.html" target="_self" rel="noopener nofollow"><strong></strong></a>Configuration - System settings and runtime parameters
<br><a class="internal-link" data-href="gpu/gpu.md" href="architecture/systems/gpu/gpu.html" target="_self" rel="noopener nofollow"><strong></strong></a>GPU Manager - WebGPU resource management and coordination
<br><a class="internal-link" data-href="tools.md" href="architecture/systems/tools/tools.html" target="_self" rel="noopener nofollow"><strong></strong></a>Tools - Development utilities and visual rule editor <br>cross-reference<a rel="noopener nofollow" class="internal-link" href="legacy/legacy.html" data-href="legacy" aria-label="legacy" data-tooltip-position="top" target="_self">Legacy V1 Analysis</a> - V1 system concepts for V2 development reference <br>cross-reference<a rel="noopener nofollow" class="internal-link" href="gameplay/gameplay.html" data-href="gameplay" aria-label="gameplay" data-tooltip-position="top" target="_self">Gameplay Mechanics</a> - Core rules and player systems
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="development/development.html" data-href="development" aria-label="development" data-tooltip-position="top" target="_self">Development Workflow</a> - Setup, testing, and build processes <br>New to the project? Start with <a class="internal-link" data-href="architecture/overview.md" href=".html" target="_self" rel="noopener nofollow">Architecture Overview</a>
<br>Want to contribute? See cross-reference<a rel="noopener nofollow" class="internal-link" href="development/getting-started.html" data-href="getting-started" aria-label="getting-started" data-tooltip-position="top" target="_self">Development Getting Started</a> and cross-reference<a rel="noopener nofollow" class="internal-link" href="development/development_principles.html" data-href="DEVELOPMENT_PRINCIPLES" aria-label="DEVELOPMENT_PRINCIPLES" data-tooltip-position="top" target="_self">Development Principles</a>
Looking for specific system? Use the navigation above
]]></description><link>architecture/systems/systems.html</link><guid isPermaLink="false">architecture/systems/systems.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[cpu-architecture]]></title><description><![CDATA[Processing model and integration approach for the spell system's CPU-based design.Initial Decision: Initially chosen for CPU because it handles direct player input and seemed more straightforward to implement. This choice may be revisited during implementation.Current Advantages:
Complex conditional logic: Spell rules without GPU shader limitations
Easy debugging: Step-through debugging and rule modification
Immediate response: Direct response to player input without GPU compilation delays
Runtime flexibility: Dynamic spell behavior changes possible
⚠️ POTENTIAL FUTURE CHANGE: Moving some spell processing to GPU if CPU becomes performance bottleneck
Simple Operations: Rune countdown timers could be GPU-accelerated
Complex Logic: Combination rules and validation likely remain CPU-bound
Hybrid Approach: CPU for logic, GPU for simple state updates
Input Phase: Process player spell casts and UI interactions during input processing phase
Rune Phase: Handle rune countdown and triggering during dedicated rune processing phase
Coordination: Seamless integration with GPU-based physics and reaction systems⚠️ NEEDS SPECIFICATION: Approach to concurrent spell processing
Multi-threading: Can spell logic be parallelized safely?
State Isolation: Ensure thread safety for simultaneous spell processing
Performance Scaling: CPU utilization across multiple player actions
Rune Placement: Direct texture writes to rune layer
Texture Access: CPU writes directly to GPU texture memory
Synchronization: Coordinate with GPU texture ping-ponging system
Error Handling: Manage GPU resource allocation failures
State Queries: Read tile data for spell validation
Cache Strategy: Minimize CPU-GPU memory transfers
Data Freshness: Ensure CPU reads current game state
Performance Impact: Balance query frequency vs. accuracy
Force Application: Queue forces for physics engine processing
Force Buffer: Accumulate forces from multiple spell sources
Timing Coordination: Ensure forces apply at correct physics update
Vector Math: Proper force calculation and combination
Read Operations: CPU reads game state for spell validation
Write Operations: CPU writes rune data and force applications
Synchronization: Coordinate with GPU pipeline phasesSpell Complexity: Complex spells may create CPU bottlenecks
Player Scaling: Performance impact of multiple simultaneous players
Rune Management: Cost of tracking many active runes across players⚠️ SUGGESTIONS for potential CPU optimizations:
Caching: Cache frequently-accessed tile data
Batching: Group multiple spell operations for efficiency Lazy evaluation: Delay expensive calculations until needed
State compression: Efficient rune data representations
⚠️ NEEDS SPECIFICATION: Efficient data transfer patterns
Transfer Minimization: Reduce CPU-GPU memory bandwidth usage
Buffer Management: Proper GPU buffer allocation and lifecycle
Memory Mapping: Efficient access to GPU texture data from CPU
Active Rune Tracking: CPU data structures for rune management
Lifecycle Management: Efficient creation and cleanup of rune objects
Memory Pooling: Reuse memory allocations for performanceMana Verification: Ensure sufficient mana flowers available
Range Checking: Validate spell targets within allowed range
Obstruction Testing: ⚠️ NEEDS DESIGN - Line of sight or targeting rules
Cooldown Enforcement: Prevent casting during mana rechargeGPU Communication Failures: Handle GPU resource unavailability
Invalid State Recovery: Respond to corrupted game state
Player Disconnection: Manage spells from disconnected players
Performance Degradation: Respond to CPU performance bottlenecksStep-through Debugging: Full debugging support for spell logic
State Inspection: Real-time examination of spell and rune state
Performance Profiling: CPU usage monitoring and bottleneck identification
Logic Tracing: Track spell execution and rule application
Rapid iteration: Quick testing of new spell mechanics
Rule modification: Runtime changes to spell behavior possible
Complex logic: Support for complex spell interactions
Integration testing: Easy testing of CPU-GPU coordination
⚠️ POTENTIAL EVOLUTION: Areas where GPU processing might be beneficial
Simple State Updates: Rune countdown timers
Parallel Operations: Multiple rune processing simultaneously Mathematical Operations: Complex force calculations
Player Count Scaling: CPU performance with many simultaneous players
Spell Complexity Growth: Performance impact of increasingly complex spells
Real-time Requirements: Maintaining responsiveness under load]]></description><link>architecture/systems/spells/cpu-architecture.html</link><guid isPermaLink="false">architecture/systems/spells/cpu-architecture.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[customization]]></title><description><![CDATA[Deck building and curse mechanics for player customization and risk/reward gameplay.
Spell Collection: Players build from available spell library
Pre-game Construction: Deck built before match starts
Strategic Focus: Deck size limits encourage focused strategies
Synergistic Design: Spells designed to work together thematically
⚠️ NEEDS SPECIFICATION: Specific deck building rules
Deck Size: Minimum and maximum spell counts TBD
Duplicate Limits: How many copies of same spell allowed?
Rarity System: Different spell availability or costs?
Mana Balance: Requirements for mana type distribution?
⚠️ NEEDS DESIGN: How players acquire new spells for their collection
Progression System: Unlock spells through gameplay?
Default Collection: Starting spells available to all players?
Expansion Content: New spells added over time?
Power vs. Risk: Cursed builds offer advantages with meaningful drawbacks
Build Balance: ⚠️ NEEDS DISCUSSION - Balance approach between pure and cursed builds
Diversity: ⚠️ SUGGESTION - Support multiple build approaches⚠️ SUGGESTION: Potential curse concepts for future design:Glass Cannon: +50% spell damage, -50% health
Mana Leak: -1 mana cost for spells, 20% spell failure rate
Berserker: +2 spell range when below 25% health, -1 max health⚠️ NEEDS BALANCING: Specific numbers and effects require playtesting⚠️ NEEDS SPECIFICATION: Implementation details for curse system
Curse Selection: How many curses can player choose?
Stacking Rules: Can multiple curses be combined?
Activation Conditions: When do curse effects trigger?
Balancing: How to ensure curses remain balanced risk/reward choices?
⚠️ SUGGESTION: Potential build approaches to consider:
Direct damage focus
Area control emphasis
Spell combination reliance
Defensive/survival priority
⚠️ ONGOING BALANCE CHALLENGE:
Preventing dominant strategies from overshadowing others
Encouraging experimentation with different build types
Maintaining viability of both cursed and pure builds
Adapting to emerging player strategies
Meaningful Choices: Each deck building decision impacts gameplay significantly
Personal Style: Support for different tactical preferences and risk tolerances
Skill Expression: Reward players who master complex spell combinationsLearning Curve: New players need viable simple strategies
Mastery Ceiling: Expert players should have room for optimization and innovation
Clear Feedback: Players should understand why their builds succeed or failFlower Allocation: Deck composition influences optimal mana flower distribution
Recharge Timing: Curse effects may interact with mana recharge cycles
Resource Planning: Spell costs drive strategic resource managementMatch Duration: Deck composition affects typical game length
Power Scaling: Prevent early-game dominance or late-game stalls
Interactive Gameplay: Encourage player-vs-player interaction over solitaire optimization⚠️ NEEDS SPECIFICATION: How deck and curse data is stored and validated
Deck Validation: Ensure legal deck construction
Curse Verification: Prevent invalid curse combinations
Persistence: Save player collections and preferred builds
⚠️ NEEDS DESIGN: Deck building and curse selection interfaces
Deck Builder: Intuitive spell selection and organization
Curse Interface: Clear presentation of risk/reward trade-offs
Preview System: Show how builds affect gameplay before committing
⚠️ ONGOING REQUIREMENT: Systems for monitoring and adjusting balance
Data Collection: Track win rates and usage patterns
Adjustment Mechanisms: How to modify spell or curse balance
Community Feedback: Integration of player feedback into balance decisions
]]></description><link>architecture/systems/spells/customization.html</link><guid isPermaLink="false">architecture/systems/spells/customization.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[mana-system]]></title><description><![CDATA[Purpose: Create resource allocation decisions without resource scarcity pressure.Philosophy: Focus on timing and positioning over resource conservation.Purpose: Create resource allocation decisions.Mechanics:
Default: 3 flowers per mana type (fire, water, earth, air)
Recharge: 3 non-stunned turns to restore after use (balances spell casting incentive vs saving)
Strategy: Specialization vs. flexibility trade-offs Hand Size: TBD based on UI and gameplay needs
Replenishment: Draw from personal spell deck each turn
Deck Construction: Pre-game selection from available spells Selection: Player chooses spell from hand
Validation: Check mana cost and target range
Execution: Place runes according to spell pattern
Cost: Exhaust required mana flowers
Cooldown: Start mana flower recharge timers Mana Cost: Specific mana types and quantities required
Range: Maximum targeting distance from caster
Pattern: Grid layout of runes placed around target
Effects: Rune types, forces, and delays in pattern Type: Determines transformation effects (fire, ice, force, etc.)
Force: Velocity applied when triggered
Delay: Countdown timer before activation Placement: Created by spell casting
Delay: Countdown each CPU processing cycle
Triggering: Apply transformations and forces when delay reaches zero
Combination: Merge with other runes on same tile
Removal: Clean up spent runes
Purpose: Create emergent spell combinations.Mechanics:
Multiple runes on same tile combine automatically
Result has combined force and minimum delay
Type determined by combination rules table
Some combinations cancel forces or produce no rune
Purpose: Power vs. risk trade-offs.Balance Philosophy: Pure builds viable but less interesting than cursed builds.Example Curses:
Glass Cannon: +50% spell damage, -50% health
Mana Leak: -1 mana cost, 20% spell failure rate
Berserker: +2 spell range when below 25% health, -1 max health Collection: Players build from available spell library
Constraints: Deck size limits encourage focused strategies
Synergies: Spells designed to work together thematically
CPU-Only Design: See <a class="internal-link" data-href="../../architecture/technical-decisions.md" href=".html" target="_self" rel="noopener nofollow">../../architecture/technical-decisions.md</a> for architecture rationale and integration details.]]></description><link>architecture/systems/spells/mana-system.html</link><guid isPermaLink="false">architecture/systems/spells/mana-system.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[reactions]]></title><description><![CDATA[Rule-based environmental transformations through GPU shader compilation for complex tile interactions.Transform human-readable tile interaction rules into highly optimized GPU shaders for environmental transformations like fire spreading, water extinguishing flames, and magical interactions.Design Approach: Designed for ease of rule creation and modification during development, allowing rules to be defined in JSON and automatically converted to efficient GPU code. Alternative approaches may be considered during implementation.
JSON rule compilation to optimized GPU shaders
Competitive rule scoring and execution for deterministic behavior
Environmental pattern matching (fire spreading, water interactions, etc.)
Rule optimization pipeline (specific implementation TBD) <a class="internal-link" data-href="rule-compilation.md" href="architecture/systems/reactions/rule-compilation.html" target="_self" rel="noopener nofollow"><strong></strong></a>Rule Compilation - JSON to GPU shader pipeline
<br><a class="internal-link" data-href="rule-system.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Rule System - Competitive scoring model and execution
<br><a class="internal-link" data-href="visual-editor.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Visual Editor - Development tools and rule creation interface
<br><a class="internal-link" data-href="examples.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Examples - Sample rules and common patterns
Problem: Multiple rules may apply to the same tile simultaneously.
Solution: Competitive evaluation where highest-scoring rule wins.Design Philosophy: Move all possible computational work to build time for minimal runtime overhead.Lower frequency than physics: Reactions may run less frequently for performance.
⚠️ Challenge: Coordination with physics timing is a major technical issue to solve.
Core Engine: Required for texture access and coordination
Build Toolchain: Rule compilation requires build-time processing
]]></description><link>architecture/systems/reactions/reactions.html</link><guid isPermaLink="false">architecture/systems/reactions/reactions.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[rule-compilation]]></title><description><![CDATA[Transform human-readable tile interaction rules into GPU shaders for environmental transformations like fire spreading, water extinguishing flames, and magical interactions.Design Approach: Designed for ease of rule creation and modification during development, allowing rules to be defined in JSON and automatically converted to GPU code. Alternative approaches may be considered during implementation.Offline Processing: Move computational work to build time for reduced runtime overhead. JSON Rule Definition Human-readable transformation rules
Visual editor exports structured rule data
Declarative condition and action specifications GLSL Code Generation Rust-based rule-to-shader compiler
Converts declarative rules to imperative GPU code
Generates helper functions for tile data access SPIR-V Compilation Standard glslangValidator compilation
Produces unoptimized intermediate representation
Platform-independent shader bytecode Optimization (⚠️ NEEDS DESIGN - specific tools TBD) Dead code elimination, function inlining
Constant folding, loop unrolling
Register allocation optimization WebGPU Conversion Convert to WebGPU-compatible shader format
Runtime loading and execution Problem: Multiple rules may apply to the same tile simultaneously.Solution: Competitive evaluation where highest-scoring rule wins.Characteristics:
Deterministic rule resolution
Priority-based rule ordering
Complex conditional logic support
Complex interaction behaviors
Logical Operators: AND, OR, NOT for complex conditions
Spatial Queries: Check neighboring tiles and patterns
Aggregate Functions: Count tiles in regions, calculate thresholds
Boolean Conversion: Transform true/false to numeric scoresBase Priority: Fixed score for rule importance
Environmental Bonuses: Dynamic scoring based on surroundings
Mandatory Conditions: Huge negative scores for rule violations
Threshold Logic: Activation based on neighbor countsTile Transformation: Change tile type and properties
Property Modification: Update velocity, health, timers
Force Application: Apply velocity changes
State Changes: Modify custom data fields{ "grass": [ { "id": "GrassIgnition", "action": { "type": "SetType", "new_type": "fire" }, "score_calculation": { "type": "Add", "children": [ { "type": "Constant", "value": 30 }, { "type": "BooleanToValue", "condition": { "type": "Aggregate", "region": "3x3", "tile_type": "fire", "comparison": "GreaterThan", "count": 0 }, "value_if_true": 0, "value_if_false": -10000 }, { "type": "Aggregate", "region": "3x3", "tile_type": "water", "expression": "count * -50" } ] } } ]
}
Lower frequency than physics: Reactions may run less frequently for performance.Challenge: Coordination with physics timing is a major technical issue to solve.
Rule Evaluation: Each tile evaluates all applicable rules
Score Calculation: Parallel computation of rule priorities Winner Selection: Deterministic highest-score selection
Action Application: Transform winning tiles Input: Read post-physics tile states
Processing: Local neighborhood sampling for conditions
Output: Write transformed tiles for next physics cycle
Integration: Seamless data flow with physics engine
⚠️ SUGGESTION: Potential editor features for future development:
Grid-based visual neighborhood editor
Point-and-click rule creation interface
Real-time rule testing and preview
Direct JSON generation for compilation
⚠️ SUGGESTION: Potential debugging capabilities:
Rule tracing: Debug which rules activated and why
Score visualization: See rule competition in real-time
Validation tools: Detect impossible or conflicting rules
Performance profiling: Shader execution timing
⚠️ SUGGESTION: Potential compilation optimizations:
Compile-time specialization for specific use cases
Dead code elimination for unused rule paths
Constant folding for pre-computed values
Loop unrolling for neighbor checks Rule Complexity: Handles arbitrary rule complexity through compilation
Rule Count: Compilation-time scaling, not runtime cost
Memory Efficiency: Optimized data access patterns
]]></description><link>architecture/systems/reactions/rule-compilation.html</link><guid isPermaLink="false">architecture/systems/reactions/rule-compilation.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[rendering]]></title><description><![CDATA[Status: Incomplete documentationThe Renderer system handles visual display and UI rendering for Reaction v2.The renderer is responsible for:
GPU-based visual display of the game grid
UI rendering and interface elements
Frame coordination with other systems
Visual effects and animations
Documentation incomplete - details to be added during implementationDocumentation incomplete - optimization details to be addedDocumentation incomplete - WebGPU implementation details to be added]]></description><link>architecture/systems/rendering/rendering.html</link><guid isPermaLink="false">architecture/systems/rendering/rendering.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[gpu-shaders]]></title><description><![CDATA[Multi-pass compute shader pipeline for collision detection and resolution.The physics system uses a sequence of compute shader passes to resolve collisions deterministically:
Velocity Setting Pass: Process spell inputs and update tile velocities
Collision Detection Pass: Calculate initial collision paths
Iterative Resolution Passes: Refine collision paths through multiple iterations Final Execution Pass: Execute movements and handle conflicts
@compute @workgroup_size(8, 8)
fn velocity_setting_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); // Read current tile and spell inputs let current_tile = read_tile(world_coord); let spell_inputs = read_spell_velocity_changes(world_coord); // Apply velocity modifications let updated_tile = apply_velocity_changes(current_tile, spell_inputs); write_tile(world_coord, updated_tile);
}
@compute @workgroup_size(8, 8)
fn collision_detection_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); let current_tile = read_tile(world_coord); if (!has_velocity(current_tile)) { return; // Skip stationary tiles in initial pass } // Load neighborhood into workgroup shared memory let neighborhood = load_neighborhood(world_coord, 7); // 7x7 for moving tiles // Calculate collision paths let collision_result = calculate_minimum_collision_time(current_tile, neighborhood); // Store collision path and timing write_collision_path(world_coord, collision_result);
}
@compute @workgroup_size(8, 8) fn iterative_resolution_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); let current_tile = read_tile(world_coord); // Load neighborhood with updated collision paths let neighborhood = load_neighborhood_with_paths(world_coord); // Recalculate collision assuming neighbors follow their stored paths let updated_collision = recalculate_collision_with_paths(current_tile, neighborhood); // Update collision path if changed if (path_changed(updated_collision)) { write_collision_path(world_coord, updated_collision); mark_convergence_flag(false); }
}
@compute @workgroup_size(8, 8)
fn execution_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); let current_tile = read_tile(world_coord); let collision_path = read_collision_path(world_coord); // Check for convergence - would another pass change the result? if (would_collision_change(current_tile, collision_path)) { // Write error tile for non-convergent scenario write_error_tile(world_coord); return; } // Execute collision resolution let final_position = collision_path.final_position; let collision_events = collision_path.events; // Atomic write to destination (handles conflicts) if (!atomic_write_tile(final_position, current_tile)) { // Conflict detected - write error tile write_error_tile(world_coord); } // Write collision events for renderer write_collision_events(collision_events);
}
Shared Memory Caching: Each workgroup loads neighborhood data into local memory.Cache Size: 7×7 neighborhood fits within workgroup shared memory limits.Synchronization: Workgroup barriers ensure data consistency across threads.// Workgroup shared memory for neighborhood caching
var&lt;workgroup&gt; neighborhood_cache: array&lt;array&lt;TileData, 7&gt;, 7&gt;;
var&lt;workgroup&gt; cache_loaded: bool; @compute @workgroup_size(8, 8)
fn collision_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;, @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;) { // First thread in workgroup loads neighborhood if (local_id.x == 0 &amp;&amp; local_id.y == 0) { load_neighborhood_to_cache(); cache_loaded = true; } workgroupBarrier(); // All threads process using cached data process_tile_with_cached_neighborhood(global_id, local_id);
}
Read Phase: Sample from texture set A (stable data from previous frame).Write Phase: Output to texture set B (prevents read-after-write hazards).Buffer Swapping: Core engine swaps texture sets between physics ticks.Dynamic Sizing: Calculate required neighborhood based on tile velocity and offset.Boundary Handling: World wrapping for neighborhoods that extend beyond edges.Memory Coalescing: Thread groups access contiguous texture regions for GPU cache efficiency.Iterative Resolution: Determinism achieved through multi-pass convergence rather than processing order.Consistent Results: Same collision scenarios produce identical outcomes across runs and platforms.Atomic Operations: GPU atomics ensure consistent conflict resolution when multiple tiles target same location.// Integer-only collision time calculation
fn calculate_collision_time(tile_a: TileData, tile_b: TileData) -&gt; u32 { // Use fixed-point arithmetic to avoid floating-point drift let relative_velocity = tile_a.velocity - tile_b.velocity; let distance = tile_a.position - tile_b.position; // Integer division with proper rounding return fixed_point_divide(distance, relative_velocity);
}
Convergence Detection: Global flag indicates when no collision paths change.Pass Skipping: Skip remaining iterative passes when convergence reached.Implementation: Atomic flag updated by any thread that changes a collision path.Bit-Packed Data: Compress tile data to minimize texture memory usage.Coalesced Access: Align memory access patterns with GPU architecture.Cache Optimization: Structure data layout for optimal GPU cache utilization.Active Region Processing: Only dispatch shaders for chunks containing moving tiles.Indirect Compute: Use indirect dispatch for dynamic workload sizing.Workgroup Scaling: Adjust workgroup count based on active tile density.Texture Management: Coordinate with core engine texture ping-ponging system.Active Chunks: Receive list of active chunks to focus processing.Resource Sharing: Share GPU resources with other compute systems.Collision Events: Write collision timing and results to structured buffer.Renderer Integration: Format events for efficient renderer consumption.Memory Layout: Optimize event buffer layout for sequential access patterns.WGSL Source: Write shaders in WebGPU Shading Language.Compilation: Compile shaders during build process for validation.Hot Reload: Development builds support shader hot-reloading.Compilation Failures: Graceful handling of shader compilation errors.Runtime Validation: Verify shader resources and binding compatibility.Fallback Behavior: Default error handling for GPU context loss.Pass Limiting: Configurable maximum iteration count prevents infinite loops.Memory Bandwidth: Texture access patterns optimized for GPU memory hierarchy.Compute Utilization: Workgroup sizing balanced for GPU architecture efficiency.GPU Utilization: Monitor compute shader execution timing.Memory Bandwidth: Track texture access patterns and cache hit rates.Convergence Speed: Measure average iterations needed for collision resolution.]]></description><link>architecture/systems/physics/gpu-shaders.html</link><guid isPermaLink="false">architecture/systems/physics/gpu-shaders.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[movement-system]]></title><description><![CDATA[Free-form positioning with cohesion forces and multi-pass collision resolution architecture.Movement Model: Unconstrained movement using integer-precision positioning for deterministic physics.Collision Resolution: Multi-pass GPU compute pipeline for deterministic collision handling.Cohesion Forces: Automatic gap-closing and tile clustering for natural density management.Integration: Provides collision events and position data to renderer for smooth visual interpolation.Precision: Fixed-point arithmetic using texture-optimized bit precision for deterministic results.Unconstrained Direction: Tiles can move in any direction based on collision physics and spell effects.Offset Storage: Each tile stores its precise x,y offsets from grid center as integer values within texture memory.Renderer Interpolation: Smooth visual movement using precise position data and collision event timing.Continuous Positioning: Tiles can have any offset from their grid centers using integer coordinates.Velocity Representation: Two-component velocity vectors (x,y) stored with texture-optimized precision.Purpose: Automatically close gaps between tiles and maintain dense tile coverage without rigid grid constraints.Force Calculation: Clamped linear attraction between tiles within 1.5 block radius.Neighborhood Processing: 5x5 grid examination to account for tile positioning at sub-grid locations.Distance Calculation: Calculate center-to-center distance between current tile and all neighbors in 5x5 area.Force Formula: Force = max(0, cohesion_strength * (1.5 - distance) / 1.5)Force Direction: Attraction toward the centroid (average position) of nearby tiles within cohesion radius.Dense Coverage: Tiles automatically maintain dense world coverage without explicit positioning rules.Gap Elimination: Empty spaces between adjacent tiles get naturally filled by cohesion attraction.Breaking Force: High-velocity impacts can overcome cohesion to separate tiles and create temporary gaps.Emergent Organization: Organic tile distribution that responds dynamically to collisions and spell effects while maintaining coverage.The collision system uses multiple GPU compute passes to resolve complex scenarios:
Velocity Setting Pass: Apply spell inputs to update tile velocities
Initial Collision Pass: Calculate collision times assuming straight-line paths Iterative Passes: Recalculate collisions based on updated paths from previous passes
Final Pass: Execute collisions or generate error tiles for conflicts
Input Processing: Read spell system velocity change requests
Apply velocity modifications to affected tiles
Handle spell-induced tile type changes
Neighborhood Analysis: May examine local area for context-dependent velocity changes.Neighborhood Scanning: Moving tiles: Examine 7×7 grid around tile position
Stationary tiles: Examine 5×5 grid for efficiency Dynamic sizing: Calculate affected cells based on velocity and current position
Collision Calculation: Project straight-line paths for all tiles in neighborhood
Calculate collision time based on tile size and relative velocities
Find minimum collision time across all potential collisions
Path Storage: Write collision path, timing, and tile type changes to tile's memory location.Updated Collision Detection:
Recalculate collisions assuming tiles follow stored paths from previous pass
Update neighborhood based on new projected movements
Store refined collision paths and timings
Convergence Checking: Continue until paths stabilize or maximum pass count reached.Convergence Verification: Check if collision times would change with another iteration.Collision Resolution: Execute tile movements to calculated positions
Apply collision-induced tile type changes
Handle tile destruction from collision results
Conflict Handling: Use GPU atomics to generate error tiles when multiple tiles target same location.Workgroup Organization: Each workgroup processes a neighborhood region with shared local memory cache.Memory Access Patterns:
Preload neighborhood data into workgroup local memory
Sequential processing to maintain deterministic order
Atomic operations for collision conflict resolution
World Wrapping: Tiles at world edges wrap to opposite side by default.Neighborhood Handling: 7×7 neighborhoods near edges access wrapped coordinates for collision detection.Early Termination: Skip remaining passes if no collision paths change.Workgroup Caching: Load full neighborhood into local memory when possible.Bit-Packed Data: Minimize memory bandwidth with compact data structures.Texture Coordination: Read from stable textures, write to ping-pong buffers.Active Region Processing: Focus compute resources on chunks containing moving tiles.Velocity Input: Receive velocity changes from spell processing.Event Coordination: Provide collision timing for spell trigger synchronization.Event Buffer: Generate collision events with precise timing data.Interpolation Data: Provide sub-grid positioning for smooth visual movement.Layer Separation: Physics handles same-layer interactions; reactions handle cross-layer effects.Performance Integration: May merge shaders for efficiency if beneficial.
Offset: Unconstrained x,y offset from grid center (texture-optimized precision)
Velocity Vector: Two-component velocity (x,y) with texture-optimized precision
Collision Path: Projected movement and collision points
Type Changes: Tile transformations from collision results Collision Timing: When collisions occur within physics tick
Collision Results: Tile movements, destructions, type changes
Interpolation Points: Data needed for smooth rendering
Pass Limiting: Configurable maximum iterations prevent infinite loops.Workgroup Efficiency: Balance neighborhood size with GPU architecture.Memory Bandwidth: Optimized data layout for GPU texture cache.Convergence-Based Determinism: Multi-pass iteration ensures consistent collision resolution regardless of processing order.Integer Mathematics: Fixed-point arithmetic prevents floating-point drift.Atomic Consistency: GPU atomics ensure deterministic conflict resolution when multiple tiles target same destination.]]></description><link>architecture/systems/physics/movement-system.html</link><guid isPermaLink="false">architecture/systems/physics/movement-system.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[physics]]></title><description><![CDATA[GPU-accelerated physics simulation providing smooth tile movement between grid locations with sub-grid positioning and deterministic collision resolution.Design Principle: Multi-pass GPU compute pipeline optimized for parallel collision detection and resolution.Movement Model: Free-form movement with integer-precision positioning for deterministic physics calculations.
Free-form tile movement with unconstrained offsets from grid centers
Multi-pass collision detection and deterministic resolution Velocity management from spell inputs and collision results
Cohesion forces for natural gap-closing and tile clustering
Event generation for renderer interpolation between physics ticks <a class="internal-link" data-href="movement-system.md" href="architecture/systems/physics/movement-system.html" target="_self" rel="noopener nofollow"><strong></strong></a>Movement System - Velocity and collision mechanics
<br><a class="internal-link" data-href="gpu-shaders.md" href="architecture/systems/physics/gpu-shaders.html" target="_self" rel="noopener nofollow"><strong></strong></a>GPU Shaders - Compute shader architecture and implementation
<br><a class="internal-link" data-href="forces.md" href="architecture/systems/physics/forces.html" target="_self" rel="noopener nofollow"><strong></strong></a>Forces - Rune forces and environmental effects
<br><a class="internal-link" data-href="determinism.md" href="architecture/systems/physics/determinism.html" target="_self" rel="noopener nofollow"><strong></strong></a>Determinism - Precision and reproducibility guarantees
Offset Positioning: Tiles store unconstrained offsets from grid centers using fixed-point arithmetic with texture-optimized precision.Unconstrained Movement: Tiles can move in any direction with collision-determined velocities and bouncing.Renderer Integration: Physics generates collision events with timing data for smooth visual interpolation.Iterative Resolution: Multiple GPU compute passes resolve complex multi-tile collision scenarios.Deterministic Results: Configurable pass limit ensures consistent behavior across platforms.Atomic Conflict Handling: Multiple tiles targeting the same location generate error tiles through GPU atomics.Gap Closure: Tiles within 1.5 block radius attract each other using clamped linear forces.5x5 Neighborhood: Cohesion calculations examine 5x5 area to account for sub-grid positioning.Natural Clustering: Automatic tile density management without rigid grid constraints.
Texture Coordination: Read/write physics data via texture ping-ponging
World Boundaries: Wrapping system for tiles at world edges
Memory Efficiency: Direct texture operations with workgroup caching Velocity Input: Receive velocity changes from spell processing
Collision Response: Tile type changes and destruction from collision results
Event Output: Collision timing and results for spell trigger coordination Event Buffer: Collision events with precise timing for smooth interpolation
Offset Data: Tile offsets from grid centers for accurate visual positioning
Velocity Data: Current tile velocities for motion blur and particle effects Core Engine: Required for texture management and active region optimization
WebGPU: GPU compute shaders for parallel processing
]]></description><link>architecture/systems/physics/physics.html</link><guid isPermaLink="false">architecture/systems/physics/physics.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[server-architecture]]></title><description><![CDATA[Authoritative game server design with GPU-accelerated simulation identical to client engine.Purpose: Central coordinator for multiplayer matches.Responsibilities:
WebSocket connection management per match
Player authentication and session management
Frame timing coordination at 60 FPS
Match lifecycle (creation, joining, termination)
Dependencies: NetworkManager, ServerGameEnginePurpose: Authoritative game simulation without rendering.Responsibilities:
Identical deterministic simulation to client engine
GPU compute shader execution for physics and reactions
Tile storage and active region management
State validation and integrity checking
Key Differences from Client:
No rendering pipeline (headless)
Additional input validation layers
State snapshot creation for rollback
Network delta generation
Purpose: Real-time communication with game clients.Responsibilities:
WebSocket server lifecycle management
Input message validation and deserialization
State update broadcasting with compression
Connection quality monitoring and adaptation Client Input Reception: WebSocket message containing player actions
Input Validation: Verify action legality (mana costs, targeting, timing)
State Application: Apply validated inputs to authoritative game state
Simulation Step: Execute physics, reactions, and rule processing
Delta Generation: Create compressed state updates for clients
60 FPS Target: 16.67ms frame budget
Input processing: 2ms
Simulation execution: 12ms
Network transmission: 2ms
Buffer time: 0.67ms
Full State Snapshots: Every 60 frames (1 second) as fallback recovery
Delta Updates: Every frame with active region optimization
Priority System: Critical updates (player health) sent immediately
Acknowledgment Tracking: Ensure reliable delivery with retransmissionServer Environment: Node.js with WebGPU adapter
GPU Requirements: NVIDIA T4 or equivalent with compute capability
Memory Management: Shared texture pools across game instancesIdentical Logic: Same shaders as client for deterministic results
Texture Management: Ping-pong system adapted for server environment
Active Region Processing: Leverage existing chunk optimizationInstance Batching: Multiple games on single GPU context
Memory Pooling: Reuse GPU resources between matches
Adaptive Quality: Reduce simulation fidelity under high loadRoom Creation: Dynamic game instance spawning
Player Assignment: Region-based server selection
Capacity Management: Load balancing across server instances
Initialization: GPU resource allocation and world setup
Player Joining: Connection establishment and state synchronization
Active Gameplay: 60 FPS simulation with network updates
Match Conclusion: Resource cleanup and statistics recording
GPU Failures: Automatic instance migration to backup servers
Network Issues: Client reconnection with state recovery
Crash Recovery: Persistent state snapshots for match restoration
Frame timing consistency (target: &lt;16.67ms)
GPU utilization per instance
Memory bandwidth consumption
Network throughput per match
CPU Bound: Input processing and network I/O optimization
GPU Bound: Shader optimization and batch processing
Memory Bound: Texture management and garbage collection
Network Bound: Compression and prioritization improvements
Player queue length
Average frame processing time
GPU memory utilization
Network bandwidth per server
This architecture provides the authoritative foundation for competitive multiplayer while leveraging Reaction's existing deterministic engine design.]]></description><link>architecture/systems/multiplayer/server-architecture.html</link><guid isPermaLink="false">architecture/systems/multiplayer/server-architecture.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[determinism]]></title><description><![CDATA[Ensuring reproducible physics simulation for fair PvP gameplay.Identical Inputs → Identical Outputs: Essential for fair PvP gameplay
Cross-Platform Consistency: Same results across different hardware and drivers
Replay Capability: Matches should be perfectly reproducible✅ SOLVED: GPU determinism achieved through Spatial Ordering StrategySolution: Deterministic tile processing order using spatial coordinates
Implementation: See <a class="internal-link" data-href="../../architecture/deterministic-execution.md" href=".html" target="_self" rel="noopener nofollow">../../architecture/deterministic-execution.md</a> for complete solution
Status: Integrated into Deterministic Time-Sliced Execution pipeline
Spatial Ordering: Process tiles in strict top-left to bottom-right order
Integer Mathematics: Fixed-point arithmetic prevents floating-point drift Cross-Platform Consistency: Identical results across GPU architectures
Validation Framework: Automated testing for deterministic execution
No Floating-Point Drift: Use integer-only calculations to prevent precision accumulation
Fixed-Point Arithmetic: ⚠️ NEEDS SPECIFICATION - Specific fixed-point formats for velocity and position
Rounding Consistency: Deterministic rounding rules across all calculationsNo Shared State: Tiles don't share mutable state during processing
Atomic Operations: Critical for marking active chunks and activity propagation
Data Races: Prevent concurrent read/write conflicts⚠️ CRITICAL REQUIREMENT: Automated testing for deterministic execution
Replay Tests: Same input sequence produces identical results
Cross-Platform Validation: Consistency across different hardware
Stress Testing: Determinism under high load and complex scenarios
Execution Tracing: Track tile state changes for debugging non-determinism
State Snapshots: Capture game state at specific frames for comparison
Regression Detection: Identify when determinism breaks during developmentHardware Differences: Different GPU architectures may behave differently
Driver Updates: Graphics driver changes could affect determinism
Fallback Strategies: ⚠️ NEEDS DESIGN - CPU fallback for determinism-critical operations?Implementation Limits: Some optimizations may break determinism
Testing Requirements: Extensive validation needed for any physics changes
Documentation: ⚠️ SUGGESTION - Clear guidelines for maintaining determinism during developmentDeterminism-First: Always consider determinism impact of changes
Validation Testing: Test determinism before and after modifications
Documentation: Document any assumptions about execution order
Code Review: Explicit review of determinism implicationsShared Memory: Avoid shared memory between GPU threads where possible
Synchronization: Use barriers and synchronization appropriately
Data Dependencies: Carefully manage data dependencies between processing stages]]></description><link>architecture/systems/physics/determinism.html</link><guid isPermaLink="false">architecture/systems/physics/determinism.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[forces]]></title><description><![CDATA[Spell-driven velocity changes and directional movement constraints.Velocity Model: Discrete directional movement (8 directions) with bit-packed representation.Input Source: Spell system provides velocity change requests processed in the velocity setting pass.Movement Constraints: No traditional forces - tiles move in grid-aligned directions only.Spell Integration: First pass of physics pipeline processes spell system velocity requests.Velocity Changes: Direct velocity modifications rather than force accumulation.Tile Type Changes: Spell effects can modify tile types alongside velocity changes.Bit-Packed Format: 3 bits for direction (8 cardinal/diagonal directions)
Remaining bits for magnitude/speed
Optimized for GPU memory bandwidth
Direction Constraints: Movement limited to 8 directions to maintain grid alignment:
4 Cardinal: North, South, East, West 4 Diagonal: Northeast, Northwest, Southeast, Southwest
Context-Dependent Changes: May examine local neighborhood for spell effects that depend on surrounding tiles.Area Effects: Handle spell effects that modify velocities across multiple tiles simultaneously.Pipeline Position: Velocity setting occurs before collision detection passes.State Preparation: Establishes initial velocity state for collision calculation./Data Flow: Reads spell inputs → applies velocity changes → writes updated tile data.Velocity Changes from Collisions: Collision resolution can modify tile velocities.Type-Dependent Collision: Different tile types may have different collision behaviors affecting resulting velocities.Destruction Events: Collisions can destroy tiles, removing them from velocity processing.Velocity Change Requests: Structured data from spell system specifying:
Target tile position
New velocity vector (direction + magnitude)
Optional tile type changes
Priority/timing information
Batch Processing: Handle multiple spell effects per tile in single pass.Direct Velocity: Set tile velocity to specific value.Velocity Modification: Add/subtract from existing velocity.Conditional Changes: Velocity changes based on tile type or neighborhood.Area Effects: Velocity changes applied to regions around spell targets.Offset System: Tiles maintain sub-grid offsets between discrete positions.Smooth Interpolation: Renderer uses offsets for smooth visual movement.Physics Tick Alignment: Offset precision ensures tiles align with grid at physics ticks.Variable Speeds: Different tiles can move at different rates.Physics Tick Coordination: All speeds calibrated to reach grid positions at physics ticks.Deterministic Movement: Consistent timing across all platforms and runs.// Velocity setting pass structure
@compute @workgroup_size(8, 8)
fn velocity_setting_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); // Read current state let current_tile = read_tile(world_coord); let spell_inputs = read_spell_velocity_changes(world_coord); // Apply velocity modifications var updated_tile = current_tile; for (let i = 0; i &lt; spell_inputs.count; i++) { updated_tile = apply_spell_effect(updated_tile, spell_inputs.effects[i]); } write_tile(world_coord, updated_tile);
}
Compact Storage: Velocity data packed into minimal bits within tile data structure.Efficient Access: Velocity reading/writing optimized for GPU memory patterns.Spell Input Buffer: Temporary buffer for spell system velocity change requests.Parallel Processing: Each tile processes its velocity changes independently.Minimal Computation: Simple velocity assignment rather than complex force calculations.Memory Bandwidth: Optimized data structures minimize GPU memory access.Spell Load: Performance scales with number of active spell effects.Area Effects: Efficient handling of spells affecting multiple tiles.Context Processing: Optional neighborhood examination for context-dependent effects.Input Interface: Structured velocity change requests from spell processing.Timing Coordination: Velocity changes applied at correct physics tick timing.Effect Validation: Ensure spell effects produce valid velocity values.State Handoff: Provides initial velocity state for collision detection passes.Result Integration: Accepts velocity changes from collision resolution.Type Coordination: Handles tile type changes that affect collision behavior.Interpolation Data: Provides velocity and offset data for smooth visual movement.Event Coordination: Velocity changes may trigger visual effects.Grid Alignment: Force-based physics would complicate grid-aligned movement.Determinism: Direct velocity setting is more predictable than force accumulation.Performance: Simpler calculations than continuous force integration.Spell Integration: Direct velocity control better matches spell effect design.Grid Consistency: 8-direction movement maintains tile alignment with grid.Visual Clarity: Predictable movement directions improve gameplay readability.Collision Simplification: Limited directions simplify collision detection algorithms.Memory Efficiency: 3 bits sufficient for direction encoding.]]></description><link>architecture/systems/physics/forces.html</link><guid isPermaLink="false">architecture/systems/physics/forces.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[network-protocol]]></title><description><![CDATA[WebSocket-based communication protocol with optimized state synchronization and delta compression.WebSocket Connection: Persistent bidirectional communication
Message Format: Binary protocol with structured headers
Compression: LZ4 compression for large state updates
Reliability: Application-level acknowledgments and retransmission
Input Messages: Client actions (spell casts, movement)
State Updates: Server game state changes
Control Messages: Connection management and metadata
Heartbeat Messages: Connection health monitoring
interface NetworkMessage { type: MessageType; frameNumber: number; playerId: string; sequence: number; timestamp: number; checksum: number; payload: MessagePayload;
}
interface SpellCastInput { spellId: number; targetX: number; targetY: number; manaType: ManaType;
} interface MovementInput { direction: number; // 8-directional movement intensity: number; // 0-255 for analog input
} interface SpellSelectInput { spellIndex: number; handPosition: number;
}
interface TileDelta { x: number; y: number; layer: Layer; oldTile: number; // bit-packed tile data newTile: number; // bit-packed tile data
} interface PlayerUpdate { playerId: string; positionX: number; positionY: number; health: number; manaLevels: number[]; // array of mana amounts
} interface FullStateSnapshot { frameNumber: number; tileData: Uint32Array; // complete world state playerStates: PlayerUpdate[]; activeChunks: ChunkCoord[];
}
Change Detection: Only transmit modified tiles per frame
Run-Length Encoding: Compress sequences of identical tiles
Bit-Packing Efficiency: Leverage existing 32-bit tile format
Estimated Savings: 90% bandwidth reduction vs full stateChunk-Based Updates: Leverage 32×32 active region system
Spatial Compression: Group changes by geographic proximity
Activity Propagation: Automatic chunk activation/deactivation
Bandwidth Scaling: Linear with activity level, not world sizeLZ4 Algorithm: Fast compression/decompression for real-time use
Adaptive Compression: Skip compression for small messages
Dictionary Building: Maintain compression context across framesInput Messages: Send immediately on player action
State Deltas: Every frame (16.67ms at 60 FPS)
Full Snapshots: Every 60 frames (1 second) for recovery
Heartbeat: Every 5 seconds for connection monitoringSequence Numbers: Detect missing or duplicate messages
Acknowledgment System: Confirm receipt of critical updates
Retransmission: Resend lost messages with exponential backoff
Recovery Mode: Request full state snapshot on desyncCritical Updates: Player health, elimination, match state
High Priority: Direct player actions and immediate consequences
Medium Priority: Environmental changes and rule effects
Low Priority: Cosmetic updates and distant tile changes
Client Connection: WebSocket establishment
Authentication: Player credentials and session validation
Game Joining: Match assignment and initial state transfer
Synchronization: Frame alignment and latency measurement
Latency Measurement: Round-trip time calculation
Bandwidth Detection: Adaptive compression and update frequency
Connection Quality: Network stability monitoring
Fallback Modes: Reduced fidelity on poor connectionsGraceful Disconnect: Planned disconnection with state preservation
Timeout Detection: Automatic disconnection after communication failure
Reconnection: Resume gameplay with state synchronization
Ghost Mode: Temporary AI control during brief disconnectionsTarget Bandwidth: &lt;16MB per player per minute
Peak Optimization: Burst protection during high-activity periods
Regional Scaling: Reduced updates for distant regions
Predictive Filtering: Skip redundant state updatesMessage Batching: Combine multiple updates per frame
Predictive Transmission: Send likely state changes early
Compression Caching: Reuse compression dictionaries
Priority Queuing: Critical messages bypass normal queue// Efficient tile delta encoding
interface CompressedTileDelta { chunkId: number; // 16 bits - chunk identifier relativeTiles: number; // 10 bits - tiles changed in chunk deltaData: Uint8Array; // variable length - compressed changes
}
Input Sanitization: Validate all client inputs against game rules
Range Checking: Ensure coordinates and values within bounds
Rate Limiting: Prevent input flooding and spam
Checksum Verification: Detect message corruption or tamperingMessage Signing: Cryptographic signatures for critical messages
Sequence Validation: Detect replay attacks and message injection
Timing Verification: Validate message timestamps against server time
State Integrity: Server-side validation of all game state changesTLS Encryption: Secure WebSocket connections (WSS)
Session Management: Secure token-based authentication
DoS Protection: Rate limiting and connection throttling
IP Filtering: Geographic and reputation-based access controlThis protocol provides efficient, reliable communication optimized for Reaction's real-time gameplay requirements while maintaining competitive integrity.]]></description><link>architecture/systems/multiplayer/network-protocol.html</link><guid isPermaLink="false">architecture/systems/multiplayer/network-protocol.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[performance]]></title><description><![CDATA[Bandwidth optimization, server scaling, and latency management strategies for multiplayer infrastructure.Simulation Requirements:
60 FPS authoritative simulation per game instance
Real-time response to player input
Support multiple players per game instance
Maintain responsive gameplay experience
Scaling Goals:
Support multiple concurrent matches per server
Efficient bandwidth utilization
Minimize network latency
High availability for players
Prediction Requirements:
Maintain smooth 60 FPS gameplay
Minimize rollback disruptions
Low prediction processing overhead
Seamless visual experience during corrections
Headless Rendering Optimization:
Skip visual pipeline entirely
Retain compute shaders for physics and reactions
Optimize GPU memory allocation for multiple instances
Implement texture pooling across game instances
Memory Optimization:
Pool GPU textures and buffers across instances
Share compute pipelines between games
Optimize memory allocation for multiple instances
Minimize GPU memory fragmentation
Batch Processing:
Process multiple game instances on single GPU context
Optimize GPU command buffer submissions
Minimize GPU state changes between instances
Implement efficient GPU-CPU synchronization
Input Processing:
Batch input validation across multiple players
Optimize network message deserialization
Implement efficient player state updates
Minimize context switching between game instances
Memory Management:
Optimize memory allocation patterns
Reduce garbage collection overhead
Efficient state history management
Pool frequently used objects
Bandwidth Reduction:
Active region delta compression (90% reduction)
Predictive state filtering
Spatial proximity optimization
Temporal coherence exploitation
Latency Reduction:
Regional server deployment
CDN integration for initial state
Predictive message transmission
Connection pooling and reuse
Instance Management:
Stateless game servers for easy scaling
Load balancing based on server utilization
Dynamic instance spawning during peak hours
Graceful shutdown and player migration
Resource Management:
Monitor server capacity and utilization
Balance load across available resources
Track GPU, memory, and network usage
Scale instances based on demand
Resource Monitoring:
Real-time GPU utilization tracking
Memory pressure detection and management
CPU bottleneck identification
Network bandwidth monitoring
Adaptive Quality:
Reduce simulation fidelity under load
Dynamic update frequency adjustment
Selective feature disabling during peaks
Graceful degradation strategies
Regional Deployment:
Multiple data centers for global coverage
Player assignment based on latency testing
Cross-region backup for failover
Edge computing for input processing
Protocol Optimization:
UDP consideration for non-critical updates
Message priority queuing
Batch transmission optimization
Connection quality adaptation
Client-Side Optimization:
Minimize prediction processing overhead
Efficient rollback state management
Optimized visual interpolation
Predictive input handling
Network Adaptation:
Monitor connection quality metrics
Adjust prediction windows based on latency
Adapt update frequencies to network conditions
Handle packet loss gracefully
Tile Delta Compression:
Run-length encoding for similar tiles
Bit-field optimization for tile changes
Spatial compression for clustered updates
Temporal compression for predictable patterns
State Synchronization:
Differential state encoding
Chunk-based update grouping
Priority-based transmission
Redundancy elimination
Connection Quality Detection:
Bandwidth measurement and adaptation
Quality of service monitoring
Congestion avoidance algorithms
Fallback mode implementation
Traffic Shaping:
Rate limiting per connection
Burst protection mechanisms
Priority queuing for critical updates
Load balancing across connections
Server Monitoring:
Track frame processing performance
Monitor GPU and memory utilization
Measure network throughput and connections
Count active game instances
Client Monitoring:
Measure prediction accuracy and rollbacks
Track network latency and frame drops
Monitor bandwidth consumption
Assess user experience quality
Automated Analysis:
Performance regression detection
Capacity planning based on usage patterns
Predictive scaling triggers
Anomaly detection for performance issues
Optimization Feedback:
A/B testing for optimization strategies
Performance impact measurement
User experience correlation
Continuous improvement cycles
Container Optimization:
Minimal Docker images for game servers
GPU-optimized container runtime
Efficient resource allocation
Fast startup and shutdown times
Resource Utilization:
Pack multiple game instances per server
Optimize GPU memory sharing
Minimize idle resource consumption
Dynamic resource allocation
Performance Alerts:
Latency threshold violations
Resource utilization warnings
Capacity planning notifications
Service degradation detection
Automated Responses:
Auto-scaling based on demand
Failover to backup servers
Load rebalancing during issues
Performance optimization triggers
This comprehensive performance strategy ensures smooth multiplayer gameplay while maintaining cost-effective server operations.]]></description><link>architecture/systems/multiplayer/performance.html</link><guid isPermaLink="false">architecture/systems/multiplayer/performance.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[security]]></title><description><![CDATA[Input validation, state integrity, and cheat detection systems for competitive multiplayer security.Authoritative Validation: All game-affecting decisions made on server
Input Processing: Client inputs validated against current game state
State Enforcement: Server never trusts client-reported game state
Damage Calculation: All combat calculations performed server-sideAuthority Boundaries:
Server: Health, mana, spell effects, tile transformations
Client: UI interactions, prediction, visual effects
Validated: Movement inputs, spell targeting, timing
Zero-Trust Client Model: Assume all client data is potentially malicious
Validation Layers: Multiple verification stages for critical operations
State Reconciliation: Continuous comparison of client predictions with server realityinterface InputValidation { syntaxCheck: boolean; // Message format validity rangeCheck: boolean; // Coordinate and value bounds gameRuleCheck: boolean; // Legal according to current state timingCheck: boolean; // Within expected timing windows rateCheck: boolean; // Not exceeding rate limits
}
Mana Verification: Server tracks actual mana levels independently
Targeting Validation: Ensure spell targets are within range and line-of-sight
Cooldown Enforcement: Server-side spell cooldown tracking
Rule Compliance: Validate spell effects against current game rulesExample Validation:function validateSpellCast(input: SpellCastInput, gameState: GameState): ValidationResult { // Check mana availability if (gameState.playerMana[input.playerId] &lt; spell.manaCost) { return { valid: false, reason: "Insufficient mana" }; } // Validate targeting if (!isValidTarget(input.target, gameState.playerPosition[input.playerId])) { return { valid: false, reason: "Invalid target" }; } // Check cooldowns if (gameState.spellCooldowns[input.playerId][input.spellId] &gt; 0) { return { valid: false, reason: "Spell on cooldown" }; } return { valid: true };
}
Position Bounds: Ensure movement stays within world boundaries
Physics Constraints: Validate movement against physics simulation
Speed Limits: Enforce maximum movement speeds
Collision Detection: Prevent movement through solid tilesInput Frequency: Maximum inputs per second per player
Spell Casting Rate: Prevent rapid-fire spell casting
Connection Limits: Maximum connections per IP address
Bandwidth Throttling: Prevent network floodingChecksum Verification: Regular state checksums between server instances
Replay Validation: Ability to replay matches for verification
Cross-Instance Checking: Multiple servers validate critical calculations
Integer-Only Mathematics: Prevent floating-point determinism issuesinterface StateIntegrityCheck { playerHealthSum: number; totalManaInWorld: number; tileTypeDistribution: Map&lt;TileType, number&gt;; activeRuneCount: number; frameChecksum: number;
}
Impossible State Detection: Identify states that violate game physics
Statistical Analysis: Detect patterns that suggest cheating
Performance Anomalies: Identify suspiciously perfect play patterns
Network Timing Analysis: Detect inhuman reaction timesInput Analysis:
Timing analysis for inhuman precision
Pattern recognition for bot behavior
Statistical analysis of success rates
Consistency checking across sessions
State Validation:
Impossible game state detection
Resource tracking (mana, health)
Position validation and teleport detection
Damage calculation verification
Performance Fingerprinting:
Hardware capability profiling
Render timing analysis
Input device characteristics
System performance patterns
Behavior Analysis:
Mouse movement patterns
Reaction time distributions
Decision-making patterns
Play style consistency
Speed Hacking: Movement faster than physics allows
Teleportation: Position changes without valid movement
Resource Manipulation: Invalid mana or health values
Information Cheating: Actions suggesting knowledge of hidden information
Automation: Bot-like behavior patterns
Network Manipulation: Lag switching or packet manipulationTLS Encryption: All WebSocket connections use WSS protocol
Certificate Validation: Proper SSL certificate verification
Session Management: Secure token-based authentication
IP Reputation: Block known malicious IP addressesRate Limiting: Connection and message rate limits
Geographic Filtering: Restrict connections by region if needed
Traffic Analysis: Detect and mitigate attack patterns
Load Balancing: Distribute traffic across multiple serversMessage Authentication: Cryptographic signatures for critical messages
Replay Attack Prevention: Timestamp and sequence number validation
Man-in-the-Middle Protection: Certificate pinning where appropriate
Session Hijacking Prevention: Secure session token managementImmediate Actions:
Flag suspicious activity for review
Increase monitoring for flagged players
Collect evidence for manual review
Apply temporary restrictions if necessary
Investigation Process:
Automated evidence collection
Manual review by security team
Player interview if needed
Final determination and action
Enforcement Actions:
Warning for minor violations
Temporary suspension for moderate violations
Permanent ban for severe violations
Hardware ID banning for repeat offenders
Breach Detection: Automated monitoring for security compromises
Response Team: Dedicated security incident response team
Communication Plan: Player notification for security issues
Recovery Procedures: Service restoration after security incidentsReplay System: Complete match recordings for investigation
Log Aggregation: Centralized logging for security analysis
Player Behavior History: Long-term behavioral pattern tracking
System State Snapshots: Capture game state during suspicious eventsMinimal Data Collection: Only collect data necessary for security
Data Retention: Automatic deletion of old security logs
Player Privacy: Protect personal information during investigations
Consent Management: Clear privacy policy for security monitoringAppeals Process: Fair system for contested security actions
Evidence Disclosure: Provide evidence for security decisions where appropriate
Policy Communication: Clear communication of security policies
Regular Auditing: Third-party security audits of anti-cheat systemsThis comprehensive security framework ensures competitive integrity while maintaining player privacy and providing fair enforcement mechanisms.]]></description><link>architecture/systems/multiplayer/security.html</link><guid isPermaLink="false">architecture/systems/multiplayer/security.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[client-prediction]]></title><description><![CDATA[Local state prediction with rollback mechanisms for responsive gameplay despite network latency.⚠️ UPDATED SYSTEM: Client prediction now uses the unified Deterministic Time-Sliced Execution pipeline. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> for complete integration details.Single Engine: Same game engine used for single-player and multiplayer prediction.Deterministic Execution: Time-sliced pipeline ensures identical client/server results.Automatic State Management: Built-in snapshots and rollback through unified state system.Frame Synchronization: Time slice alignment with server for precise synchronization.
Local state prediction using identical simulation logic
Server state comparison with automatic mismrediction detection Rollback and re-execution through unified state management
Ghost simulation for action queue visualization
Purpose: Runs identical simulation logic for local prediction.Components:
Same GPU compute shaders as server
Physics and reaction processing
Tile state management with active regions
Deterministic frame execution pipeline
Key Differences:
Operates on unconfirmed inputs
Generates visual output during prediction
Maintains rollback state history
Handles prediction correction smoothly
Confirmed States: Server-validated game states stored every 5 frames
Prediction States: Local simulation results with input applied
Rollback Threshold: Maximum 10 frames (167ms at 60 FPS)
Server State Reception: Authoritative state update arrives
Local Comparison: Compare with predicted state at same frame
Divergence Analysis: Identify significant differences
Rollback Decision: Determine if correction is necessary State Restoration: Revert to last confirmed server state
Input Replay: Re-apply all inputs since that frame
Simulation Catch-up: Run physics/reactions to current frame
Visual Interpolation: Smooth transition to corrected state
Own Actions Only: Predict consequences of local player inputs
Physics Prediction: Tile movement and basic collisions
Spell Effects: Immediate visual feedback for cast spells
Avoid Complex Rules: Don't predict environmental transformationsAll Player Actions: Predict other players' likely actions
Rule Interactions: Attempt complex environmental predictions
Higher Rollback Risk: More frequent corrections needed
Better Responsiveness: Smoother gameplay when predictions succeedNetwork Quality Based: Adjust strategy based on connection stability
Misprediction History: Learn from previous prediction accuracy
Dynamic Threshold: Modify rollback sensitivity based on gameplay contextinterface PredictedInput { frameNumber: number; playerId: string; inputData: PlayerInput; timestamp: number; confirmed: boolean;
} Local Input Capture: Player action registration
Immediate Prediction: Apply to local simulation instantly
Server Transmission: Send input with frame number
Confirmation Tracking: Mark inputs as confirmed when server acknowledges
History Cleanup: Remove old confirmed inputs from buffer
Interpolation: Smooth transition between predicted and actual states
Temporal Blending: Gradual adjustment over multiple frames
Priority System: Prioritize corrections for player-controlled entitiesOptimistic Updates: Show immediate response to player actions
Uncertainty Indicators: Visual cues for unconfirmed actions
Rollback Masking: Hide jarring corrections with effectsSpatial Boundaries: Only predict within player's view range
Temporal Limits: Maximum prediction window of 10 frames
Complexity Filtering: Skip expensive calculations during predictionState Compression: Efficient storage of rollback snapshots
Garbage Collection: Automatic cleanup of old prediction data
GPU Resource Sharing: Reuse textures between prediction and renderingLatency Measurement: Dynamic adjustment of prediction window
Quality Scaling: Reduce prediction complexity on slow connections
Fallback Mode: Disable prediction on extremely poor connectionsDesync Recovery: Full state resynchronization when prediction fails
Input Loss: Request missing inputs from server
State Corruption: Fallback to last known good stateConnection Loss: Maintain prediction until reconnection
High Latency: Extend prediction window with quality reduction
Packet Loss: Request state recovery from serverFrame Drops: Reduce prediction complexity automatically
Memory Pressure: Cleanup old snapshots more aggressively
GPU Issues: Fallback to CPU-only prediction if necessaryThis system provides responsive gameplay while maintaining competitive integrity through authoritative server validation.]]></description><link>architecture/systems/multiplayer/client-prediction.html</link><guid isPermaLink="false">architecture/systems/multiplayer/client-prediction.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[deployment]]></title><description><![CDATA[Container orchestration, regional deployment, and horizontal scaling infrastructure for multiplayer servers.Docker Configuration:
NVIDIA Docker runtime for GPU support
Ubuntu base image with WebGPU drivers
Node.js runtime with GPU-accelerated libraries
Minimal attack surface with only required packages
Container Specifications:FROM nvidia/ubuntu:22.04
RUN apt-get update &amp;&amp; apt-get install -y \ nodejs npm \ nvidia-driver-525 \ vulkan-utils
COPY package*.json ./
RUN npm ci --only=production
COPY dist/ ./dist/
EXPOSE 8080
CMD ["node", "dist/server.js"]
Resource Requirements:
4 vCPU cores per game server instance
16GB RAM per server (supports 8-12 concurrent games)
NVIDIA T4 or equivalent GPU (4GB VRAM minimum)
1Gbps network interface
Kubernetes Deployment:
Pod scheduling with GPU node affinity
Horizontal Pod Autoscaler based on CPU/GPU utilization
Service mesh for inter-service communication
ConfigMap and Secret management for configuration
Alternative: Docker Swarm:
Simpler orchestration for smaller deployments
Built-in load balancing and service discovery
GPU resource constraints and placement
Rolling updates with zero-downtime deployment
Primary Regions:
North America (East/West Coast)
Europe (Frankfurt, London)
Asia-Pacific (Singapore, Tokyo)
Optional: South America, Australia
Region Selection Criteria:
Player population density
Network infrastructure quality
Data sovereignty requirements
Cost optimization opportunities
Matchmaking Service:
Global player queue management
Region assignment based on latency
Cross-region backup for peak times
Load balancing across regional clusters
Data Synchronization:
Player profiles and statistics
Match history and replay data
Configuration and rule updates
Security blacklists and ban information
Auto-Scaling Configuration:apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata: name: game-server-hpa
spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: game-server minReplicas: 3 maxReplicas: 50 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 - type: Resource resource: name: nvidia.com/gpu target: type: Utilization averageUtilization: 80
Scaling Triggers:
CPU utilization &gt;70%
GPU utilization &gt;80%
Memory usage &gt;85%
Queue length &gt;100 waiting players
Average response time &gt;100ms
Resource Optimization:
GPU memory pooling across game instances
CPU allocation based on actual usage patterns
Memory tuning for garbage collection optimization
Network bandwidth allocation per game
Performance Monitoring:
Real-time resource utilization tracking
Application performance monitoring (APM)
Custom metrics for game-specific performance
Alerting for performance degradation
Core Services:interface ServiceArchitecture { gameServer: GameServerService; // Game simulation and state matchmaker: MatchmakingService; // Player matching and queuing authentication: AuthService; // Player authentication statistics: StatsService; // Match history and analytics configuration: ConfigService; // Game rules and settings
}
Service Communication:
gRPC for internal service communication
Redis for shared state and caching
Message queues for asynchronous processing
Service mesh for secure inter-service communication
Application Load Balancer:
Session affinity for WebSocket connections
Health check integration with Kubernetes
Geographic routing for optimal latency
SSL termination and certificate management
Game Server Load Balancing:
Consistent hashing for player assignment
Capacity-based routing
Failover to backup servers
Graceful shutdown with player migration
Game State: Redis cluster for real-time state
Player Data: PostgreSQL for persistent player information
Analytics: ClickHouse for match statistics and telemetry
Configuration: etcd for distributed configuration managementMatch Replays:
Compressed binary format for efficiency
Object storage (S3/GCS) for long-term archival
CDN distribution for replay downloads
Retention policy with automatic cleanup
Player Profiles:
Distributed across regions for performance
Eventual consistency for non-critical data
Backup and disaster recovery procedures
GDPR compliance for data deletion
Build Pipeline:
Source code compilation and TypeScript checking
Unit and integration test execution
Docker image building with security scanning
Image tagging and registry push
Deployment manifest generation
Deployment Strategy:
Blue-green deployment for zero-downtime updates
Canary releases for gradual rollout
Feature flags for controlled feature releases
Automated rollback on deployment failures
Development Environment:
Single-region deployment with minimal resources
Mock services for external dependencies
Debug logging and development tools
Rapid iteration and testing capabilities
Staging Environment:
Production-like configuration with reduced scale
Full integration testing
Performance and load testing
Security vulnerability scanning
Production Environment:
Multi-region deployment with full redundancy
Comprehensive monitoring and alerting
Security hardening and compliance
Disaster recovery procedures
System Metrics:
CPU, memory, GPU utilization per node
Network throughput and latency
Disk I/O and storage utilization
Container resource consumption
Application Metrics:
Game server response times
Player connection counts
Match completion rates
Error rates and exceptions
Critical Alerts:
Service downtime or unreachability
High error rates (&gt;5% of requests)
Resource exhaustion warnings
Security incident detection
Performance Alerts:
Latency degradation (&gt;100ms p95)
GPU utilization spikes (&gt;90%)
Memory pressure warnings
Network congestion detection
Centralized Logging:
ELK Stack (Elasticsearch, Logstash, Kibana) or equivalent
Structured logging with correlation IDs
Log aggregation from all services
Long-term log retention for compliance
Security Logging:
Authentication and authorization events
Suspicious activity detection
Security incident correlation
Audit trail for compliance requirements
Data Backup:
Automated database backups with point-in-time recovery
Game state snapshots for active matches
Configuration backup and version control
Cross-region replication for critical data
Recovery Procedures:
Recovery Time Objective (RTO): 15 minutes
Recovery Point Objective (RPO): 5 minutes
Automated failover for database services
Manual intervention procedures for complex failures
Service Redundancy:
Multi-region deployment with active-active configuration
Automatic traffic rerouting during outages
Graceful degradation during partial failures
Communication plan for extended outages
This deployment architecture provides scalable, reliable multiplayer infrastructure capable of supporting global competitive gameplay with minimal latency and maximum uptime.]]></description><link>architecture/systems/multiplayer/deployment.html</link><guid isPermaLink="false">architecture/systems/multiplayer/deployment.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[multiplayer]]></title><description><![CDATA[Real-time PvP multiplayer architecture using authoritative servers with client-side prediction.The multiplayer system leverages Reaction's deterministic engine design to enable competitive real-time gameplay. An authoritative server runs the identical simulation while clients predict local actions to maintain responsive gameplay.Authoritative game simulation with GPU-accelerated processing identical to client engine.Local state prediction with rollback mechanisms for responsive gameplay despite network latency.WebSocket-based communication with optimized state synchronization and delta compression.Bandwidth optimization, server scaling, and latency management strategies.Input validation, state integrity, and cheat detection systems.Container orchestration, regional deployment, and horizontal scaling infrastructure.Core Engine Integration
Server runs headless version of identical simulation
Leverages existing GPU compute shaders for physics and reactions
Uses bit-packed tile format for efficient network transmission
Deterministic Design Benefits
Integer-only mathematics ensures identical client/server results
Strict execution order enables reliable rollback mechanisms
Active region system scales network bandwidth with activity level
WebGPU Compatibility
Server requires GPU-capable infrastructure
Compute shaders run identically on both client and server
Texture ping-ponging system adapted for network synchronization Core Networking: WebSocket protocol and basic state synchronization
Server Engine: Headless game engine with GPU compute capabilities
Client Prediction: Local state management with rollback
Performance: Bandwidth compression and server scaling
Security: Anti-cheat and input validation systems
Server Infrastructure
GPU-capable servers (NVIDIA T4 or equivalent)
WebGPU-compatible Node.js environment
16GB RAM per game instance (4-8 players)
Performance Targets
60 FPS authoritative simulation
&lt;50ms input processing latency
&lt;16MB bandwidth per player per minute
Support 100+ concurrent matches per server
This architecture provides competitive multiplayer performance while building on Reaction's existing deterministic engine design.]]></description><link>architecture/systems/multiplayer/multiplayer.html</link><guid isPermaLink="false">architecture/systems/multiplayer/multiplayer.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[core]]></title><description><![CDATA[Central coordination and tile data management for the Reaction v2 game engine.The Core Engine coordinates data flow between CPU spell logic and GPU simulation systems while maintaining high performance and deterministic execution.Key Challenge: Synchronize three different processing systems (CPU spells, GPU physics, GPU reactions) without race conditions or performance bottlenecks.
Bit-packed tile storage across 4 layers (Ground, Object, Air, Rune)
GPU texture management with ping-ponging for race-condition prevention Active region optimization using 32×32 chunks
Frame execution pipeline coordination <a class="internal-link" data-href="tile-storage.md" href="architecture/systems/core/tile-storage.html" target="_self" rel="noopener nofollow"><strong></strong></a>Tile Storage System - Bit-packing format and layer organization
<br><a class="internal-link" data-href="texture-management.md" href="architecture/systems/core/texture-management.html" target="_self" rel="noopener nofollow"><strong></strong></a>Texture Management - GPU texture coordination and ping-ponging
<br><a class="internal-link" data-href="active-regions.md" href="architecture/systems/core/active-regions.html" target="_self" rel="noopener nofollow"><strong></strong></a>Active Regions - Chunk-based processing optimization
<br><a class="internal-link" data-href="api-reference.md" href="architecture/systems/core/api-reference.html" target="_self" rel="noopener nofollow"><strong></strong></a>API Reference - Classes and integration points Ground Layer: Terrain foundation (dirt, stone, water)
Object Layer: Interactive entities (rocks, trees, creatures, players)
Air Layer: Gases and effects (fire, smoke, magic) Rune Layer: Spell-placed magical effects (temporary) Active Region System: Only process chunks with changing tiles
Texture Ping-Ponging: Prevents GPU read-after-write hazards
Bit-Packed Storage: 32-bit tile representation
Chunk-Based Processing: 32×32 tile regions Spell System: Writes rune data to rune layer textures
Physics Engine: Reads/writes velocity data via texture pairs
Reaction Engine: Processes transformation rules on tile data Renderer: Provides read-only access to current tile states for display
Game Logic: Exposes tile query API for validation and state checking WebGPU API: Required for texture management and GPU compute coordination
]]></description><link>architecture/systems/core/core.html</link><guid isPermaLink="false">architecture/systems/core/core.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[texture-management]]></title><description><![CDATA[GPU texture coordination and ping-ponging system for race-condition prevention.Challenge: Prevent GPU read-after-write hazards when multiple systems access the same tile data simultaneously.Solution: Texture ping-ponging using paired textures for each layer.Each layer uses paired textures (layer_A, layer_B) enabling GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards.
Read Phase: Modules read from texture set A
Write Phase: Modules write to texture set B Swap Phase: Texture roles switch for next frame
Barrier: GPU compute dispatch barriers ensure proper execution ordering
Format: r32uint for optimal GPU cache performance
Rationale: Single 32-bit channel matches bit-packed tile format2D Layout: Textures leverage GPU's optimized 2D memory access patterns
Spatial Locality: Neighboring tiles often accessed together benefit from cache prefetching
Input Processing: Reads from current texture set
Physics Pass: Writes to alternate texture set
Reaction Pass: Reads from physics output textures
Render Pass: Reads from stable texture set for display
Active Texture Tracking: Core Engine maintains current read/write texture assignments
Automatic Swapping: Texture roles alternate each frame automatically
Resource Cleanup: Proper GPU resource lifecycle management⚠️ NEEDS IMPLEMENTATION DETAIL: Specific WebGPU texture creation and binding patternsTrade-off: Double memory usage (2x textures per layer) for synchronization safety
Optimization: Memory layout optimized for GPU architecture⚠️ NEEDS DESIGN: GPU resource allocation failure handling and recovery strategies
Race Condition Prevention: Eliminates GPU synchronization hazards
Pipeline Operations: Allows overlapped read/write operations
Memory Layout: 2D texture layout for spatial access patterns Memory Overhead: 2x memory usage per layer
Texture Switching: Minimal GPU overhead for texture binding updates
⚠️ NEEDS SPECIFICATION: Core classes and methods for texture managementPlanned Classes:
TextureManager: Handles ping-ponging and synchronization TileStorage: Manages texture allocation and bit-packing
Integration with GameLoop for frame coordination
]]></description><link>architecture/systems/core/texture-management.html</link><guid isPermaLink="false">architecture/systems/core/texture-management.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[tile-storage]]></title><description><![CDATA[Problem: GPU shaders need packed data, but game logic needs flexible representations.Solution: Bit-packed 32-bit tiles stored in GPU textures.
Ground Layer: Terrain foundation (dirt, stone, water)
Object Layer: Interactive entities (rocks, trees, creatures)
Air Layer: Gases and effects (fire, smoke, magic) Rune Layer: Spell-placed magical effects (temporary)
Note: Specific bit allocation TBD during implementation. Approximate layout:
Tile Type (~6 bits, chosen for comfortable headroom)
Velocity X/Y (signed values for movement)
Custom Data (remaining bits for health, timers, charges)
Texture Ping-Ponging: Each layer uses paired textures (layer_A, layer_B) enabling GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards.Memory Layout: Textures use r32uint format for optimal GPU cache performance.Purpose: Avoid processing static regions to maintain performance.Implementation:
Divide world into 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)
Track chunks with active tiles in GPU buffer
Shaders only process listed active chunks
Activity propagates to neighboring chunks automatically
Dormant regions have minimal GPU cost TileStorage: Manages texture allocation and bit-packing
TextureManager: Handles ping-ponging and synchronization
GameLoop: Coordinates frame execution pipeline
ActiveRegionTracker: Optimizes chunk-based processing Spell System: Writes rune data to rune layer textures
Physics Engine: Reads/writes velocity data via texture pairs
Reaction Engine: Processes transformation rules on tile data
Renderer: Reads current tile states for display
]]></description><link>architecture/systems/core/tile-storage.html</link><guid isPermaLink="false">architecture/systems/core/tile-storage.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[gpu]]></title><description><![CDATA[Shared WebGPU resource management and coordination for all GPU-accelerated systems.The GPU Manager System manages the WebGPU instance, device initialization, and resource sharing across all systems that require GPU computation or rendering.Key Challenge: Coordinate GPU resource usage across multiple systems (Physics, Reactions, Renderer) while maintaining performance and preventing resource conflicts.
WebGPU device initialization and capability detection
GPU resource allocation and memory management
Compute pipeline coordination between systems
Error handling and recovery for GPU operations
Performance monitoring and resource utilization tracking WebGPU Device: Single device instance shared across all systems
Buffer Pools: Reusable buffer allocation for different data types
Texture Management: Coordinate texture creation and lifecycle
Compute Queue: Prioritized command queue for GPU operations Physics System: Provides compute shaders for collision and movement
Reactions System: Manages rule compilation and execution shaders Renderer: Coordinates rendering pipeline and display
Core System: Integrates with texture ping-ponging and memory management Automatic Fallback: Handle WebGPU unavailability gracefully
Capability Detection: Query and adapt to GPU limitations
Error Recovery: Robust handling of GPU context loss
Performance Profiling: Built-in GPU timing and resource monitoring Allocation Tracking: Monitor buffer and texture usage across systems
Memory Optimization: Efficient sharing and reuse of GPU resources
Priority Management: Coordinate competing GPU workloads
Synchronization: Ensure proper ordering of GPU operations Device Setup: Initialize WebGPU device with required features
System Registration: Allow systems to register their GPU requirements
Resource Allocation: Provide standardized buffer/texture allocation Command Submission: Centralized GPU command queue management
Resource Sharing: Safe sharing of buffers and textures between systems
Performance Monitoring: Real-time GPU utilization reporting WebGPU API: Required for all GPU operations
Browser/Platform: WebGPU support and capabilities
]]></description><link>architecture/systems/gpu/gpu.html</link><guid isPermaLink="false">architecture/systems/gpu/gpu.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[config]]></title><description><![CDATA[Status: 🚧 Stub - This system documentation needs completionSystem for managing game configuration, settings, and runtime parameters.TODO: Add links to configuration components when implemented:
Configuration file formats and schemas
Runtime configuration management
Environment-specific settings
Validation and error handling
TODO: Document configuration system responsibilities:
Game settings and parameters
Environment configuration (dev/test/prod)
Runtime parameter management
Configuration validation and defaults
TODO: Define configuration categories:
Game Settings: Tile limits, world parameters, gameplay constants
Performance Settings: GPU options, rendering quality, frame rate targets
Network Settings: Server endpoints, timeout values, retry policies
Development Settings: Debug flags, logging levels, profiling options
TODO: Add implementation details:
Configuration file loading and parsing
Hot-reloading of configuration changes
Configuration override hierarchy
Validation and schema enforcement
🚧 This file is a stub and needs completion]]></description><link>architecture/systems/config/config.html</link><guid isPermaLink="false">architecture/systems/config/config.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[active-regions]]></title><description><![CDATA[Chunk-based processing optimization to avoid processing static regions.Purpose: Avoid processing static regions to maintain performance.Core Characteristic: Automatic scaling with activity level rather than world size.
Chunk Size: 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)
World Organization: Divide entire world into fixed chunk grid
Chunk Coordinates: Each chunk identified by (chunk_x, chunk_y) coordinates Active Chunk Buffer: GPU buffer maintains list of chunks with active tiles
Shader Processing: Shaders only process tiles in listed active chunks
Dynamic Updates: Chunks added/removed from active list based on tile changes Neighbor Activation: Activity automatically propagates to neighboring chunks
Movement Spreading: Moving tiles mark their destination chunks as active
Collision Effects: Collisions spread activity to neighboring regions
Gradual Decay: Activity in stable regions decays over time
@compute @workgroup_size(8, 8)
fn process_active_chunks(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let chunk_coord = active_chunks[workgroup_id.x]; let local_coord = global_id.xy; let world_coord = chunk_coord * 32u + local_coord; // Process only tiles in active chunks if (world_coord.x &lt; world_size.x &amp;&amp; world_coord.y &lt; world_size.y) { process_tile(world_coord); }
}
GPU Alignment: 32×32 chunks align well with GPU workgroup sizes
Memory Coalescing: Chunk-based processing improves memory access patterns
Thread Utilization: Reduces wasted GPU threads on empty regions
Activity-Based Cost: Processing cost scales with active tiles, not world size
Dormant Regions: Static areas have minimal GPU cost
Memory Access: Reduced texture memory accesses in inactive regions
Active Chunk Buffer: Small GPU buffer storing active chunk coordinates
Tracking Data: Minimal per-chunk metadata for activity state
Negligible Cost: Buffer size insignificant compared to texture memory
Tile Movement: Moving tiles activate their current and destination chunks
Spell Casting: Rune placement activates target chunks
Environmental Changes: Rule transformations mark chunks active
Force Application: Physics forces spread activation
⚠️ NEEDS DESIGN: Specific strategy for marking chunks inactive
Potential approaches: Timer-based decay, change detection, activity counters
Challenge: Balance between responsiveness and performance
Chunk Boundaries: Ensure proper handling of tiles affecting multiple chunks
Large Effects: Spells or explosions affecting many chunks simultaneously
Performance Spikes: Sudden activation of many dormant regions
Movement Processing: Physics updates active chunk list based on tile movement
Collision Detection: Collision effects activate neighboring chunks Rule Processing: Environmental transformations mark affected chunks active
Pattern Matching: Large-scale patterns may activate multiple chunks Rune Placement: Spell casting activates target chunks immediately
Area Effects: Large spells properly handle multi-chunk activation
⚠️ NEEDS SPECIFICATION: Detailed implementation approach for:
Active chunk buffer data structure
GPU buffer update mechanisms Integration with existing texture ping-ponging
Performance monitoring and tuning capabilities
]]></description><link>architecture/systems/core/active-regions.html</link><guid isPermaLink="false">architecture/systems/core/active-regions.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[api-reference]]></title><description><![CDATA[Classes, interfaces, and integration points for the Core Engine system.⚠️ STATUS: API design has not been established yet. The following are suggestions for future design work.⚠️ SUGGESTION: Manages texture allocation and bit-packing operations.Potential Responsibilities:
Bit-packing and unpacking of tile data
Texture allocation and memory management
Layer-specific data access patterns
⚠️ NEEDS DESIGN: Detailed method signatures and data structuresHandles ping-ponging and GPU synchronization.Responsibilities:
Texture pair management for each layer
Ping-pong switching between frames
GPU resource lifecycle management
Synchronization barrier coordination
⚠️ NEEDS DESIGN: WebGPU integration patterns and error handlingCoordinates frame execution pipeline across all modules.Responsibilities:
Frame timing and execution order
Module coordination and communication
Performance monitoring and bottleneck detection
⚠️ NEEDS SPECIFICATION: Integration with different module update frequenciesOptimizes chunk-based processing across GPU modules.Responsibilities:
Active chunk list management
Activity propagation logic
GPU buffer updates for active regions
Performance scaling based on activity
⚠️ NEEDS SPECIFICATION: Activity detection and decay algorithmsRune Placement API:// Preliminary interface - subject to change
interface RunePlacementAPI { placeRune(position: TileCoord, rune: RuneData): void; removeRune(position: TileCoord): void; queryRune(position: TileCoord): RuneData | null;
}
Velocity Management API:// Preliminary interface - subject to change
interface VelocityAPI { setVelocity(position: TileCoord, velocity: Vector2): void; getVelocity(position: TileCoord): Vector2; applyForce(position: TileCoord, force: Vector2): void;
}
Tile State API:// Preliminary interface - subject to change interface TileStateAPI { getTile(position: TileCoord, layer: LayerType): TileData; setTile(position: TileCoord, layer: LayerType, data: TileData): void; queryNeighborhood(center: TileCoord, radius: number): TileData[];
}
Read-Only Display API:// Preliminary interface - subject to change
interface DisplayAPI { getCurrentTileState(position: TileCoord): LayeredTileData; getVisibleRegion(viewport: Rectangle): TileData[]; subscribeToChanges(callback: (changes: TileChange[]) =&gt; void): void;
}
⚠️ NEEDS FINALIZATION: Specific bit allocation during implementation// Preliminary structure - bit allocation TBD
interface TileData { type: number; // ~6 bits - tile type identifier velocity: Vector2; // 16 bits - movement vector (signed) customData: number; // ~10 bits - health, timers, charges
}
enum LayerType { Ground = 0, // Terrain foundation Object = 1, // Interactive entities Air = 2, // Gases and effects Rune = 3 // Spell-placed effects
}
interface TileCoord { x: number; y: number;
} interface ChunkCoord { chunkX: number; chunkY: number;
}
⚠️ NEEDS DESIGN: Comprehensive error handling strategy for:
GPU resource allocation failures
WebGPU device lost scenarios Texture memory exhaustion
Invalid tile coordinate access
Synchronization failures
⚠️ NEEDS IMPLEMENTATION: Built-in profiling capabilities for:
Frame timing breakdown by module
GPU utilization and memory bandwidth
Active region processing efficiency
Texture ping-pong overhead measurement WebGPU API: Core dependency for all GPU operations
TypeScript: Type safety and development experience Integration with all other game modules
Shared type definitions across the codebase
Common utility functions and error types
]]></description><link>architecture/systems/core/api-reference.html</link><guid isPermaLink="false">architecture/systems/core/api-reference.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[state-management]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed unified state management approach that serves both single-player gameplay and multiplayer networking requirements through a single pipeline.Core Concept: Use identical state management for single-player, multiplayer client prediction, and multiplayer server authority.Benefits:
Consistent behavior across all game modes
Simplified testing and debugging
Reduced code duplication
Natural multiplayer upgrade path Frame-based snapshots for rollback and networking
Deterministic state serialization for cross-platform consistency Efficient delta compression for multiplayer bandwidth optimization
Rollback recovery for client prediction correction
Frequency: Every frame (60 FPS) for complete state history.Retention: 300 snapshots (5 seconds) in circular buffer for rollback window.Compression: Incremental snapshots with delta compression for memory efficiency.interface GameStateSnapshot { frameNumber: number; timestamp: number; // Core game data tileData: CompressedTileData; playerStates: PlayerStateData[]; activeChunks: ChunkId[]; // Timing system state timeSliceState: TimeSliceSchedulerState; manaRechargeState: ManaSchedulerState; // Validation checksum: string; // Compression metadata deltaBaseFrame?: number; compressionLevel: 'full' | 'delta' | 'minimal';
} class StateSnapshotManager { private snapshots = new CircularBuffer&lt;GameStateSnapshot&gt;(300); private deltaCompressor = new DeltaCompressor(); saveFrameState(frameNumber: number, gameState: GameState): void { const snapshot = this.createSnapshot(frameNumber, gameState); this.snapshots.push(snapshot); // Clean up old snapshots beyond retention window this.cleanupOldSnapshots(); } private createSnapshot(frameNumber: number, state: GameState): GameStateSnapshot { // Determine compression strategy const useFullSnapshot = frameNumber % 60 === 0; // Every second const compressionLevel = useFullSnapshot ? 'full' : 'delta'; return { frameNumber, timestamp: performance.now(), tileData: this.compressTileData(state.tiles, compressionLevel), playerStates: this.serializePlayerStates(state.players), activeChunks: Array.from(state.activeChunks), timeSliceState: state.scheduler.serialize(), manaRechargeState: state.manaScheduler.serialize(), checksum: this.calculateChecksum(state), deltaBaseFrame: useFullSnapshot ? undefined : frameNumber - 1, compressionLevel }; }
}
Multiplayer Misprediction: Server state differs from client prediction.Determinism Failure: Checksum mismatch in single-player determinism testing.Network Recovery: Client needs to resynchronize with server.class RollbackManager { async rollbackToFrame(targetFrame: number): Promise&lt;boolean&gt; { // Find target snapshot const snapshot = this.snapshotManager.getSnapshot(targetFrame); if (!snapshot) { console.error(`Cannot rollback: snapshot ${targetFrame} not found`); return false; } // Restore game state await this.restoreGameState(snapshot); // Re-execute frames from rollback point to current const currentFrame = this.gameEngine.getCurrentFrame(); for (let frame = targetFrame + 1; frame &lt;= currentFrame; frame++) { await this.replayFrame(frame); } return true; } private async restoreGameState(snapshot: GameStateSnapshot): Promise&lt;void&gt; { // Restore tile data await this.tileManager.restoreFromSnapshot(snapshot.tileData); // Restore player states this.playerManager.restoreFromSnapshot(snapshot.playerStates); // Restore timing system state this.scheduler.deserialize(snapshot.timeSliceState); this.manaScheduler.deserialize(snapshot.manaRechargeState); // Validate restoration const restoredChecksum = this.calculateChecksum(this.gameState); if (restoredChecksum !== snapshot.checksum) { throw new Error('State restoration checksum mismatch'); } }
}
Local Simulation: Run complete game simulation locally for responsiveness.Server Validation: Compare local state with authoritative server updates.Automatic Correction: Rollback and re-execute when server state differs.class ClientPredictionManager { private pendingInputs = new Map&lt;number, PlayerInput[]&gt;(); private serverStates = new Map&lt;number, GameStateSnapshot&gt;(); processServerUpdate(serverSnapshot: GameStateSnapshot): void { const frameNumber = serverSnapshot.frameNumber; this.serverStates.set(frameNumber, serverSnapshot); // Compare with local prediction const localSnapshot = this.snapshotManager.getSnapshot(frameNumber); if (localSnapshot &amp;&amp; !this.statesMatch(localSnapshot, serverSnapshot)) { console.log(`Misprediction detected at frame ${frameNumber}, rolling back`); this.rollbackManager.rollbackToFrame(frameNumber); } // Confirm inputs up to this frame this.confirmInputsUpToFrame(frameNumber); } private statesMatch(local: GameStateSnapshot, server: GameStateSnapshot): boolean { // Compare essential game state (ignore client-only data) return ( local.checksum === server.checksum &amp;&amp; this.tileDataMatches(local.tileData, server.tileData) &amp;&amp; this.playerStatesMatch(local.playerStates, server.playerStates) ); }
}
Authoritative Simulation: Server runs definitive game simulation.Input Validation: Validate all client inputs before application.State Broadcasting: Send compressed state updates to all clients.class ServerAuthorityManager { private connectedClients = new Set&lt;ClientConnection&gt;(); processFrame(): void { // Standard game processing this.gameEngine.processFrame(); // Generate state delta for clients const currentFrame = this.gameEngine.getCurrentFrame(); const stateDelta = this.generateStateDelta(currentFrame); // Broadcast to all clients this.broadcastStateDelta(stateDelta); } private generateStateDelta(frameNumber: number): StateDelta { const currentSnapshot = this.snapshotManager.getSnapshot(frameNumber); const previousSnapshot = this.snapshotManager.getSnapshot(frameNumber - 1); return this.deltaCompressor.createDelta(previousSnapshot, currentSnapshot); }
}
Change Detection: Only transmit modified tiles per frame.Run-Length Encoding: Compress sequences of similar changes.Spatial Compression: Group changes by active regions.class TileDeltaCompressor { compressTileChanges(oldTiles: TileData, newTiles: TileData): CompressedTileData { const changes: TileChange[] = []; // Detect changes for (let y = 0; y &lt; this.worldHeight; y++) { for (let x = 0; x &lt; this.worldWidth; x++) { const oldTile = oldTiles.getTile(x, y); const newTile = newTiles.getTile(x, y); if (oldTile !== newTile) { changes.push({ x, y, oldValue: oldTile, newValue: newTile }); } } } // Apply compression algorithms return this.compressChanges(changes); } private compressChanges(changes: TileChange[]): CompressedTileData { // Group by active chunks const chunkChanges = this.groupByChunk(changes); // Apply run-length encoding within chunks const compressed = chunkChanges.map(chunk =&gt; this.runLengthEncode(chunk.changes) ); return { changedChunks: compressed, compressionRatio: changes.length / compressed.length }; }
}
Snapshot Pooling: Reuse snapshot objects to reduce garbage collection.Lazy Compression: Compress snapshots in background thread when possible.Memory-Mapped Storage: Use efficient binary formats for large state data.Adaptive Compression: Adjust compression level based on network conditions.Priority Transmission: Send critical state changes immediately.Batch Optimization: Group small changes into larger network packets.Incremental Replay: Only re-execute affected systems during rollback.State Caching: Cache frequently accessed rollback points.Parallel Processing: Use worker threads for rollback computation when possible.Checksum Validation: Verify state integrity at snapshot creation and restoration.Cross-Reference Checking: Validate state consistency across different data structures.Automated Recovery: Attempt automatic recovery from last known good state.Connection Recovery: Seamless reconnection with state synchronization.Missing Data Recovery: Request missing snapshots from server.Graceful Degradation: Continue local simulation during temporary disconnections.class DeterminismValidator { validateStateConsistency(snapshot: GameStateSnapshot): ValidationResult { // Check internal consistency const tileConsistency = this.validateTileData(snapshot.tileData); const playerConsistency = this.validatePlayerStates(snapshot.playerStates); const timingConsistency = this.validateTimingState(snapshot.timeSliceState); // Verify checksum const calculatedChecksum = this.calculateChecksum(snapshot); const checksumValid = calculatedChecksum === snapshot.checksum; return { valid: tileConsistency &amp;&amp; playerConsistency &amp;&amp; timingConsistency &amp;&amp; checksumValid, errors: this.collectValidationErrors(), warnings: this.collectValidationWarnings() }; }
} cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture <br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Integration with time slice scheduling
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/multiplayer/multiplayer.html" data-href="multiplayer" aria-label="multiplayer" data-tooltip-position="top" target="_self">Multiplayer System</a> - Network protocol and client prediction details
⚠️ NEEDS TEAM DISCUSSION:
Snapshot retention policy (current proposal: 5 seconds)
Delta compression vs full snapshot frequency (current proposal: every 60 frames)
Rollback window limits for client prediction
⚠️ NEEDS IMPLEMENTATION:
Performance benchmarking of snapshot creation overhead
Network bandwidth testing with delta compression
Cross-platform determinism validation suite
]]></description><link>architecture/general/state-management.html</link><guid isPermaLink="false">architecture/general/state-management.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[technical-decisions]]></title><description><![CDATA[Design choices, rationale, and alternative approaches considered during Reaction v2 architecture.Decision: Separate concerns into focused, loosely-coupled modules
Rationale: Enables independent development and testing of complex systems
Alternative Considered: Monolithic architecture - rejected for maintainability concernsDecision: WebGPU-based processing for physics, reactions, and rendering
Rationale: Required performance for thousands of interacting tiles at 60 FPS
Trade-offs: Added complexity vs. performance requirementsSpell System: Initially chosen for CPU because it handles direct player input and seemed more straightforward to implement. This choice may be revisited during implementation.Physics Engine: GPU compute shaders with hardcoded physics rules
Rationale: High parallelization needs for tile movement and collision detectionReaction Engine: GPU compute shaders with compiled rules
Rationale: Complex rule evaluation benefits from parallel processingDecision: Input → Physics → Runes → Reactions → Render
Rationale: Ensures deterministic execution and proper data dependencies
⚠️ UNSOLVED: Timing coordination between systems at different frequenciesDecision: 32-bit integers with packed tile data
Rationale: GPU cache efficiency and memory bandwidth optimization
⚠️ NOTE: Specific bit allocation TBD during implementation. See <a class="internal-link" data-href="../systems/core-engine/tile-storage.md" href=".html" target="_self" rel="noopener nofollow">tile-storage.md</a> for current architectural approach.Decision: Ground, Object, Air, Rune layers
Rationale: Clean separation of different tile behaviors and interactions
Alternative Considered: Single layer with type flags - rejected for complexityDecision: Dual texture approach for each layer
Rationale: Prevents GPU read-after-write hazards and race conditions
Trade-off: Double memory usage for synchronization safetyDecision: 32×32 tile chunks for processing optimization
Rationale: Balances GPU workgroup efficiency with memory overhead
Alternative Sizes Considered: 16×16 (too small), 64×64 (too large for cache)Decision: JSON rules → GPU shaders via offline compilation
Rationale: Move computational work to build time for runtime performance
⚠️ NOTE: Alternative approaches may be considered during implementationDecision: 3-turn recharge cycle with unlimited regeneration
Rationale: Balances spell casting incentive vs strategic saving
Alternative Considered: Scarcity-based system - rejected for pacing concernsDecision: 2:1 mana flower trading removed
Rationale: Simplified resource management modelDecision: ~64 tile types per layer
Rationale: Chosen to be comfortably under realistic GPU and memory limits
Constraint: Leaves room for expansion without architectural changesDecision: Identical inputs must produce identical outputs
Rationale: Essential for fair PvP gameplay
Implementation: Integer-only mathematics, strict execution ordering
⚠️ CHALLENGE: GPU thread execution order is not inherently deterministicDecision: Fixed world size at initialization
Rationale: Avoids dynamic streaming complexity
Trade-off: Limits map variety for implementation simplicityDecision: Grid-based rule design interface planned
Rationale: Simplifies rule creation and prevents impossible shader compilation
Status: Design planned, implementation TBDDecision: Use containerized build for consistent results
Rationale: Ensures deterministic shader compilation across development environments
⚠️ STATUS: Implementation approach needs specification⚠️ Major Design Decisions Still Needed: Frame Rate Coordination: How to handle different update frequencies between physics (60 FPS) and reactions (potentially lower)? GPU Determinism: Specific approach to ensure consistent thread execution order? Rule Compilation Pipeline: Exact toolchain and optimization steps? Spell Hand Size: UI and gameplay constraints on number of spells available? World Size Limits: Performance testing needed to determine optimal map dimensions? Build System Integration: How rule compilation integrates with main build process? ]]></description><link>architecture/general/technical-decisions.html</link><guid isPermaLink="false">architecture/general/technical-decisions.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[variable-timing]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed time slice scheduling system that enables variable player action timing while maintaining deterministic 60 FPS execution.Variable Player Speeds: Different players can have different action timing based on status effects.Fixed Mana Timing: Mana recharge remains strategically consistent regardless of player speed changes.Smooth Physics: Maintain 60 FPS physics simulation for fluid movement.Deterministic Execution: All timing decisions must be reproducible for multiplayer.Frame Duration: 16.67ms (60 FPS)
Time Slices: 8 slices per frame
Slice Duration: 2.08ms per sliceRationale: 8 slices provides sufficient granularity for speed effects (0.5x to 2x) while maintaining reasonable processing overhead.interface TimeSliceSchedule { // Base timing (normal speed) baseActionInterval: 8; // 8 slices = 1 action baseManaInterval: 24; // 24 slices = 3 actions // Physics runs every slice for smooth motion physicsInterval: 1; // Reactions run less frequently for performance reactionInterval: 4; // Every 4 slices
}
Speed Effects: Status effects modify player action timing immediately.Calculation: newInterval = baseInterval / speedMultiplierSpeed Ranges: Slowed: 0.5x (16 slices per action)
Normal: 1.0x (8 slices per action) Hasted: 2.0x (4 slices per action)
interface PlayerActionSchedule { playerId: string; currentInterval: number; // Current slices between actions nextActionSlice: number; // When next action executes queuedActions: PlayerAction[]; // 3 actions lookahead speedMultiplier: number; // Current speed effect
} class TimeSliceScheduler { private playerSchedules = new Map&lt;string, PlayerActionSchedule&gt;(); private currentSlice = 0; // Process all scheduled actions for this slice processSlice(sliceIndex: number) { this.currentSlice = sliceIndex; // Process players in deterministic order (by ID) const sortedPlayerIds = Array.from(this.playerSchedules.keys()).sort(); for (const playerId of sortedPlayerIds) { this.processPlayerSchedule(playerId, sliceIndex); } } private processPlayerSchedule(playerId: string, slice: number) { const schedule = this.playerSchedules.get(playerId); if (schedule.nextActionSlice === slice) { // Execute queued action const action = schedule.queuedActions.shift(); this.executePlayerAction(playerId, action); // Schedule next action schedule.nextActionSlice = slice + schedule.currentInterval; // Request new action for queue this.requestNextAction(playerId); } }
}
Independence: Mana timing unaffected by player speed changes.Strategic Consistency: Players can rely on consistent mana timing for tactical planning.Implementation: Separate timing system running parallel to player actions.class ManaRechargeScheduler { private readonly MANA_RECHARGE_INTERVAL = 24; // 3 base actions worth private nextRechargeSlice = 24; processSlice(sliceIndex: number) { if (sliceIndex === this.nextRechargeSlice) { this.rechargeManaFlowers(); this.nextRechargeSlice += this.MANA_RECHARGE_INTERVAL; } } private rechargeManaFlowers() { // Recharge all mana flowers regardless of player speeds for (const flower of this.getAllManaFlowers()) { flower.recharge(); } }
}
Timing Update: Speed effects immediately modify next action timing.Queue Preservation: Existing action queue remains valid but timing adjusts.Deterministic Application: Speed changes processed in consistent order.class StatusEffectManager { applySpeedEffect(playerId: string, newMultiplier: number) { const schedule = this.scheduler.getPlayerSchedule(playerId); const currentSlice = this.scheduler.getCurrentSlice(); // Calculate remaining time to next action const remainingSlices = schedule.nextActionSlice - currentSlice; // Apply speed change to remaining time const speedChange = newMultiplier / schedule.speedMultiplier; const newRemainingSlices = Math.ceil(remainingSlices / speedChange); // Update schedule schedule.speedMultiplier = newMultiplier; schedule.currentInterval = Math.ceil(8 / newMultiplier); // 8 = base interval schedule.nextActionSlice = currentSlice + newRemainingSlices; // Invalidate affected ghost predictions this.ghostSimulator.invalidatePlayerPredictions(playerId); }
}
Simultaneous Actions: When multiple players have actions scheduled for same slice, process in deterministic order (player ID).Queue Validation: Validate action legality when scheduled, not when executed.Timing Consistency: Ensure identical timing calculations across all clients and server.class SchedulingEdgeCases { // Handle sub-slice timing precision handleFractionalSlices(calculatedSlices: number): number { // Always round up to ensure actions don't execute too early return Math.ceil(calculatedSlices); } // Handle extreme speed changes clampSpeedMultiplier(multiplier: number): number { return Math.max(0.1, Math.min(10.0, multiplier)); } // Handle action queue overflow validateActionQueue(queue: PlayerAction[]): boolean { // Ensure queue never exceeds 3 actions return queue.length &lt;= 3; }
}
Sparse Processing: Only process slices with scheduled events.Batch Operations: Group similar operations within same slice.Memory Efficiency: Use circular buffers for timing data.Consistent Frequency: Physics processes every slice for smooth motion.Interpolation: Visual interpolation between physics updates for display.State Synchronization: Ensure physics state consistency with action timing.Lookahead: Simulate 3 queued actions for each player.Timing Prediction: Account for current speed effects in predictions.Invalidation: Update predictions when speed effects change.class GhostTimingPredictor { predictActionTiming(playerId: string, actionCount: number): number[] { const schedule = this.scheduler.getPlayerSchedule(playerId); const predictions: number[] = []; let nextSlice = schedule.nextActionSlice; for (let i = 0; i &lt; actionCount; i++) { predictions.push(nextSlice); nextSlice += schedule.currentInterval; } return predictions; }
}
Determinism Tests: Verify identical timing across multiple runs.Edge Case Coverage: Test extreme speed values and rapid changes.Synchronization Validation: Ensure client-server timing consistency.Slice Processing Overhead: Measure time slice processing cost.Memory Usage: Monitor scheduling data structure efficiency.Scalability: Test with varying player counts and speed effects.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/deterministic-execution.html" data-href="deterministic-execution" aria-label="deterministic-execution" data-tooltip-position="top" target="_self">Deterministic Execution</a> - Execution order and consistency
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> - Integration with state snapshots
⚠️ NEEDS TEAM DISCUSSION:
Optimal slice count (current proposal: 8 slices per frame)
Speed multiplier ranges (current proposal: 0.1x to 10x)
Ghost prediction complexity vs performance trade-offs
⚠️ NEEDS IMPLEMENTATION:
Detailed performance benchmarking of time slice overhead
Integration testing with existing Core Engine texture management
Multiplayer synchronization validation
]]></description><link>architecture/general/variable-timing.html</link><guid isPermaLink="false">architecture/general/variable-timing.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[implementation-guide]]></title><description><![CDATA[⚠️ PROPOSED IMPLEMENTATION PLAN: This document outlines the suggested implementation approach for the Deterministic Time-Sliced Execution pipeline. All timelines and priorities should be validated with the team.Goal: Establish deterministic frame processing with time slicing.Components:
DeterministicTimeSlicedPipeline - Main pipeline class
TimeSliceScheduler - Variable timing management DeterministicMath - Integer-only math library
StateSnapshotManager - Frame-based state capture
Success Criteria: 60 FPS deterministic execution with variable player action timing.Estimated Complexity: High - foundational architecture changes required.Goal: Achieve consistent GPU processing across platforms.Components:
SpatialOrderingStrategy - Deterministic tile processing order
DeterministicGPUProcessor - GPU compute shader coordination
FixedPointMath - GPU shader math library
DeterminismValidator - Cross-platform testing framework
Success Criteria: Identical results across different GPU hardware.Estimated Complexity: Very High - requires low-level GPU programming expertise.Goal: Unified state system for single-player and multiplayer.Components:
UnifiedGameEngine - Mode-agnostic game engine
RollbackManager - State restoration and replay
DeltaCompressor - Network-efficient state compression
ClientPredictionManager - Multiplayer prediction integration
Success Criteria: Seamless transition between single-player and multiplayer modes.Estimated Complexity: Medium - builds on established state management patterns.Goal: Predictive action visualization for player feedback.Components:
GhostSimulator - Lightweight prediction engine
GhostCacheManager - Performance optimization
GhostRenderer - Visual representation system AdaptiveComplexityManager - Performance scaling
Success Criteria: Clear action previews without performance impact.Estimated Complexity: Medium - primarily feature development on stable foundation.GPU Determinism: Cross-platform consistency may require extensive hardware testing.Performance Impact: Time slicing overhead needs careful optimization.Multiplayer Synchronization: Complex integration with existing network protocol.Incremental Development: Implement and validate each component independently.Performance Monitoring: Continuous benchmarking throughout development.Fallback Plans: CPU-based fallbacks for problematic GPU determinism cases.Texture Management: Adapt ping-ponging system for time-sliced execution.Active Regions: Integrate chunk processing with spatial ordering.API Changes: Update Core Engine API for new pipeline integration.Deterministic Processing: Replace existing physics with spatial ordering approach.Time Slice Integration: Adapt physics updates to variable frequency execution.Integer Mathematics: Convert physics calculations to fixed-point arithmetic.Action Scheduling: Replace immediate execution with time-slice scheduling.Mana Management: Implement separate timing system for mana recharge.Queue Management: Add 3-action lookahead system with ghost predictions.Automated Validation: CI/CD integration for determinism regression testing.Cross-Platform Testing: Validation across different GPU architectures.Performance Benchmarking: Continuous monitoring of pipeline overhead.Network Simulation: Test under various latency and packet loss conditions.Prediction Accuracy: Monitor client prediction success rates.Synchronization Validation: Ensure frame-perfect client-server alignment.Documentation: All new components require comprehensive documentation.Testing: Unit tests for deterministic components, integration tests for pipeline.Performance: Benchmark all changes against baseline performance metrics.Architecture Reviews: Major pipeline changes require team architectural review.Implementation Discussion: Technical details should be validated before implementation.Progress Tracking: Regular updates on implementation progress and blockers.
Frame Rate: Maintain 60 FPS with up to 8 players
Determinism: 100% consistency across identical inputs Latency: &lt;50ms total input-to-response latency in multiplayer
Memory: &lt;20% increase in memory usage for state management Cross-Platform: Identical results on all supported GPU architectures
Network Efficiency: &lt;16MB bandwidth per player per minute
User Experience: Smooth ghost predictions for all player actions cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Complete pipeline specification
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/deterministic-execution.html" data-href="deterministic-execution" aria-label="deterministic-execution" data-tooltip-position="top" target="_self">Deterministic Execution</a> - GPU determinism implementation
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Time slice scheduling details
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> - Unified state system architecture
⚠️ NEEDS TEAM VALIDATION:
Implementation timeline and resource allocation
Technical risk tolerance and fallback strategies Performance targets and quality requirements
Integration approach with existing codebase
]]></description><link>architecture/general/implementation-guide.html</link><guid isPermaLink="false">architecture/general/implementation-guide.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[overview]]></title><description><![CDATA[Reaction is a real-time PvP game where players cast spells that place magical runes on a grid. These runes transform the terrain according to rule-based systems.The core technical challenge: simulate thousands of interacting tiles at 60 FPS while allowing complex spell interactions that feel responsive and fair.Performance Goal: High performance with many active tilesDeterminism: Identical inputs produce identical outputs (essential for fair PvP)Responsiveness: Spell casting feels immediate despite complex backend processingExtensibility: New spells and tile interactions can be added without engine rewritesThe system separates concerns into focused, loosely-coupled modules:Purpose: Central coordination and tile data management.Responsibilities:
Bit-packed tile storage across 4 layers (Ground, Object, Air, Rune)
GPU texture management with ping-ponging (enables GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards) for race-condition prevention
Active region optimization (32×32 chunks - chosen to balance GPU workgroup efficiency with memory overhead)
Frame execution pipeline coordination
Dependencies: WebGPU APIPurpose: Player-controlled spellcasting and resource management.Responsibilities:
Mana flower economy and recharge timers
Spell validation and execution
Rune lifecycle management (placement, delay, triggering, combinations)
Deck building and curse system
Player customization options
Dependencies: Core Engine (for rune placement)Processing: Initially chosen for CPU because it handles direct player input. This choice may be revisited during implementation.Purpose: GPU-accelerated tile movement and collision simulation.Responsibilities:
Velocity-based tile movement
Collision detection and response
Force application from runes and environment
Layer interaction physics (falling, bouncing)
Dependencies: Core Engine (texture coordination)Processing: GPU compute shaders with hardcoded physics rulesNote: Frame rate coordination approach proposed in cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">data-flow.md</a> - implementation and effectiveness TBDPurpose: Rule-based environmental transformations.Responsibilities:
JSON rule compilation to optimized GPU shaders
Competitive rule scoring and execution
Environmental pattern matching (fire spreading, etc.)
Optimization pipeline (specific implementation TBD)
Dependencies: Core Engine (texture access), Build toolchainProcessing: GPU compute shaders with compiled rulesNote: The rule compilation pipeline allows simple code generation with sophisticated optimization. Alternative approaches welcome if simpler.Purpose: Visual display and user interface.Responsibilities:
Multi-layer world rendering
UI elements (mana flowers, spell hand)
Visual effects and animations
Camera and viewport management
Dependencies: Core Engine (tile data access)Processing: GPU rendering pipelinePurpose: Development and debugging utilities.Responsibilities:
Visual rule editor with grid-based interface
Debug overlays and tile inspection
Performance profiling and rule tracing
Asset validation and testing tools
Dependencies: All modules (for debugging access)<br>⚠️ PROPOSED ARCHITECTURE: A Deterministic Time-Sliced Execution approach has been proposed for variable timing and multiplayer synchronization. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">data-flow.md</a> for proposed pipeline details - implementation and validation TBD.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/core/tile-storage.html" data-href="tile-storage" aria-label="tile-storage" data-tooltip-position="top" target="_self">tile-storage.md</a> for complete tile format and layer architecture details. Specific bit allocation TBD during implementation.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/performance.html" data-href="performance" aria-label="performance" data-tooltip-position="top" target="_self">performance.md</a> and individual system documentation for specific optimization strategies.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="gameplay/gameplay.html" data-href="gameplay" aria-label="gameplay" data-tooltip-position="top" target="_self">gameplay mechanics</a> for complete gameplay mechanics and customization systems.
Visual Editor: Grid-based rule design interface
JSON Export: Human-readable rule definitions
Compilation: Automatic shader generation and optimization
Testing: Live rule testing and validation
Integration: Hot-reload in development builds Tile Inspector: Real-time tile data examination
Rule Tracer: Understand why specific rules activated
Performance Overlay: Monitor frame timing and bottlenecks
Determinism Validation: Verify identical execution across runs
Tile Types: ~64 per layer (chosen to be comfortably under realistic limits)World Size: Fixed at initialization (no dynamic streaming)Mana Types: 8 maximum (player state buffer constraint)Spell Hand: Size TBD based on UI and gameplay needsPerformance Degradation: Automated benchmarks prevent optimization regressionsRule Complexity: Visual editor prevents impossible shader compilationDeterminism: Strict execution ordering and integer-only mathematicsToolchain Stability: Containerized build environment for consistent results]]></description><link>architecture/general/overview.html</link><guid isPermaLink="false">architecture/general/overview.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[performance]]></title><description><![CDATA[Optimization approaches and technical constraints for tile processing performance.⚠️ NEEDS DISCUSSION: Specific performance targets and constraints have not been established yet.General Goals:
Support many active tiles simultaneously
Performance should scale with activity level rather than world size
Purpose: Avoid processing static regions to maintain performance.Implementation:
Divide world into 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)
Track chunks with active tiles in GPU buffer
Shaders only process listed active chunks
Activity propagates to neighboring chunks automatically
Dormant regions have minimal GPU cost
Benefits:
Automatic scaling with activity level
Efficient memory bandwidth usage
Reduced compute shader dispatches
GPU Cache Optimization: Leverage 2D data access patterns for efficient memory readsBit-Packing: 32-bit tiles maximize cache line utilization
Tile Type (~6 bits): 64 possible types per layer
Velocity (16 bits): Movement vector for physics
Custom Data (10 bits): Health, timers, charges, etc.
Ping-Ponging: Dual texture approach prevents read-after-write hazardsGPU Workgroup Efficiency: 32×32 chunks align with GPU architectureMemory Layout: Textures use r32uint format for optimal GPU cache performanceParallel Processing: Each GPU thread handles one tile for maximum parallelization⚠️ POTENTIAL OPTIMIZATIONS: Additional GPU techniques
Memory Coalescing: Threads in a warp access consecutive memory addresses simultaneously for maximum bandwidth
⚠️ GUIDELINE: Minimize divergent branching
Structure algorithms so threads in the same warp follow similar execution paths
When early exits are necessary, group similar work patterns together to reduce warp divergence
Tile Types: ~64 per layer (chosen to be comfortably under realistic limits)
World Size: Fixed at initialization (no dynamic streaming)
Mana Types: 8 maximum (player state buffer constraint)
Spell Hand: Size TBD based on UI and gameplay needs⚠️ NEEDS DISCUSSION: Specific performance characteristics to be determined through testing
32×32 chunks chosen to balance GPU workgroup efficiency with memory overhead
GPU texture cache considerations
Parallel processing efficiency targets
⚠️ SUGGESTION: Potential optimization techniques for rule compilation:
Compile-time specialization for specific use cases
Dead code elimination for unused rule paths
Constant folding for pre-computed values
Loop unrolling for neighbor checks
Shader Generation: Move complex rule logic to build time
Asset Optimization: Texture and mesh preprocessing
⚠️ NEEDS DESIGN: Specific optimization pipeline implementation⚠️ SUGGESTION: Potential monitoring and validation approaches:
Automated benchmarks to prevent regressions
Frame timing and bottleneck profiling
Determinism validation across runs
⚠️ Major Unsolved Issues:
Frame rate coordination between different systems
GPU thread execution order determinism
Memory bandwidth optimization across modules
⚠️ SUGGESTION: Potential profiling capabilities to develop:
Frame timing monitoring for pipeline stages
GPU utilization tracking
Memory bandwidth analysis
Active region processing visualization
⚠️ SUGGESTION: Potential debugging tools:
Tile inspector for real-time data examination
Rule tracer for activation analysis
Determinism validation tools
]]></description><link>architecture/general/performance.html</link><guid isPermaLink="false">architecture/general/performance.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[deterministic-execution]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed deterministic execution approach for GPU-accelerated physics and reactions. This system solves the fundamental challenge of achieving identical results across different hardware for competitive multiplayer.Core Issue: GPU thread execution order within workgroups is not inherently deterministic.Impact: Non-deterministic collision resolution between tiles
Inconsistent force application results
Different outcomes on different hardware
Breaks competitive multiplayer requirements
Criticality: Essential for fair PvP gameplay and replay capability.Chunk-Level Ordering: Process 32×32 chunks in strict spatial sequence (top-left to bottom-right).Tile-Level Ordering: Within each chunk, process tiles in deterministic spatial order.Player-Level Ordering: Process players in consistent ID-based sequence.// Deterministic tile processing within chunk
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in; void main() { // Map thread to deterministic tile position ivec2 chunkPos = getChunkPosition(); ivec2 localPos = ivec2(gl_LocalInvocationID.xy); ivec2 tilePos = chunkPos * 32 + localPos * 4; // Process 4 tiles per thread in spatial order for (int i = 0; i &lt; 4; i++) { ivec2 currentTile = tilePos + ivec2(i % 2, i / 2); processTileDeterministic(currentTile); }
}
Precision: 16.16 fixed-point format (16 bits integer, 16 bits fractional).Operations: All calculations use integer arithmetic to prevent floating-point drift.Cross-Platform Consistency: Identical results regardless of GPU floating-point implementation.class DeterministicMath { static readonly FIXED_POINT_SCALE = 65536; // 2^16 // Deterministic multiplication static multiply(a: number, b: number): number { return Math.floor((a * b) / this.FIXED_POINT_SCALE); } // Deterministic collision detection static checkCollision(pos1: Point, pos2: Point, radius: number): boolean { const dx = pos1.x - pos2.x; const dy = pos1.y - pos2.y; const distanceSquared = dx * dx + dy * dy; const radiusSquared = radius * radius; return distanceSquared &lt;= radiusSquared; } // Deterministic force resolution static resolveCollision(tile1: TileState, tile2: TileState): CollisionResult { // Use consistent tie-breaking rules const primaryTile = tile1.id &lt; tile2.id ? tile1 : tile2; const secondaryTile = tile1.id &lt; tile2.id ? tile2 : tile1; return this.calculateForces(primaryTile, secondaryTile); }
}
Execution Phases: Use compute barriers to enforce processing order between dependent operations.Memory Barriers: Ensure texture writes complete before subsequent reads.Workgroup Synchronization: Coordinate processing within and between workgroups.Read-Write Separation: Maintain existing texture ping-ponging for race condition prevention.Deterministic Swapping: Ensure texture role swapping occurs at consistent points.State Consistency: Verify texture state consistency across deterministic processing.Replay Tests: Identical input sequences must produce identical outputs.Hardware Variation Testing: Validate consistency across different GPU architectures.Stress Testing: Verify determinism under high load and complex scenarios.class DeterminismValidator { private frameChecksums = new Map&lt;number, string&gt;(); validateFrame(frameNumber: number, gameState: GameState): boolean { const checksum = this.calculateStateChecksum(gameState); const expectedChecksum = this.frameChecksums.get(frameNumber); if (expectedChecksum &amp;&amp; expectedChecksum !== checksum) { console.error(`Determinism failure at frame ${frameNumber}`); return false; } this.frameChecksums.set(frameNumber, checksum); return true; } private calculateStateChecksum(state: GameState): string { // Create deterministic hash of all relevant game state const stateData = this.serializeGameState(state); return this.deterministicHash(stateData); }
}
Determinism-First Design: Consider determinism impact of all changes.Validation Requirements: Test determinism before and after modifications.Code Review Focus: Explicit review of determinism implications.Documentation: Document assumptions about execution order and state dependencies.Overhead Analysis: Spatial ordering adds ~5-10% GPU processing overhead.Optimization Opportunities: Maintain determinism while optimizing memory access patterns.Fallback Strategies: ⚠️ NEEDS DISCUSSION - CPU fallback for determinism-critical operations if GPU determinism proves insufficient.Hardware Differences: Test across NVIDIA, AMD, and Intel GPU architectures.Driver Updates: Establish testing protocol for graphics driver changes.Compatibility Matrix: Maintain supported hardware and driver combinations.Optimization Constraints: Some GPU optimizations may break determinism.Testing Requirements: Extensive validation needed for any physics changes.Quality Assurance: Determinism testing integrated into CI/CD pipeline.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Time slice scheduling integration
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/performance.html" data-href="performance" aria-label="performance" data-tooltip-position="top" target="_self">Performance Strategy</a> - Optimization approaches with determinism constraints
⚠️ NEEDS IMPLEMENTATION: GPU compute shader templates for deterministic processing
Cross-platform validation test suite
Performance benchmarking of spatial ordering overhead
]]></description><link>architecture/general/deterministic-execution.html</link><guid isPermaLink="false">architecture/general/deterministic-execution.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[general]]></title><description><![CDATA[Core architectural concepts, design patterns, and system design documentation for Reaction v2.
<a class="internal-link" data-href="overview.md" href="architecture/general/overview.html" target="_self" rel="noopener nofollow"><strong></strong></a>System Overview - Complete architectural design and module relationships
<br><a class="internal-link" data-href="data-flow.md" href="architecture/general/data-flow.html" target="_self" rel="noopener nofollow"><strong></strong></a>Data Flow - Frame execution pipeline and module communication
<br><a class="internal-link" data-href="performance.md" href="architecture/general/performance.html" target="_self" rel="noopener nofollow"><strong></strong></a>Performance Strategy - Optimization approaches and technical constraints
<br><a class="internal-link" data-href="technical-decisions.md" href="architecture/general/technical-decisions.html" target="_self" rel="noopener nofollow"><strong></strong></a>Technical Decisions - Design choices and rationale <br><a class="internal-link" data-href="implementation-guide.md" href="architecture/general/implementation-guide.html" target="_self" rel="noopener nofollow"><strong></strong></a>Implementation Guide - Step-by-step implementation approach
<br><a class="internal-link" data-href="deterministic-execution.md" href="architecture/general/deterministic-execution.html" target="_self" rel="noopener nofollow"><strong></strong></a>Deterministic Execution - GPU determinism and cross-platform consistency
<br><a class="internal-link" data-href="variable-timing.md" href="architecture/general/variable-timing.html" target="_self" rel="noopener nofollow"><strong></strong></a>Variable Timing System - Time slice scheduling and player action management
<br><a class="internal-link" data-href="state-management.md" href="architecture/general/state-management.html" target="_self" rel="noopener nofollow"><strong></strong></a>State Management - Snapshots, rollback, and multiplayer synchronization
<br><a class="internal-link" data-href="ghost-simulation.md" href="architecture/general/ghost-simulation.html" target="_self" rel="noopener nofollow"><strong></strong></a>Ghost Simulation - Predictive action visualization system
Modular Design: Modules with focused responsibilitiesWebGPU Processing: Physics, reactions, and rendering use GPU computeDeterministic Requirements: Identical inputs must produce identical outputs for PvPActive Region System: Process only chunks with changing tiles⚠️ Unsolved Issues Requiring Design Work:
Frame rate coordination between physics, reactions, and rendering systems
GPU thread execution determinism guarantees
Specific rule compilation pipeline implementation
]]></description><link>architecture/general/general.html</link><guid isPermaLink="false">architecture/general/general.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[ghost-simulation]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed predictive action visualization system that shows players their queued actions and their likely outcomes without affecting the main game simulation.Action Preview: Show visual representation of 3 queued player actions.Spell Effect Prediction: Display where runes will be placed and their likely effects.Movement Prediction: Show future player positions based on queued movement.Performance Constraint: Ghost simulation must not impact main game performance.Simplified Rules: Use fast approximations instead of full physics/reaction simulation.Position-Only Physics: Predict movement without complex collision interactions.Basic Spell Effects: Show rune placement without full environmental predictions.Selective Simulation: Only simulate aspects visible to players.interface GhostPrediction { actionIndex: number; // Which queued action (0, 1, 2) playerPosition: Position; // Predicted player position spellEffects: RunePlacement[]; // Predicted rune placements confidence: number; // Prediction confidence (0-1) timestamp: number; // When prediction was generated
} class GhostSimulator { private predictionCache = new Map&lt;string, GhostPrediction[]&gt;(); private simulationComplexity: 'minimal' | 'basic' | 'detailed' = 'basic'; updatePlayerGhosts(playerId: string): GhostPrediction[] { const cacheKey = this.generateCacheKey(playerId); // Check cache validity if (this.isCacheValid(cacheKey)) { return this.predictionCache.get(cacheKey); } // Generate new predictions const predictions = this.simulatePlayerActions(playerId); this.predictionCache.set(cacheKey, predictions); return predictions; }
}
Minimal: Position-only prediction with no interaction simulation.
Movement vectors applied directly
Spell targeting shown without environmental effects
Fastest performance, lowest accuracy
Basic: Position + simple spell effects prediction.
Basic collision detection for movement
Rune placement validation
Simple environmental effects (obvious barriers, holes)
Balanced performance and accuracy
Detailed: Full simulation using simplified rules.
Complete physics simulation with reduced precision
Environmental rule evaluation with fast heuristics
Complex spell interactions predicted
Higher accuracy, potential performance impact
class MovementPredictor { predictMovement(player: PlayerState, action: MovementAction): Position { let currentPos = player.position; const moveVector = this.calculateMoveVector(action); // Simple collision detection for ghost prediction const targetPos = { x: currentPos.x + moveVector.x, y: currentPos.y + moveVector.y }; // Check for obvious barriers if (this.isPositionBlocked(targetPos)) { return currentPos; // No movement if blocked } return targetPos; } private isPositionBlocked(position: Position): boolean { // Simplified collision detection for performance const tile = this.getTileAt(position); return tile?.type === TileType.SOLID || tile?.type === TileType.WALL; }
}
class SpellEffectPredictor { predictSpellCast(player: PlayerState, spell: SpellAction): RunePlacement[] { const placements: RunePlacement[] = []; // Validate mana requirements if (!this.hasRequiredMana(player, spell)) { return []; // No effect if insufficient mana } // Calculate rune placements const pattern = this.getSpellPattern(spell.spellId); const targetPos = spell.targetPosition; for (const offset of pattern.runeOffsets) { const runePos = { x: targetPos.x + offset.x, y: targetPos.y + offset.y }; // Basic placement validation if (this.canPlaceRune(runePos)) { placements.push({ position: runePos, runeType: pattern.runeType, delay: pattern.delay, confidence: this.calculatePlacementConfidence(runePos) }); } } return placements; }
}
Cache Keys: Based on player state hash and action queue hash.Invalidation: Cache invalidated when player state or world state changes significantly.Selective Updates: Only update ghosts for players whose state changed.class GhostCacheManager { private readonly CACHE_DURATION = 100; // ms generateCacheKey(playerId: string): string { const player = this.getPlayer(playerId); const actionQueueHash = this.hashActionQueue(player.actionQueue); const playerStateHash = this.hashPlayerState(player); const worldStateHash = this.getRelevantWorldStateHash(player.position); return `${playerId}-${actionQueueHash}-${playerStateHash}-${worldStateHash}`; } isCacheValid(cacheKey: string): boolean { const cached = this.predictionCache.get(cacheKey); if (!cached) return false; const age = performance.now() - cached.timestamp; return age &lt; this.CACHE_DURATION; } invalidatePlayerCache(playerId: string): void { // Remove all cache entries for this player for (const [key, _] of this.predictionCache) { if (key.startsWith(playerId)) { this.predictionCache.delete(key); } } }
}
Performance Monitoring: Adjust simulation complexity based on frame rate.Player Count Scaling: Reduce complexity when many players are active.Network Condition Adaptation: Simplify predictions on slow connections.class AdaptiveGhostManager { private performanceMonitor = new PerformanceMonitor(); updateSimulationComplexity(): void { const currentFPS = this.performanceMonitor.getCurrentFPS(); const playerCount = this.getActivePlayerCount(); if (currentFPS &lt; 55 || playerCount &gt; 6) { this.ghostSimulator.setComplexity('minimal'); } else if (currentFPS &lt; 58 || playerCount &gt; 4) { this.ghostSimulator.setComplexity('basic'); } else { this.ghostSimulator.setComplexity('detailed'); } }
}
Player Ghosts: Translucent player sprites at predicted positions.Action Indicators: Visual cues showing queued action types.Spell Previews: Targeting lines and rune placement previews.Confidence Visualization: Alpha/color coding based on prediction confidence.interface GhostVisual { playerId: string; actionIndex: number; position: Position; alpha: number; // Transparency based on confidence actionIndicator: ActionType; spellPreview?: SpellPreview;
} class GhostRenderer { renderPlayerGhosts(predictions: GhostPrediction[]): void { for (let i = 0; i &lt; predictions.length; i++) { const prediction = predictions[i]; const alpha = this.calculateAlpha(prediction.confidence, i); this.renderGhostPlayer({ playerId: prediction.playerId, actionIndex: i, position: prediction.playerPosition, alpha: alpha, actionIndicator: prediction.actionType, spellPreview: prediction.spellEffects }); } } private calculateAlpha(confidence: number, actionIndex: number): number { // Closer actions are more opaque, further actions more transparent const timeAlpha = 1.0 - (actionIndex * 0.2); const confidenceAlpha = 0.3 + (confidence * 0.7); return timeAlpha * confidenceAlpha; }
}
Prediction Timing: Account for variable action timing in predictions.Speed Effect Integration: Update predictions when player speed changes.Action Queue Synchronization: Maintain predictions synchronized with action queue.class GhostTimingIntegration { updateGhostTimingForSpeedChange(playerId: string, newSpeedMultiplier: number): void { // Recalculate prediction timing based on new speed const predictions = this.ghostSimulator.getPlayerPredictions(playerId); for (const prediction of predictions) { const newTiming = this.recalculateActionTiming( prediction.actionIndex, newSpeedMultiplier ); prediction.expectedExecutionSlice = newTiming; } // Invalidate cache to force regeneration this.ghostCacheManager.invalidatePlayerCache(playerId); } private recalculateActionTiming(actionIndex: number, speedMultiplier: number): number { const baseInterval = 8; // 8 time slices per action at normal speed const adjustedInterval = Math.ceil(baseInterval / speedMultiplier); return this.currentSlice + (adjustedInterval * (actionIndex + 1)); }
}
Invalid Actions: Show warning indicators for actions that can't be executed.Resource Conflicts: Display mana insufficiency or other blocking conditions.Simulation Errors: Graceful degradation to simpler prediction methods.class GhostErrorHandler { handlePredictionError(playerId: string, error: PredictionError): GhostPrediction { console.warn(`Ghost prediction error for ${playerId}:`, error); switch (error.type) { case 'insufficient-mana': return this.createManaWarningGhost(playerId, error.actionIndex); case 'invalid-target': return this.createTargetWarningGhost(playerId, error.actionIndex); case 'simulation-timeout': return this.fallbackToPositionOnlyPrediction(playerId, error.actionIndex); default: return this.createErrorGhost(playerId, error.actionIndex); } }
}
Accuracy Metrics: Track how often predictions match actual outcomes.Performance Benchmarks: Monitor ghost simulation performance impact.User Experience Testing: Validate that ghost feedback improves gameplay.Action Queue Edge Cases: Test ghost behavior with rapidly changing queues.Speed Effect Interactions: Verify ghost timing updates with status effects.Network Lag Simulation: Test ghost behavior under various network conditions.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Integration with action scheduling
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/rendering/rendering.html" data-href="rendering" aria-label="rendering" data-tooltip-position="top" target="_self">Renderer System</a> - Visual rendering integration
⚠️ NEEDS TEAM DISCUSSION:
Default simulation complexity level (minimal/basic/detailed)
Ghost prediction accuracy vs performance trade-offs
Visual design for ghost representation (transparency, colors, indicators)
⚠️ NEEDS IMPLEMENTATION:
Performance benchmarking of different complexity levels
User experience testing of ghost feedback effectiveness
Integration testing with action queue and timing systems
]]></description><link>architecture/general/ghost-simulation.html</link><guid isPermaLink="false">architecture/general/ghost-simulation.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[data-flow]]></title><description><![CDATA[⚠️ OUTDATED DOCUMENT: This document describes a previously proposed Deterministic Time-Sliced Execution pipeline. The physics system has been updated and this document no longer reflects the current architectural direction. This document will be rebuilt to match the current physics system approach.The new pipeline subdivides each 60 FPS frame into 8 time slices, enabling variable player action timing while maintaining perfect determinism for multiplayer.
Frame Duration: 16.67ms (60 FPS)
Time Slices: 8 slices per frame (2.08ms each)
Variable Timing: Different systems execute at different slice intervals
Deterministic Order: All processing uses strict spatial/temporal ordering
Each frame processes 8 time slices in deterministic order:
Scheduled Action Processing: Execute player actions based on individual timing
Mana Recharge Processing: Fixed 3-action interval regardless of player speed
Physics Processing: Every slice for 60 FPS smooth motion
Reaction Processing: Less frequent, deterministic intervals
Ghost Prediction Updates: Maintain 3-action lookahead for all players State Snapshot: Save complete game state for rollback/networking
Network Delta Generation: Create compressed updates for multiplayer
Validation: Verify deterministic execution consistency Base Interval: 8 time slices (normal speed)
Speed Multipliers: Status effects modify timing (0.5x = slowed, 2x = hasted)
Immediate Application: Speed changes affect next scheduled action
Deterministic Order: Players processed by ID for consistent results Fixed Schedule: 24 time slices (3 base actions) regardless of player speed
Strategic Consistency: Mana timing remains constant tactical element
Independent Processing: Separate from player action timing 3-Action Lookahead: Players maintain queue of upcoming actions
Ghost Predictions: Visual preview of queued actions
Queue Validation: Invalid actions automatically replaced Spatial Ordering: Process tiles in strict top-left to bottom-right order
Chunk Processing: Handle 32×32 chunks in deterministic sequence
Integer Mathematics: Fixed-point arithmetic prevents floating-point drift
Synchronization Barriers: GPU compute barriers ensure execution order Deterministic Math Library: Custom integer-only calculations
Hardware Independence: Identical results across GPU architectures
Validation Testing: Automated cross-platform determinism verification Single Pipeline: Same engine for single-player and multiplayer modes
State Snapshots: Automatic frame-based state saving
Rollback Capability: Support for multiplayer prediction correction
Network Synchronization: Frame-based state delta compression Client Prediction: Local state prediction with server validation
Rollback Recovery: Automatic correction on server mismatch
Network Protocol: Frame-synchronized state updates
Ghost Simulation: Predictive action visualization Selective Processing: Only active systems process each slice
GPU Batching: Maintain efficient compute shader dispatches
Memory Coherence: Optimize texture access patterns
Chunk Activation: Process only regions with activity Adaptive Frequencies: Reduce reaction frequency under load
Prediction Caching: Cache ghost simulations for performance
Network Efficiency: Delta compression minimizes bandwidth
State Cleanup: Automatic old state garbage collection cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/deterministic-execution.html" data-href="deterministic-execution" aria-label="deterministic-execution" data-tooltip-position="top" target="_self">Deterministic Execution</a> - GPU determinism and cross-platform consistency
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Time slice scheduling and player action management
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> - Snapshots, rollback, and multiplayer synchronization
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/ghost-simulation.html" data-href="ghost-simulation" aria-label="ghost-simulation" data-tooltip-position="top" target="_self">Ghost Simulation</a> - Predictive action visualization system
⚠️ NEEDS TEAM DISCUSSION: Optimal time slice count (8 vs 4 vs 16)
Performance impact of deterministic GPU ordering
Ghost simulation complexity vs performance trade-offs
]]></description><link>architecture/general/data-flow.html</link><guid isPermaLink="false">architecture/general/data-flow.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[architecture]]></title><description><![CDATA[High-level system design, technical decisions, and performance considerations for Reaction v2.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/overview.html" data-href="overview" aria-label="overview" data-tooltip-position="top" target="_self">System Overview</a> - Complete architectural design and module relationships
<br><a class="internal-link" data-href="general/general.md" href="architecture/general/general.html" target="_self" rel="noopener nofollow"><strong></strong></a>General Architecture - Core architectural concepts and design patterns <br><a class="internal-link" data-href="systems/systems.md" href="architecture/systems/systems.html" target="_self" rel="noopener nofollow"><strong></strong></a>Systems - Individual system modules and implementations
Modular Design: Modules with focused responsibilitiesWebGPU Processing: Physics, reactions, and rendering use GPU computeDeterministic Requirements: Identical inputs must produce identical outputs for PvPActive Region System: Process only chunks with changing tiles⚠️ Unsolved Issues Requiring Design Work:
Frame rate coordination between physics, reactions, and rendering systems
GPU thread execution determinism guarantees
Specific rule compilation pipeline implementation Tile Storage: 4 layers (Ground, Object, Air, Rune) with bit-packed 32-bit tiles
Chunk Size: 32×32 tiles (balances GPU workgroup efficiency with memory overhead)
Processing Order: Input → Physics → Runes → Reactions → Render
Communication: Core Engine coordinates data flow between modules
]]></description><link>architecture/architecture.html</link><guid isPermaLink="false">architecture/architecture.md</guid><pubDate>Wed, 24 Sep 2025 03:50:46 GMT</pubDate></item><item><title><![CDATA[docs]]></title><description><![CDATA[Status: 🚧 Stub - This index file needs completionComplete documentation for the Reaction v2 real-time PvP grid-based spellcasting game engine.
<a class="internal-link" data-href="architecture/architecture.md" href="architecture/architecture.html" target="_self" rel="noopener nofollow"><strong></strong></a>Architecture - System design and technical approach
<br><a class="internal-link" data-href="development/development.md" href="development/development.html" target="_self" rel="noopener nofollow"><strong></strong></a>Development - Setup, workflow, and development processes <br><a class="internal-link" data-href="gameplay/gameplay.md" href="gameplay/gameplay.html" target="_self" rel="noopener nofollow"><strong></strong></a>Gameplay - Core game mechanics and design philosophy <br><a class="internal-link" data-href="legacy/legacy.md" href="legacy/legacy.html" target="_self" rel="noopener nofollow"><strong></strong></a>Legacy V1 Analysis - V1 system concepts for V2 development reference
TODO: Add quick start section with:
Project setup instructions
First build steps
Development environment configuration
TODO: Add project overview with:
Game concept summary
Technical architecture highlights
Development status and roadmap
🚧 This file is a stub and needs completion]]></description><link>docs.html</link><guid isPermaLink="false">docs.md</guid><pubDate>Wed, 24 Sep 2025 03:49:58 GMT</pubDate></item></channel></rss>