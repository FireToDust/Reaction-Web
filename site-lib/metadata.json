{"createdTime":1760381438065,"shownInTree":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/overview.html","architecture/general/performance.html","architecture/general/state-management.html","architecture/general/technical-decisions.html","architecture/general/variable-timing.html","architecture/systems/config/config.html","architecture/systems/core/active-regions.html","architecture/systems/core/api-reference.html","architecture/systems/core/core.html","architecture/systems/core/texture-management.html","architecture/systems/core/tile-storage.html","architecture/systems/gpu/gpu.html","architecture/systems/multiplayer/client-prediction.html","architecture/systems/multiplayer/deployment.html","architecture/systems/multiplayer/multiplayer.html","architecture/systems/multiplayer/network-protocol.html","architecture/systems/multiplayer/performance.html","architecture/systems/multiplayer/security.html","architecture/systems/multiplayer/server-architecture.html","architecture/systems/physics/determinism.html","architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.html","architecture/systems/reactions/reactions.html","architecture/systems/reactions/rule-compilation.html","architecture/systems/rendering/rendering.html","architecture/systems/spells/cpu-architecture.html","architecture/systems/spells/customization.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/tools/tools.html","architecture/systems/ui/ui.html","architecture/systems/systems.html","architecture/architecture.html","development/building-documentation.html","development/development.html","development/development_principles.html","development/documentation_structure.html","development/getting-started.html","development/tasklist.html","gameplay/core-mechanics.html","gameplay/gameplay.html","legacy/legacy.html","legacy/v1-data-strategies.html","legacy/v1-environmental-examples.html","legacy/v1-gpu-patterns.html","legacy/v1-reference.html","legacy/v1-visual-effects.html","docs.html","index.html"],"attachments":["site-lib/scripts/graph-wasm.wasm","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/main-styles.css","site-lib/rss.xml"],"allFiles":["legacy/v1-visual-effects.html","legacy/v1-gpu-patterns.html","legacy/v1-reference.html","legacy/legacy.html","legacy/v1-data-strategies.html","legacy/v1-environmental-examples.html","gameplay/gameplay.html","index.html","gameplay/core-mechanics.html","docs.html","development/getting-started.html","development/tasklist.html","development/building-documentation.html","development/development.html","development/documentation_structure.html","architecture/systems/ui/ui.html","development/development_principles.html","architecture/systems/tools/tools.html","architecture/systems/systems.html","architecture/systems/spells/spells.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/customization.html","architecture/systems/spells/mana-system.html","architecture/systems/rendering/rendering.html","architecture/systems/spells/cpu-architecture.html","architecture/systems/reactions/reactions.html","architecture/systems/reactions/rule-compilation.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.html","architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/multiplayer/server-architecture.html","architecture/systems/physics/determinism.html","architecture/systems/multiplayer/security.html","architecture/systems/multiplayer/performance.html","architecture/systems/multiplayer/multiplayer.html","architecture/systems/multiplayer/network-protocol.html","architecture/systems/multiplayer/client-prediction.html","architecture/systems/multiplayer/deployment.html","architecture/systems/core/texture-management.html","architecture/systems/core/tile-storage.html","architecture/systems/gpu/gpu.html","architecture/systems/core/api-reference.html","architecture/systems/core/core.html","architecture/systems/config/config.html","architecture/systems/core/active-regions.html","architecture/general/technical-decisions.html","architecture/general/variable-timing.html","architecture/general/performance.html","architecture/general/state-management.html","architecture/general/implementation-guide.html","architecture/general/overview.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/architecture.html","site-lib/scripts/graph-wasm.wasm","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/main-styles.css"],"webpages":{"architecture/general/data-flow.html":{"title":"data-flow","icon":"","description":"⚠️ OUTDATED DOCUMENT: This document describes a previously proposed Deterministic Time-Sliced Execution pipeline. The physics system has been updated and this document no longer reflects the current architectural direction. This document will be rebuilt to match the current physics system approach.The new pipeline subdivides each 60 FPS frame into 8 time slices, enabling variable player action timing while maintaining perfect determinism for multiplayer.\nFrame Duration: 16.67ms (60 FPS)\nTime Slices: 8 slices per frame (2.08ms each)\nVariable Timing: Different systems execute at different slice intervals\nDeterministic Order: All processing uses strict spatial/temporal ordering\nEach frame processes 8 time slices in deterministic order:\nScheduled Action Processing: Execute player actions based on individual timing\nMana Recharge Processing: Fixed 3-action interval regardless of player speed\nPhysics Processing: Every slice for 60 FPS smooth motion\nReaction Processing: Less frequent, deterministic intervals\nGhost Prediction Updates: Maintain 3-action lookahead for all players State Snapshot: Save complete game state for rollback/networking\nNetwork Delta Generation: Create compressed updates for multiplayer\nValidation: Verify deterministic execution consistency Base Interval: 8 time slices (normal speed)\nSpeed Multipliers: Status effects modify timing (0.5x = slowed, 2x = hasted)\nImmediate Application: Speed changes affect next scheduled action\nDeterministic Order: Players processed by ID for consistent results Fixed Schedule: 24 time slices (3 base actions) regardless of player speed\nStrategic Consistency: Mana timing remains constant tactical element\nIndependent Processing: Separate from player action timing 3-Action Lookahead: Players maintain queue of upcoming actions\nGhost Predictions: Visual preview of queued actions\nQueue Validation: Invalid actions automatically replaced Spatial Ordering: Process tiles in strict top-left to bottom-right order\nChunk Processing: Handle 32×32 chunks in deterministic sequence\nInteger Mathematics: Fixed-point arithmetic prevents floating-point drift\nSynchronization Barriers: GPU compute barriers ensure execution order Deterministic Math Library: Custom integer-only calculations\nHardware Independence: Identical results across GPU architectures\nValidation Testing: Automated cross-platform determinism verification Single Pipeline: Same engine for single-player and multiplayer modes\nState Snapshots: Automatic frame-based state saving\nRollback Capability: Support for multiplayer prediction correction\nNetwork Synchronization: Frame-based state delta compression Client Prediction: Local state prediction with server validation\nRollback Recovery: Automatic correction on server mismatch\nNetwork Protocol: Frame-synchronized state updates\nGhost Simulation: Predictive action visualization Selective Processing: Only active systems process each slice\nGPU Batching: Maintain efficient compute shader dispatches\nMemory Coherence: Optimize texture access patterns\nChunk Activation: Process only regions with activity Adaptive Frequencies: Reduce reaction frequency under load\nPrediction Caching: Cache ghost simulations for performance\nNetwork Efficiency: Delta compression minimizes bandwidth\nState Cleanup: Automatic old state garbage collection cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/deterministic-execution.html\" data-href=\"deterministic-execution\" aria-label=\"deterministic-execution\" data-tooltip-position=\"top\" target=\"_self\">Deterministic Execution</a> - GPU determinism and cross-platform consistency\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Time slice scheduling and player action management\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/state-management.html\" data-href=\"state-management\" aria-label=\"state-management\" data-tooltip-position=\"top\" target=\"_self\">State Management</a> - Snapshots, rollback, and multiplayer synchronization\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/ghost-simulation.html\" data-href=\"ghost-simulation\" aria-label=\"ghost-simulation\" data-tooltip-position=\"top\" target=\"_self\">Ghost Simulation</a> - Predictive action visualization system\n⚠️ NEEDS TEAM DISCUSSION: Optimal time slice count (8 vs 4 vs 16)\nPerformance impact of deterministic GPU ordering\nGhost simulation complexity vs performance trade-offs\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Data Flow Architecture","level":1,"id":"Data_Flow_Architecture_0"},{"heading":"Pipeline Overview: Deterministic Time-Sliced Execution","level":2,"id":"Pipeline_Overview_Deterministic_Time-Sliced_Execution_0"},{"heading":"Key Innovation","level":3,"id":"Key_Innovation_0"},{"heading":"Frame Execution Pipeline","level":2,"id":"Frame_Execution_Pipeline_0"},{"heading":"Time Slice Processing (Repeated 8x per frame)","level":3,"id":"Time_Slice_Processing_(Repeated_8x_per_frame)_0"},{"heading":"Frame Completion","level":3,"id":"Frame_Completion_0"},{"heading":"Variable Timing System","level":2,"id":"Variable_Timing_System_0"},{"heading":"Player Action Scheduling","level":3,"id":"Player_Action_Scheduling_0"},{"heading":"Mana Recharge Timing","level":3,"id":"Mana_Recharge_Timing_0"},{"heading":"Action Queue Management","level":3,"id":"Action_Queue_Management_0"},{"heading":"Deterministic Execution Framework","level":2,"id":"Deterministic_Execution_Framework_0"},{"heading":"GPU Determinism Strategy","level":3,"id":"GPU_Determinism_Strategy_0"},{"heading":"Cross-Platform Consistency","level":3,"id":"Cross-Platform_Consistency_0"},{"heading":"State Management Integration","level":2,"id":"State_Management_Integration_0"},{"heading":"Unified State System","level":3,"id":"Unified_State_System_0"},{"heading":"Multiplayer Integration","level":3,"id":"Multiplayer_Integration_0"},{"heading":"Performance Optimizations","level":2,"id":"Performance_Optimizations_0"},{"heading":"Time Slice Efficiency","level":3,"id":"Time_Slice_Efficiency_0"},{"heading":"Scalability Considerations","level":3,"id":"Scalability_Considerations_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Detailed Implementation","level":3,"id":"Detailed_Implementation_0"}],"links":["architecture/general/deterministic-execution.html","architecture/general/variable-timing.html","architecture/general/state-management.html","architecture/general/ghost-simulation.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/data-flow.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506316,"modifiedTime":1760380506317,"sourceSize":5271,"sourcePath":"architecture/general/data-flow.md","exportPath":"architecture/general/data-flow.html","showInTree":true,"treeOrder":2,"backlinks":["architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/general/overview.html"],"type":"markdown"},"architecture/general/deterministic-execution.html":{"title":"deterministic-execution","icon":"","description":"⚠️ PROPOSED SYSTEM: This document describes the proposed deterministic execution approach for GPU-accelerated physics and reactions. This system solves the fundamental challenge of achieving identical results across different hardware for competitive multiplayer.Core Issue: GPU thread execution order within workgroups is not inherently deterministic.Impact: Non-deterministic collision resolution between tiles\nInconsistent force application results\nDifferent outcomes on different hardware\nBreaks competitive multiplayer requirements\nCriticality: Essential for fair PvP gameplay and replay capability.Chunk-Level Ordering: Process 32×32 chunks in strict spatial sequence (top-left to bottom-right).Tile-Level Ordering: Within each chunk, process tiles in deterministic spatial order.Player-Level Ordering: Process players in consistent ID-based sequence.// Deterministic tile processing within chunk\nlayout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in; void main() { // Map thread to deterministic tile position ivec2 chunkPos = getChunkPosition(); ivec2 localPos = ivec2(gl_LocalInvocationID.xy); ivec2 tilePos = chunkPos * 32 + localPos * 4; // Process 4 tiles per thread in spatial order for (int i = 0; i &lt; 4; i++) { ivec2 currentTile = tilePos + ivec2(i % 2, i / 2); processTileDeterministic(currentTile); }\n}\nPrecision: 16.16 fixed-point format (16 bits integer, 16 bits fractional).Operations: All calculations use integer arithmetic to prevent floating-point drift.Cross-Platform Consistency: Identical results regardless of GPU floating-point implementation.class DeterministicMath { static readonly FIXED_POINT_SCALE = 65536; // 2^16 // Deterministic multiplication static multiply(a: number, b: number): number { return Math.floor((a * b) / this.FIXED_POINT_SCALE); } // Deterministic collision detection static checkCollision(pos1: Point, pos2: Point, radius: number): boolean { const dx = pos1.x - pos2.x; const dy = pos1.y - pos2.y; const distanceSquared = dx * dx + dy * dy; const radiusSquared = radius * radius; return distanceSquared &lt;= radiusSquared; } // Deterministic force resolution static resolveCollision(tile1: TileState, tile2: TileState): CollisionResult { // Use consistent tie-breaking rules const primaryTile = tile1.id &lt; tile2.id ? tile1 : tile2; const secondaryTile = tile1.id &lt; tile2.id ? tile2 : tile1; return this.calculateForces(primaryTile, secondaryTile); }\n}\nExecution Phases: Use compute barriers to enforce processing order between dependent operations.Memory Barriers: Ensure texture writes complete before subsequent reads.Workgroup Synchronization: Coordinate processing within and between workgroups.Read-Write Separation: Maintain existing texture ping-ponging for race condition prevention.Deterministic Swapping: Ensure texture role swapping occurs at consistent points.State Consistency: Verify texture state consistency across deterministic processing.Replay Tests: Identical input sequences must produce identical outputs.Hardware Variation Testing: Validate consistency across different GPU architectures.Stress Testing: Verify determinism under high load and complex scenarios.class DeterminismValidator { private frameChecksums = new Map&lt;number, string&gt;(); validateFrame(frameNumber: number, gameState: GameState): boolean { const checksum = this.calculateStateChecksum(gameState); const expectedChecksum = this.frameChecksums.get(frameNumber); if (expectedChecksum &amp;&amp; expectedChecksum !== checksum) { console.error(`Determinism failure at frame ${frameNumber}`); return false; } this.frameChecksums.set(frameNumber, checksum); return true; } private calculateStateChecksum(state: GameState): string { // Create deterministic hash of all relevant game state const stateData = this.serializeGameState(state); return this.deterministicHash(stateData); }\n}\nDeterminism-First Design: Consider determinism impact of all changes.Validation Requirements: Test determinism before and after modifications.Code Review Focus: Explicit review of determinism implications.Documentation: Document assumptions about execution order and state dependencies.Overhead Analysis: Spatial ordering adds ~5-10% GPU processing overhead.Optimization Opportunities: Maintain determinism while optimizing memory access patterns.Fallback Strategies: ⚠️ NEEDS DISCUSSION - CPU fallback for determinism-critical operations if GPU determinism proves insufficient.Hardware Differences: Test across NVIDIA, AMD, and Intel GPU architectures.Driver Updates: Establish testing protocol for graphics driver changes.Compatibility Matrix: Maintain supported hardware and driver combinations.Optimization Constraints: Some GPU optimizations may break determinism.Testing Requirements: Extensive validation needed for any physics changes.Quality Assurance: Determinism testing integrated into CI/CD pipeline.\ncross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Parent pipeline architecture\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Time slice scheduling integration\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/performance.html\" data-href=\"performance\" aria-label=\"performance\" data-tooltip-position=\"top\" target=\"_self\">Performance Strategy</a> - Optimization approaches with determinism constraints\n⚠️ NEEDS IMPLEMENTATION: GPU compute shader templates for deterministic processing\nCross-platform validation test suite\nPerformance benchmarking of spatial ordering overhead\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Deterministic Execution Framework","level":1,"id":"Deterministic_Execution_Framework_0"},{"heading":"Problem Statement","level":2,"id":"Problem_Statement_0"},{"heading":"GPU Non-Determinism Challenge","level":3,"id":"GPU_Non-Determinism_Challenge_0"},{"heading":"Solution: Spatial Ordering Strategy","level":2,"id":"Solution_Spatial_Ordering_Strategy_0"},{"heading":"Deterministic Processing Order","level":3,"id":"Deterministic_Processing_Order_0"},{"heading":"GPU Compute Implementation","level":3,"id":"GPU_Compute_Implementation_0"},{"heading":"Integer-Only Mathematics","level":2,"id":"Integer-Only_Mathematics_0"},{"heading":"Fixed-Point Arithmetic System","level":3,"id":"Fixed-Point_Arithmetic_System_0"},{"heading":"Deterministic Math Library","level":3,"id":"Deterministic_Math_Library_0"},{"heading":"Synchronization Strategy","level":2,"id":"Synchronization_Strategy_0"},{"heading":"GPU Compute Barriers","level":3,"id":"GPU_Compute_Barriers_0"},{"heading":"Texture Ping-Ponging Integration","level":3,"id":"Texture_Ping-Ponging_Integration_0"},{"heading":"Cross-Platform Validation","level":2,"id":"Cross-Platform_Validation_0"},{"heading":"Automated Testing Framework","level":3,"id":"Automated_Testing_Framework_0"},{"heading":"Validation Checkpoints","level":3,"id":"Validation_Checkpoints_0"},{"heading":"Implementation Guidelines","level":2,"id":"Implementation_Guidelines_0"},{"heading":"Development Practices","level":3,"id":"Development_Practices_0"},{"heading":"Performance Considerations","level":3,"id":"Performance_Considerations_0"},{"heading":"Risk Mitigation","level":2,"id":"Risk_Mitigation_0"},{"heading":"GPU Driver Variations","level":3,"id":"GPU_Driver_Variations_0"},{"heading":"Performance vs Determinism Trade-offs","level":3,"id":"Performance_vs_Determinism_Trade-offs_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/variable-timing.html","architecture/general/performance.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/deterministic-execution.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506317,"modifiedTime":1760380506317,"sourceSize":6596,"sourcePath":"architecture/general/deterministic-execution.md","exportPath":"architecture/general/deterministic-execution.html","showInTree":true,"treeOrder":3,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html","architecture/general/implementation-guide.html","architecture/general/variable-timing.html"],"type":"markdown"},"architecture/general/general.html":{"title":"general","icon":"","description":"Core architectural concepts, design patterns, and system design documentation for Reaction v2.\n<a class=\"internal-link\" data-href=\"overview.md\" href=\"architecture/general/overview.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>System Overview - Complete architectural design and module relationships\n<br><a class=\"internal-link\" data-href=\"data-flow.md\" href=\"architecture/general/data-flow.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Data Flow - Frame execution pipeline and module communication\n<br><a class=\"internal-link\" data-href=\"performance.md\" href=\"architecture/general/performance.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Performance Strategy - Optimization approaches and technical constraints\n<br><a class=\"internal-link\" data-href=\"technical-decisions.md\" href=\"architecture/general/technical-decisions.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Technical Decisions - Design choices and rationale <br><a class=\"internal-link\" data-href=\"implementation-guide.md\" href=\"architecture/general/implementation-guide.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Implementation Guide - Step-by-step implementation approach\n<br><a class=\"internal-link\" data-href=\"deterministic-execution.md\" href=\"architecture/general/deterministic-execution.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Deterministic Execution - GPU determinism and cross-platform consistency\n<br><a class=\"internal-link\" data-href=\"variable-timing.md\" href=\"architecture/general/variable-timing.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Variable Timing System - Time slice scheduling and player action management\n<br><a class=\"internal-link\" data-href=\"state-management.md\" href=\"architecture/general/state-management.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>State Management - Snapshots, rollback, and multiplayer synchronization\n<br><a class=\"internal-link\" data-href=\"ghost-simulation.md\" href=\"architecture/general/ghost-simulation.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Ghost Simulation - Predictive action visualization system\nModular Design: Modules with focused responsibilitiesWebGPU Processing: Physics, reactions, and rendering use GPU computeDeterministic Requirements: Identical inputs must produce identical outputs for PvPActive Region System: Process only chunks with changing tiles⚠️ Unsolved Issues Requiring Design Work:\nFrame rate coordination between physics, reactions, and rendering systems\nGPU thread execution determinism guarantees\nSpecific rule compilation pipeline implementation\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"General Architecture Documentation","level":1,"id":"General_Architecture_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Architecture","level":3,"id":"Core_Architecture_0"},{"heading":"Implementation Guides","level":3,"id":"Implementation_Guides_0"},{"heading":"Architectural Approach","level":2,"id":"Architectural_Approach_0"},{"heading":"Major Technical Challenges","level":2,"id":"Major_Technical_Challenges_0"}],"links":["architecture/general/overview.html","architecture/general/data-flow.html","architecture/general/performance.html","architecture/general/technical-decisions.html","architecture/general/implementation-guide.html","architecture/general/deterministic-execution.html","architecture/general/variable-timing.html","architecture/general/state-management.html","architecture/general/ghost-simulation.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/general.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506318,"modifiedTime":1760380506318,"sourceSize":1651,"sourcePath":"architecture/general/general.md","exportPath":"architecture/general/general.html","showInTree":true,"treeOrder":4,"backlinks":["architecture/architecture.html"],"type":"markdown"},"architecture/general/ghost-simulation.html":{"title":"ghost-simulation","icon":"","description":"⚠️ PROPOSED SYSTEM: This document describes the proposed predictive action visualization system that shows players their queued actions and their likely outcomes without affecting the main game simulation.Action Preview: Show visual representation of 3 queued player actions.Spell Effect Prediction: Display where runes will be placed and their likely effects.Movement Prediction: Show future player positions based on queued movement.Performance Constraint: Ghost simulation must not impact main game performance.Simplified Rules: Use fast approximations instead of full physics/reaction simulation.Position-Only Physics: Predict movement without complex collision interactions.Basic Spell Effects: Show rune placement without full environmental predictions.Selective Simulation: Only simulate aspects visible to players.interface GhostPrediction { actionIndex: number; // Which queued action (0, 1, 2) playerPosition: Position; // Predicted player position spellEffects: RunePlacement[]; // Predicted rune placements confidence: number; // Prediction confidence (0-1) timestamp: number; // When prediction was generated\n} class GhostSimulator { private predictionCache = new Map&lt;string, GhostPrediction[]&gt;(); private simulationComplexity: 'minimal' | 'basic' | 'detailed' = 'basic'; updatePlayerGhosts(playerId: string): GhostPrediction[] { const cacheKey = this.generateCacheKey(playerId); // Check cache validity if (this.isCacheValid(cacheKey)) { return this.predictionCache.get(cacheKey); } // Generate new predictions const predictions = this.simulatePlayerActions(playerId); this.predictionCache.set(cacheKey, predictions); return predictions; }\n}\nMinimal: Position-only prediction with no interaction simulation.\nMovement vectors applied directly\nSpell targeting shown without environmental effects\nFastest performance, lowest accuracy\nBasic: Position + simple spell effects prediction.\nBasic collision detection for movement\nRune placement validation\nSimple environmental effects (obvious barriers, holes)\nBalanced performance and accuracy\nDetailed: Full simulation using simplified rules.\nComplete physics simulation with reduced precision\nEnvironmental rule evaluation with fast heuristics\nComplex spell interactions predicted\nHigher accuracy, potential performance impact\nclass MovementPredictor { predictMovement(player: PlayerState, action: MovementAction): Position { let currentPos = player.position; const moveVector = this.calculateMoveVector(action); // Simple collision detection for ghost prediction const targetPos = { x: currentPos.x + moveVector.x, y: currentPos.y + moveVector.y }; // Check for obvious barriers if (this.isPositionBlocked(targetPos)) { return currentPos; // No movement if blocked } return targetPos; } private isPositionBlocked(position: Position): boolean { // Simplified collision detection for performance const tile = this.getTileAt(position); return tile?.type === TileType.SOLID || tile?.type === TileType.WALL; }\n}\nclass SpellEffectPredictor { predictSpellCast(player: PlayerState, spell: SpellAction): RunePlacement[] { const placements: RunePlacement[] = []; // Validate mana requirements if (!this.hasRequiredMana(player, spell)) { return []; // No effect if insufficient mana } // Calculate rune placements const pattern = this.getSpellPattern(spell.spellId); const targetPos = spell.targetPosition; for (const offset of pattern.runeOffsets) { const runePos = { x: targetPos.x + offset.x, y: targetPos.y + offset.y }; // Basic placement validation if (this.canPlaceRune(runePos)) { placements.push({ position: runePos, runeType: pattern.runeType, delay: pattern.delay, confidence: this.calculatePlacementConfidence(runePos) }); } } return placements; }\n}\nCache Keys: Based on player state hash and action queue hash.Invalidation: Cache invalidated when player state or world state changes significantly.Selective Updates: Only update ghosts for players whose state changed.class GhostCacheManager { private readonly CACHE_DURATION = 100; // ms generateCacheKey(playerId: string): string { const player = this.getPlayer(playerId); const actionQueueHash = this.hashActionQueue(player.actionQueue); const playerStateHash = this.hashPlayerState(player); const worldStateHash = this.getRelevantWorldStateHash(player.position); return `${playerId}-${actionQueueHash}-${playerStateHash}-${worldStateHash}`; } isCacheValid(cacheKey: string): boolean { const cached = this.predictionCache.get(cacheKey); if (!cached) return false; const age = performance.now() - cached.timestamp; return age &lt; this.CACHE_DURATION; } invalidatePlayerCache(playerId: string): void { // Remove all cache entries for this player for (const [key, _] of this.predictionCache) { if (key.startsWith(playerId)) { this.predictionCache.delete(key); } } }\n}\nPerformance Monitoring: Adjust simulation complexity based on frame rate.Player Count Scaling: Reduce complexity when many players are active.Network Condition Adaptation: Simplify predictions on slow connections.class AdaptiveGhostManager { private performanceMonitor = new PerformanceMonitor(); updateSimulationComplexity(): void { const currentFPS = this.performanceMonitor.getCurrentFPS(); const playerCount = this.getActivePlayerCount(); if (currentFPS &lt; 55 || playerCount &gt; 6) { this.ghostSimulator.setComplexity('minimal'); } else if (currentFPS &lt; 58 || playerCount &gt; 4) { this.ghostSimulator.setComplexity('basic'); } else { this.ghostSimulator.setComplexity('detailed'); } }\n}\nPlayer Ghosts: Translucent player sprites at predicted positions.Action Indicators: Visual cues showing queued action types.Spell Previews: Targeting lines and rune placement previews.Confidence Visualization: Alpha/color coding based on prediction confidence.interface GhostVisual { playerId: string; actionIndex: number; position: Position; alpha: number; // Transparency based on confidence actionIndicator: ActionType; spellPreview?: SpellPreview;\n} class GhostRenderer { renderPlayerGhosts(predictions: GhostPrediction[]): void { for (let i = 0; i &lt; predictions.length; i++) { const prediction = predictions[i]; const alpha = this.calculateAlpha(prediction.confidence, i); this.renderGhostPlayer({ playerId: prediction.playerId, actionIndex: i, position: prediction.playerPosition, alpha: alpha, actionIndicator: prediction.actionType, spellPreview: prediction.spellEffects }); } } private calculateAlpha(confidence: number, actionIndex: number): number { // Closer actions are more opaque, further actions more transparent const timeAlpha = 1.0 - (actionIndex * 0.2); const confidenceAlpha = 0.3 + (confidence * 0.7); return timeAlpha * confidenceAlpha; }\n}\nPrediction Timing: Account for variable action timing in predictions.Speed Effect Integration: Update predictions when player speed changes.Action Queue Synchronization: Maintain predictions synchronized with action queue.class GhostTimingIntegration { updateGhostTimingForSpeedChange(playerId: string, newSpeedMultiplier: number): void { // Recalculate prediction timing based on new speed const predictions = this.ghostSimulator.getPlayerPredictions(playerId); for (const prediction of predictions) { const newTiming = this.recalculateActionTiming( prediction.actionIndex, newSpeedMultiplier ); prediction.expectedExecutionSlice = newTiming; } // Invalidate cache to force regeneration this.ghostCacheManager.invalidatePlayerCache(playerId); } private recalculateActionTiming(actionIndex: number, speedMultiplier: number): number { const baseInterval = 8; // 8 time slices per action at normal speed const adjustedInterval = Math.ceil(baseInterval / speedMultiplier); return this.currentSlice + (adjustedInterval * (actionIndex + 1)); }\n}\nInvalid Actions: Show warning indicators for actions that can't be executed.Resource Conflicts: Display mana insufficiency or other blocking conditions.Simulation Errors: Graceful degradation to simpler prediction methods.class GhostErrorHandler { handlePredictionError(playerId: string, error: PredictionError): GhostPrediction { console.warn(`Ghost prediction error for ${playerId}:`, error); switch (error.type) { case 'insufficient-mana': return this.createManaWarningGhost(playerId, error.actionIndex); case 'invalid-target': return this.createTargetWarningGhost(playerId, error.actionIndex); case 'simulation-timeout': return this.fallbackToPositionOnlyPrediction(playerId, error.actionIndex); default: return this.createErrorGhost(playerId, error.actionIndex); } }\n}\nAccuracy Metrics: Track how often predictions match actual outcomes.Performance Benchmarks: Monitor ghost simulation performance impact.User Experience Testing: Validate that ghost feedback improves gameplay.Action Queue Edge Cases: Test ghost behavior with rapidly changing queues.Speed Effect Interactions: Verify ghost timing updates with status effects.Network Lag Simulation: Test ghost behavior under various network conditions.\ncross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Parent pipeline architecture\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Integration with action scheduling\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/rendering/rendering.html\" data-href=\"rendering\" aria-label=\"rendering\" data-tooltip-position=\"top\" target=\"_self\">Renderer System</a> - Visual rendering integration\n⚠️ NEEDS TEAM DISCUSSION:\nDefault simulation complexity level (minimal/basic/detailed)\nGhost prediction accuracy vs performance trade-offs\nVisual design for ghost representation (transparency, colors, indicators)\n⚠️ NEEDS IMPLEMENTATION:\nPerformance benchmarking of different complexity levels\nUser experience testing of ghost feedback effectiveness\nIntegration testing with action queue and timing systems\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Ghost Simulation System","level":1,"id":"Ghost_Simulation_System_0"},{"heading":"Design Goals","level":2,"id":"Design_Goals_0"},{"heading":"Player Feedback Requirements","level":3,"id":"Player_Feedback_Requirements_0"},{"heading":"Ghost Simulation Architecture","level":2,"id":"Ghost_Simulation_Architecture_0"},{"heading":"Lightweight Simulation Strategy","level":3,"id":"Lightweight_Simulation_Strategy_0"},{"heading":"Simulation Complexity Levels","level":3,"id":"Simulation_Complexity_Levels_0"},{"heading":"Prediction Algorithms","level":2,"id":"Prediction_Algorithms_0"},{"heading":"Movement Prediction","level":3,"id":"Movement_Prediction_0"},{"heading":"Spell Effect Prediction","level":3,"id":"Spell_Effect_Prediction_0"},{"heading":"Performance Optimization","level":2,"id":"Performance_Optimization_0"},{"heading":"Caching Strategy","level":3,"id":"Caching_Strategy_0"},{"heading":"Adaptive Complexity","level":3,"id":"Adaptive_Complexity_0"},{"heading":"Visual Representation","level":2,"id":"Visual_Representation_0"},{"heading":"Ghost Rendering","level":3,"id":"Ghost_Rendering_0"},{"heading":"Integration with Timing System","level":2,"id":"Integration_with_Timing_System_0"},{"heading":"Time Slice Synchronization","level":3,"id":"Time_Slice_Synchronization_0"},{"heading":"Error Handling and Fallbacks","level":2,"id":"Error_Handling_and_Fallbacks_0"},{"heading":"Prediction Failures","level":3,"id":"Prediction_Failures_0"},{"heading":"Testing and Validation","level":2,"id":"Testing_and_Validation_0"},{"heading":"Prediction Accuracy","level":3,"id":"Prediction_Accuracy_0"},{"heading":"Edge Case Coverage","level":3,"id":"Edge_Case_Coverage_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/variable-timing.html","architecture/systems/rendering/rendering.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/ghost-simulation.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506318,"modifiedTime":1760380506318,"sourceSize":12880,"sourcePath":"architecture/general/ghost-simulation.md","exportPath":"architecture/general/ghost-simulation.html","showInTree":true,"treeOrder":5,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html"],"type":"markdown"},"architecture/general/implementation-guide.html":{"title":"implementation-guide","icon":"","description":"⚠️ PROPOSED IMPLEMENTATION PLAN: This document outlines the suggested implementation approach for the Deterministic Time-Sliced Execution pipeline. All timelines and priorities should be validated with the team.Goal: Establish deterministic frame processing with time slicing.Components:\nDeterministicTimeSlicedPipeline - Main pipeline class\nTimeSliceScheduler - Variable timing management DeterministicMath - Integer-only math library\nStateSnapshotManager - Frame-based state capture\nSuccess Criteria: 60 FPS deterministic execution with variable player action timing.Estimated Complexity: High - foundational architecture changes required.Goal: Achieve consistent GPU processing across platforms.Components:\nSpatialOrderingStrategy - Deterministic tile processing order\nDeterministicGPUProcessor - GPU compute shader coordination\nFixedPointMath - GPU shader math library\nDeterminismValidator - Cross-platform testing framework\nSuccess Criteria: Identical results across different GPU hardware.Estimated Complexity: Very High - requires low-level GPU programming expertise.Goal: Unified state system for single-player and multiplayer.Components:\nUnifiedGameEngine - Mode-agnostic game engine\nRollbackManager - State restoration and replay\nDeltaCompressor - Network-efficient state compression\nClientPredictionManager - Multiplayer prediction integration\nSuccess Criteria: Seamless transition between single-player and multiplayer modes.Estimated Complexity: Medium - builds on established state management patterns.Goal: Predictive action visualization for player feedback.Components:\nGhostSimulator - Lightweight prediction engine\nGhostCacheManager - Performance optimization\nGhostRenderer - Visual representation system AdaptiveComplexityManager - Performance scaling\nSuccess Criteria: Clear action previews without performance impact.Estimated Complexity: Medium - primarily feature development on stable foundation.GPU Determinism: Cross-platform consistency may require extensive hardware testing.Performance Impact: Time slicing overhead needs careful optimization.Multiplayer Synchronization: Complex integration with existing network protocol.Incremental Development: Implement and validate each component independently.Performance Monitoring: Continuous benchmarking throughout development.Fallback Plans: CPU-based fallbacks for problematic GPU determinism cases.Texture Management: Adapt ping-ponging system for time-sliced execution.Active Regions: Integrate chunk processing with spatial ordering.API Changes: Update Core Engine API for new pipeline integration.Deterministic Processing: Replace existing physics with spatial ordering approach.Time Slice Integration: Adapt physics updates to variable frequency execution.Integer Mathematics: Convert physics calculations to fixed-point arithmetic.Action Scheduling: Replace immediate execution with time-slice scheduling.Mana Management: Implement separate timing system for mana recharge.Queue Management: Add 3-action lookahead system with ghost predictions.Automated Validation: CI/CD integration for determinism regression testing.Cross-Platform Testing: Validation across different GPU architectures.Performance Benchmarking: Continuous monitoring of pipeline overhead.Network Simulation: Test under various latency and packet loss conditions.Prediction Accuracy: Monitor client prediction success rates.Synchronization Validation: Ensure frame-perfect client-server alignment.Documentation: All new components require comprehensive documentation.Testing: Unit tests for deterministic components, integration tests for pipeline.Performance: Benchmark all changes against baseline performance metrics.Architecture Reviews: Major pipeline changes require team architectural review.Implementation Discussion: Technical details should be validated before implementation.Progress Tracking: Regular updates on implementation progress and blockers.\nFrame Rate: Maintain 60 FPS with up to 8 players\nDeterminism: 100% consistency across identical inputs Latency: &lt;50ms total input-to-response latency in multiplayer\nMemory: &lt;20% increase in memory usage for state management Cross-Platform: Identical results on all supported GPU architectures\nNetwork Efficiency: &lt;16MB bandwidth per player per minute\nUser Experience: Smooth ghost predictions for all player actions cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Complete pipeline specification\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/deterministic-execution.html\" data-href=\"deterministic-execution\" aria-label=\"deterministic-execution\" data-tooltip-position=\"top\" target=\"_self\">Deterministic Execution</a> - GPU determinism implementation\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Time slice scheduling details\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/state-management.html\" data-href=\"state-management\" aria-label=\"state-management\" data-tooltip-position=\"top\" target=\"_self\">State Management</a> - Unified state system architecture\n⚠️ NEEDS TEAM VALIDATION:\nImplementation timeline and resource allocation\nTechnical risk tolerance and fallback strategies Performance targets and quality requirements\nIntegration approach with existing codebase\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Implementation Guide","level":1,"id":"Implementation_Guide_0"},{"heading":"Implementation Priority Order","level":2,"id":"Implementation_Priority_Order_0"},{"heading":"Phase 1: Core Pipeline Foundation","level":3,"id":"Phase_1_Core_Pipeline_Foundation_0"},{"heading":"Phase 2: GPU Determinism Framework","level":3,"id":"Phase_2_GPU_Determinism_Framework_0"},{"heading":"Phase 3: State Management Integration","level":3,"id":"Phase_3_State_Management_Integration_0"},{"heading":"Phase 4: Ghost Simulation System","level":3,"id":"Phase_4_Ghost_Simulation_System_0"},{"heading":"Technical Risk Assessment","level":2,"id":"Technical_Risk_Assessment_0"},{"heading":"High-Risk Components","level":3,"id":"High-Risk_Components_0"},{"heading":"Mitigation Strategies","level":3,"id":"Mitigation_Strategies_0"},{"heading":"Integration with Existing Systems","level":2,"id":"Integration_with_Existing_Systems_0"},{"heading":"Core Engine Modifications","level":3,"id":"Core_Engine_Modifications_0"},{"heading":"Physics Engine Updates","level":3,"id":"Physics_Engine_Updates_0"},{"heading":"Spell System Integration","level":3,"id":"Spell_System_Integration_0"},{"heading":"Validation and Testing Strategy","level":2,"id":"Validation_and_Testing_Strategy_0"},{"heading":"Determinism Testing","level":3,"id":"Determinism_Testing_0"},{"heading":"Multiplayer Testing","level":3,"id":"Multiplayer_Testing_0"},{"heading":"Development Guidelines","level":2,"id":"Development_Guidelines_0"},{"heading":"Code Quality Standards","level":3,"id":"Code_Quality_Standards_0"},{"heading":"Team Coordination","level":3,"id":"Team_Coordination_0"},{"heading":"Success Metrics","level":2,"id":"Success_Metrics_0"},{"heading":"Performance Targets","level":3,"id":"Performance_Targets_0"},{"heading":"Quality Targets","level":3,"id":"Quality_Targets_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/variable-timing.html","architecture/general/state-management.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/implementation-guide.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506318,"modifiedTime":1760380506319,"sourceSize":6036,"sourcePath":"architecture/general/implementation-guide.md","exportPath":"architecture/general/implementation-guide.html","showInTree":true,"treeOrder":6,"backlinks":["architecture/general/general.html"],"type":"markdown"},"architecture/general/overview.html":{"title":"overview","icon":"","description":"Reaction is a real-time PvP game where players cast spells that place magical runes on a grid. These runes transform the terrain according to rule-based systems.The core technical challenge: simulate thousands of interacting tiles at 60 FPS while allowing complex spell interactions that feel responsive and fair.Performance Goal: High performance with many active tilesDeterminism: Identical inputs produce identical outputs (essential for fair PvP)Responsiveness: Spell casting feels immediate despite complex backend processingExtensibility: New spells and tile interactions can be added without engine rewritesThe system separates concerns into focused, loosely-coupled modules:Purpose: Central coordination and tile data management.Responsibilities:\nBit-packed tile storage across 4 layers (Ground, Object, Air, Rune)\nGPU texture management with ping-ponging (enables GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards) for race-condition prevention\nActive region optimization (32×32 chunks - chosen to balance GPU workgroup efficiency with memory overhead)\nFrame execution pipeline coordination\nDependencies: WebGPU APIPurpose: Player-controlled spellcasting and resource management.Responsibilities:\nMana flower economy and recharge timers\nSpell validation and execution\nRune lifecycle management (placement, delay, triggering, combinations)\nDeck building and curse system\nPlayer customization options\nDependencies: Core Engine (for rune placement)Processing: Initially chosen for CPU because it handles direct player input. This choice may be revisited during implementation.Purpose: GPU-accelerated tile movement and collision simulation.Responsibilities:\nVelocity-based tile movement\nCollision detection and response\nForce application from runes and environment\nLayer interaction physics (falling, bouncing)\nDependencies: Core Engine (texture coordination)Processing: GPU compute shaders with hardcoded physics rulesNote: Frame rate coordination approach proposed in cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">data-flow.md</a> - implementation and effectiveness TBDPurpose: Rule-based environmental transformations.Responsibilities:\nJSON rule compilation to optimized GPU shaders\nCompetitive rule scoring and execution\nEnvironmental pattern matching (fire spreading, etc.)\nOptimization pipeline (specific implementation TBD)\nDependencies: Core Engine (texture access), Build toolchainProcessing: GPU compute shaders with compiled rulesNote: The rule compilation pipeline allows simple code generation with sophisticated optimization. Alternative approaches welcome if simpler.Purpose: Visual display and user interface.Responsibilities:\nMulti-layer world rendering\nUI elements (mana flowers, spell hand)\nVisual effects and animations\nCamera and viewport management\nDependencies: Core Engine (tile data access)Processing: GPU rendering pipelinePurpose: Development and debugging utilities.Responsibilities:\nVisual rule editor with grid-based interface\nDebug overlays and tile inspection\nPerformance profiling and rule tracing\nAsset validation and testing tools\nDependencies: All modules (for debugging access)<br>⚠️ PROPOSED ARCHITECTURE: A Deterministic Time-Sliced Execution approach has been proposed for variable timing and multiplayer synchronization. See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">data-flow.md</a> for proposed pipeline details - implementation and validation TBD.<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/core/tile-storage.html\" data-href=\"tile-storage\" aria-label=\"tile-storage\" data-tooltip-position=\"top\" target=\"_self\">tile-storage.md</a> for complete tile format and layer architecture details. Specific bit allocation TBD during implementation.<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/performance.html\" data-href=\"performance\" aria-label=\"performance\" data-tooltip-position=\"top\" target=\"_self\">performance.md</a> and individual system documentation for specific optimization strategies.<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"gameplay/gameplay.html\" data-href=\"gameplay\" aria-label=\"gameplay\" data-tooltip-position=\"top\" target=\"_self\">gameplay mechanics</a> for complete gameplay mechanics and customization systems.\nVisual Editor: Grid-based rule design interface\nJSON Export: Human-readable rule definitions\nCompilation: Automatic shader generation and optimization\nTesting: Live rule testing and validation\nIntegration: Hot-reload in development builds Tile Inspector: Real-time tile data examination\nRule Tracer: Understand why specific rules activated\nPerformance Overlay: Monitor frame timing and bottlenecks\nDeterminism Validation: Verify identical execution across runs\nTile Types: ~64 per layer (chosen to be comfortably under realistic limits)World Size: Fixed at initialization (no dynamic streaming)Mana Types: 8 maximum (player state buffer constraint)Spell Hand: Size TBD based on UI and gameplay needsPerformance Degradation: Automated benchmarks prevent optimization regressionsRule Complexity: Visual editor prevents impossible shader compilationDeterminism: Strict execution ordering and integer-only mathematicsToolchain Stability: Containerized build environment for consistent results","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"System Architecture Overview","level":1,"id":"System_Architecture_Overview_0"},{"heading":"Purpose and Core Challenge","level":2,"id":"Purpose_and_Core_Challenge_0"},{"heading":"System Requirements","level":2,"id":"System_Requirements_0"},{"heading":"Module Architecture","level":2,"id":"Module_Architecture_0"},{"heading":"Core Engine Module","level":3,"id":"Core_Engine_Module_0"},{"heading":"Spell System Module","level":3,"id":"Spell_System_Module_0"},{"heading":"Physics Engine Module","level":3,"id":"Physics_Engine_Module_0"},{"heading":"Reaction Engine Module","level":3,"id":"Reaction_Engine_Module_0"},{"heading":"Renderer Module","level":3,"id":"Renderer_Module_0"},{"heading":"Tools Module","level":3,"id":"Tools_Module_0"},{"heading":"Data Flow Architecture","level":2,"id":"Data_Flow_Architecture_0"},{"heading":"Technical Implementation","level":2,"id":"Technical_Implementation_0"},{"heading":"Tile Storage Format","level":3,"id":"Tile_Storage_Format_0"},{"heading":"Performance Optimizations","level":3,"id":"Performance_Optimizations_0"},{"heading":"Player Customization","level":3,"id":"Player_Customization_0"},{"heading":"Development Workflow","level":2,"id":"Development_Workflow_0"},{"heading":"Rule Creation Pipeline","level":3,"id":"Rule_Creation_Pipeline_0"},{"heading":"Debugging and Analysis","level":3,"id":"Debugging_and_Analysis_0"},{"heading":"Risk Management and Constraints","level":2,"id":"Risk_Management_and_Constraints_0"},{"heading":"Technical Constraints","level":3,"id":"Technical_Constraints_0"},{"heading":"Risk Mitigation","level":3,"id":"Risk_Mitigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/data-flow.html","architecture/systems/core/tile-storage.html","architecture/general/performance.html","gameplay/gameplay.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/overview.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506319,"modifiedTime":1760380506319,"sourceSize":5705,"sourcePath":"architecture/general/overview.md","exportPath":"architecture/general/overview.html","showInTree":true,"treeOrder":7,"backlinks":["architecture/architecture.html","development/getting-started.html","architecture/general/general.html","index.html"],"type":"markdown"},"architecture/general/performance.html":{"title":"performance","icon":"","description":"Optimization approaches and technical constraints for tile processing performance.⚠️ NEEDS DISCUSSION: Specific performance targets and constraints have not been established yet.General Goals:\nSupport many active tiles simultaneously\nPerformance should scale with activity level rather than world size\nPurpose: Avoid processing static regions to maintain performance.Implementation:\nDivide world into 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)\nTrack chunks with active tiles in GPU buffer\nShaders only process listed active chunks\nActivity propagates to neighboring chunks automatically\nDormant regions have minimal GPU cost\nBenefits:\nAutomatic scaling with activity level\nEfficient memory bandwidth usage\nReduced compute shader dispatches\nGPU Cache Optimization: Leverage 2D data access patterns for efficient memory readsBit-Packing: 32-bit tiles maximize cache line utilization\nTile Type (~6 bits): 64 possible types per layer\nVelocity (16 bits): Movement vector for physics\nCustom Data (10 bits): Health, timers, charges, etc.\nPing-Ponging: Dual texture approach prevents read-after-write hazardsGPU Workgroup Efficiency: 32×32 chunks align with GPU architectureMemory Layout: Textures use r32uint format for optimal GPU cache performanceParallel Processing: Each GPU thread handles one tile for maximum parallelization⚠️ POTENTIAL OPTIMIZATIONS: Additional GPU techniques\nMemory Coalescing: Threads in a warp access consecutive memory addresses simultaneously for maximum bandwidth\n⚠️ GUIDELINE: Minimize divergent branching\nStructure algorithms so threads in the same warp follow similar execution paths\nWhen early exits are necessary, group similar work patterns together to reduce warp divergence\nTile Types: ~64 per layer (chosen to be comfortably under realistic limits)\nWorld Size: Fixed at initialization (no dynamic streaming)\nMana Types: 8 maximum (player state buffer constraint)\nSpell Hand: Size TBD based on UI and gameplay needs⚠️ NEEDS DISCUSSION: Specific performance characteristics to be determined through testing\n32×32 chunks chosen to balance GPU workgroup efficiency with memory overhead\nGPU texture cache considerations\nParallel processing efficiency targets\n⚠️ SUGGESTION: Potential optimization techniques for rule compilation:\nCompile-time specialization for specific use cases\nDead code elimination for unused rule paths\nConstant folding for pre-computed values\nLoop unrolling for neighbor checks\nShader Generation: Move complex rule logic to build time\nAsset Optimization: Texture and mesh preprocessing\n⚠️ NEEDS DESIGN: Specific optimization pipeline implementation⚠️ SUGGESTION: Potential monitoring and validation approaches:\nAutomated benchmarks to prevent regressions\nFrame timing and bottleneck profiling\nDeterminism validation across runs\n⚠️ Major Unsolved Issues:\nFrame rate coordination between different systems\nGPU thread execution order determinism\nMemory bandwidth optimization across modules\n⚠️ SUGGESTION: Potential profiling capabilities to develop:\nFrame timing monitoring for pipeline stages\nGPU utilization tracking\nMemory bandwidth analysis\nActive region processing visualization\n⚠️ SUGGESTION: Potential debugging tools:\nTile inspector for real-time data examination\nRule tracer for activation analysis\nDeterminism validation tools\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Performance Strategy","level":1,"id":"Performance_Strategy_0"},{"heading":"Performance Requirements","level":2,"id":"Performance_Requirements_0"},{"heading":"Optimization Systems","level":2,"id":"Optimization_Systems_0"},{"heading":"Active Region System","level":3,"id":"Active_Region_System_0"},{"heading":"Texture-Based Storage","level":3,"id":"Texture-Based_Storage_0"},{"heading":"Chunk-Based Processing","level":3,"id":"Chunk-Based_Processing_0"},{"heading":"Shader Design Principles","level":3,"id":"Shader_Design_Principles_0"},{"heading":"Technical Constraints","level":2,"id":"Technical_Constraints_0"},{"heading":"Hard Limits","level":3,"id":"Hard_Limits_0"},{"heading":"Performance Scaling","level":3,"id":"Performance_Scaling_0"},{"heading":"Offline Optimizations","level":2,"id":"Offline_Optimizations_0"},{"heading":"Rule Compilation Approach","level":3,"id":"Rule_Compilation_Approach_0"},{"heading":"Build-Time Processing","level":3,"id":"Build-Time_Processing_0"},{"heading":"Risk Management","level":2,"id":"Risk_Management_0"},{"heading":"Performance Monitoring","level":3,"id":"Performance_Monitoring_0"},{"heading":"Bottleneck Identification","level":3,"id":"Bottleneck_Identification_0"},{"heading":"Monitoring and Debugging","level":2,"id":"Monitoring_and_Debugging_0"},{"heading":"Performance Profiling","level":3,"id":"Performance_Profiling_0"},{"heading":"Debug Capabilities","level":3,"id":"Debug_Capabilities_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/general/performance.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506319,"modifiedTime":1760380506320,"sourceSize":4083,"sourcePath":"architecture/general/performance.md","exportPath":"architecture/general/performance.html","showInTree":true,"treeOrder":8,"backlinks":["architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/overview.html"],"type":"markdown"},"architecture/general/state-management.html":{"title":"state-management","icon":"","description":"⚠️ PROPOSED SYSTEM: This document describes the proposed unified state management approach that serves both single-player gameplay and multiplayer networking requirements through a single pipeline.Core Concept: Use identical state management for single-player, multiplayer client prediction, and multiplayer server authority.Benefits:\nConsistent behavior across all game modes\nSimplified testing and debugging\nReduced code duplication\nNatural multiplayer upgrade path Frame-based snapshots for rollback and networking\nDeterministic state serialization for cross-platform consistency Efficient delta compression for multiplayer bandwidth optimization\nRollback recovery for client prediction correction\nFrequency: Every frame (60 FPS) for complete state history.Retention: 300 snapshots (5 seconds) in circular buffer for rollback window.Compression: Incremental snapshots with delta compression for memory efficiency.interface GameStateSnapshot { frameNumber: number; timestamp: number; // Core game data tileData: CompressedTileData; playerStates: PlayerStateData[]; activeChunks: ChunkId[]; // Timing system state timeSliceState: TimeSliceSchedulerState; manaRechargeState: ManaSchedulerState; // Validation checksum: string; // Compression metadata deltaBaseFrame?: number; compressionLevel: 'full' | 'delta' | 'minimal';\n} class StateSnapshotManager { private snapshots = new CircularBuffer&lt;GameStateSnapshot&gt;(300); private deltaCompressor = new DeltaCompressor(); saveFrameState(frameNumber: number, gameState: GameState): void { const snapshot = this.createSnapshot(frameNumber, gameState); this.snapshots.push(snapshot); // Clean up old snapshots beyond retention window this.cleanupOldSnapshots(); } private createSnapshot(frameNumber: number, state: GameState): GameStateSnapshot { // Determine compression strategy const useFullSnapshot = frameNumber % 60 === 0; // Every second const compressionLevel = useFullSnapshot ? 'full' : 'delta'; return { frameNumber, timestamp: performance.now(), tileData: this.compressTileData(state.tiles, compressionLevel), playerStates: this.serializePlayerStates(state.players), activeChunks: Array.from(state.activeChunks), timeSliceState: state.scheduler.serialize(), manaRechargeState: state.manaScheduler.serialize(), checksum: this.calculateChecksum(state), deltaBaseFrame: useFullSnapshot ? undefined : frameNumber - 1, compressionLevel }; }\n}\nMultiplayer Misprediction: Server state differs from client prediction.Determinism Failure: Checksum mismatch in single-player determinism testing.Network Recovery: Client needs to resynchronize with server.class RollbackManager { async rollbackToFrame(targetFrame: number): Promise&lt;boolean&gt; { // Find target snapshot const snapshot = this.snapshotManager.getSnapshot(targetFrame); if (!snapshot) { console.error(`Cannot rollback: snapshot ${targetFrame} not found`); return false; } // Restore game state await this.restoreGameState(snapshot); // Re-execute frames from rollback point to current const currentFrame = this.gameEngine.getCurrentFrame(); for (let frame = targetFrame + 1; frame &lt;= currentFrame; frame++) { await this.replayFrame(frame); } return true; } private async restoreGameState(snapshot: GameStateSnapshot): Promise&lt;void&gt; { // Restore tile data await this.tileManager.restoreFromSnapshot(snapshot.tileData); // Restore player states this.playerManager.restoreFromSnapshot(snapshot.playerStates); // Restore timing system state this.scheduler.deserialize(snapshot.timeSliceState); this.manaScheduler.deserialize(snapshot.manaRechargeState); // Validate restoration const restoredChecksum = this.calculateChecksum(this.gameState); if (restoredChecksum !== snapshot.checksum) { throw new Error('State restoration checksum mismatch'); } }\n}\nLocal Simulation: Run complete game simulation locally for responsiveness.Server Validation: Compare local state with authoritative server updates.Automatic Correction: Rollback and re-execute when server state differs.class ClientPredictionManager { private pendingInputs = new Map&lt;number, PlayerInput[]&gt;(); private serverStates = new Map&lt;number, GameStateSnapshot&gt;(); processServerUpdate(serverSnapshot: GameStateSnapshot): void { const frameNumber = serverSnapshot.frameNumber; this.serverStates.set(frameNumber, serverSnapshot); // Compare with local prediction const localSnapshot = this.snapshotManager.getSnapshot(frameNumber); if (localSnapshot &amp;&amp; !this.statesMatch(localSnapshot, serverSnapshot)) { console.log(`Misprediction detected at frame ${frameNumber}, rolling back`); this.rollbackManager.rollbackToFrame(frameNumber); } // Confirm inputs up to this frame this.confirmInputsUpToFrame(frameNumber); } private statesMatch(local: GameStateSnapshot, server: GameStateSnapshot): boolean { // Compare essential game state (ignore client-only data) return ( local.checksum === server.checksum &amp;&amp; this.tileDataMatches(local.tileData, server.tileData) &amp;&amp; this.playerStatesMatch(local.playerStates, server.playerStates) ); }\n}\nAuthoritative Simulation: Server runs definitive game simulation.Input Validation: Validate all client inputs before application.State Broadcasting: Send compressed state updates to all clients.class ServerAuthorityManager { private connectedClients = new Set&lt;ClientConnection&gt;(); processFrame(): void { // Standard game processing this.gameEngine.processFrame(); // Generate state delta for clients const currentFrame = this.gameEngine.getCurrentFrame(); const stateDelta = this.generateStateDelta(currentFrame); // Broadcast to all clients this.broadcastStateDelta(stateDelta); } private generateStateDelta(frameNumber: number): StateDelta { const currentSnapshot = this.snapshotManager.getSnapshot(frameNumber); const previousSnapshot = this.snapshotManager.getSnapshot(frameNumber - 1); return this.deltaCompressor.createDelta(previousSnapshot, currentSnapshot); }\n}\nChange Detection: Only transmit modified tiles per frame.Run-Length Encoding: Compress sequences of similar changes.Spatial Compression: Group changes by active regions.class TileDeltaCompressor { compressTileChanges(oldTiles: TileData, newTiles: TileData): CompressedTileData { const changes: TileChange[] = []; // Detect changes for (let y = 0; y &lt; this.worldHeight; y++) { for (let x = 0; x &lt; this.worldWidth; x++) { const oldTile = oldTiles.getTile(x, y); const newTile = newTiles.getTile(x, y); if (oldTile !== newTile) { changes.push({ x, y, oldValue: oldTile, newValue: newTile }); } } } // Apply compression algorithms return this.compressChanges(changes); } private compressChanges(changes: TileChange[]): CompressedTileData { // Group by active chunks const chunkChanges = this.groupByChunk(changes); // Apply run-length encoding within chunks const compressed = chunkChanges.map(chunk =&gt; this.runLengthEncode(chunk.changes) ); return { changedChunks: compressed, compressionRatio: changes.length / compressed.length }; }\n}\nSnapshot Pooling: Reuse snapshot objects to reduce garbage collection.Lazy Compression: Compress snapshots in background thread when possible.Memory-Mapped Storage: Use efficient binary formats for large state data.Adaptive Compression: Adjust compression level based on network conditions.Priority Transmission: Send critical state changes immediately.Batch Optimization: Group small changes into larger network packets.Incremental Replay: Only re-execute affected systems during rollback.State Caching: Cache frequently accessed rollback points.Parallel Processing: Use worker threads for rollback computation when possible.Checksum Validation: Verify state integrity at snapshot creation and restoration.Cross-Reference Checking: Validate state consistency across different data structures.Automated Recovery: Attempt automatic recovery from last known good state.Connection Recovery: Seamless reconnection with state synchronization.Missing Data Recovery: Request missing snapshots from server.Graceful Degradation: Continue local simulation during temporary disconnections.class DeterminismValidator { validateStateConsistency(snapshot: GameStateSnapshot): ValidationResult { // Check internal consistency const tileConsistency = this.validateTileData(snapshot.tileData); const playerConsistency = this.validatePlayerStates(snapshot.playerStates); const timingConsistency = this.validateTimingState(snapshot.timeSliceState); // Verify checksum const calculatedChecksum = this.calculateChecksum(snapshot); const checksumValid = calculatedChecksum === snapshot.checksum; return { valid: tileConsistency &amp;&amp; playerConsistency &amp;&amp; timingConsistency &amp;&amp; checksumValid, errors: this.collectValidationErrors(), warnings: this.collectValidationWarnings() }; }\n} cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Parent pipeline architecture <br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Integration with time slice scheduling\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/multiplayer/multiplayer.html\" data-href=\"multiplayer\" aria-label=\"multiplayer\" data-tooltip-position=\"top\" target=\"_self\">Multiplayer System</a> - Network protocol and client prediction details\n⚠️ NEEDS TEAM DISCUSSION:\nSnapshot retention policy (current proposal: 5 seconds)\nDelta compression vs full snapshot frequency (current proposal: every 60 frames)\nRollback window limits for client prediction\n⚠️ NEEDS IMPLEMENTATION:\nPerformance benchmarking of snapshot creation overhead\nNetwork bandwidth testing with delta compression\nCross-platform determinism validation suite\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"State Management System","level":1,"id":"State_Management_System_0"},{"heading":"Unified Architecture Principle","level":2,"id":"Unified_Architecture_Principle_0"},{"heading":"Single Pipeline Design","level":3,"id":"Single_Pipeline_Design_0"},{"heading":"State Management Responsibilities","level":3,"id":"State_Management_Responsibilities_0"},{"heading":"State Snapshot System","level":2,"id":"State_Snapshot_System_0"},{"heading":"Snapshot Strategy","level":3,"id":"Snapshot_Strategy_0"},{"heading":"Rollback System","level":2,"id":"Rollback_System_0"},{"heading":"Rollback Triggers","level":3,"id":"Rollback_Triggers_0"},{"heading":"Rollback Process","level":3,"id":"Rollback_Process_0"},{"heading":"Multiplayer Integration","level":2,"id":"Multiplayer_Integration_0"},{"heading":"Client Prediction Mode","level":3,"id":"Client_Prediction_Mode_0"},{"heading":"Server Authority Mode","level":3,"id":"Server_Authority_Mode_0"},{"heading":"Delta Compression","level":2,"id":"Delta_Compression_0"},{"heading":"Tile Data Compression","level":3,"id":"Tile_Data_Compression_0"},{"heading":"Performance Optimizations","level":2,"id":"Performance_Optimizations_0"},{"heading":"Memory Management","level":3,"id":"Memory_Management_0"},{"heading":"Network Efficiency","level":3,"id":"Network_Efficiency_0"},{"heading":"Rollback Efficiency","level":3,"id":"Rollback_Efficiency_0"},{"heading":"Error Handling and Recovery","level":2,"id":"Error_Handling_and_Recovery_0"},{"heading":"State Corruption Detection","level":3,"id":"State_Corruption_Detection_0"},{"heading":"Network Failure Handling","level":3,"id":"Network_Failure_Handling_0"},{"heading":"Determinism Validation","level":3,"id":"Determinism_Validation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/variable-timing.html","architecture/systems/multiplayer/multiplayer.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/state-management.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506320,"modifiedTime":1760380506320,"sourceSize":12367,"sourcePath":"architecture/general/state-management.md","exportPath":"architecture/general/state-management.html","showInTree":true,"treeOrder":9,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html","architecture/general/implementation-guide.html","architecture/general/variable-timing.html","architecture/systems/multiplayer/client-prediction.html"],"type":"markdown"},"architecture/general/technical-decisions.html":{"title":"technical-decisions","icon":"","description":"Design choices, rationale, and alternative approaches considered during Reaction v2 architecture.Decision: Separate concerns into focused, loosely-coupled modules\nRationale: Enables independent development and testing of complex systems\nAlternative Considered: Monolithic architecture - rejected for maintainability concernsDecision: WebGPU-based processing for physics, reactions, and rendering\nRationale: Required performance for thousands of interacting tiles at 60 FPS\nTrade-offs: Added complexity vs. performance requirementsSpell System: Initially chosen for CPU because it handles direct player input and seemed more straightforward to implement. This choice may be revisited during implementation.Physics Engine: GPU compute shaders with hardcoded physics rules\nRationale: High parallelization needs for tile movement and collision detectionReaction Engine: GPU compute shaders with compiled rules\nRationale: Complex rule evaluation benefits from parallel processingDecision: Input → Physics → Runes → Reactions → Render\nRationale: Ensures deterministic execution and proper data dependencies\n⚠️ UNSOLVED: Timing coordination between systems at different frequenciesDecision: 32-bit integers with packed tile data\nRationale: GPU cache efficiency and memory bandwidth optimization\n⚠️ NOTE: Specific bit allocation TBD during implementation. See <a class=\"internal-link\" data-href=\"../systems/core-engine/tile-storage.md\" href=\".html\" target=\"_self\" rel=\"noopener nofollow\">tile-storage.md</a> for current architectural approach.Decision: Ground, Object, Air, Rune layers\nRationale: Clean separation of different tile behaviors and interactions\nAlternative Considered: Single layer with type flags - rejected for complexityDecision: Dual texture approach for each layer\nRationale: Prevents GPU read-after-write hazards and race conditions\nTrade-off: Double memory usage for synchronization safetyDecision: 32×32 tile chunks for processing optimization\nRationale: Balances GPU workgroup efficiency with memory overhead\nAlternative Sizes Considered: 16×16 (too small), 64×64 (too large for cache)Decision: JSON rules → GPU shaders via offline compilation\nRationale: Move computational work to build time for runtime performance\n⚠️ NOTE: Alternative approaches may be considered during implementationDecision: 3-turn recharge cycle with unlimited regeneration\nRationale: Balances spell casting incentive vs strategic saving\nAlternative Considered: Scarcity-based system - rejected for pacing concernsDecision: 2:1 mana flower trading removed\nRationale: Simplified resource management modelDecision: ~64 tile types per layer\nRationale: Chosen to be comfortably under realistic GPU and memory limits\nConstraint: Leaves room for expansion without architectural changesDecision: Identical inputs must produce identical outputs\nRationale: Essential for fair PvP gameplay\nImplementation: Integer-only mathematics, strict execution ordering\n⚠️ CHALLENGE: GPU thread execution order is not inherently deterministicDecision: Fixed world size at initialization\nRationale: Avoids dynamic streaming complexity\nTrade-off: Limits map variety for implementation simplicityDecision: Grid-based rule design interface planned\nRationale: Simplifies rule creation and prevents impossible shader compilation\nStatus: Design planned, implementation TBDDecision: Use containerized build for consistent results\nRationale: Ensures deterministic shader compilation across development environments\n⚠️ STATUS: Implementation approach needs specification⚠️ Major Design Decisions Still Needed: Frame Rate Coordination: How to handle different update frequencies between physics (60 FPS) and reactions (potentially lower)? GPU Determinism: Specific approach to ensure consistent thread execution order? Rule Compilation Pipeline: Exact toolchain and optimization steps? Spell Hand Size: UI and gameplay constraints on number of spells available? World Size Limits: Performance testing needed to determine optimal map dimensions? Build System Integration: How rule compilation integrates with main build process? ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Technical Decisions","level":1,"id":"Technical_Decisions_0"},{"heading":"Core Architecture Decisions","level":2,"id":"Core_Architecture_Decisions_0"},{"heading":"Modular Design Choice","level":3,"id":"Modular_Design_Choice_0"},{"heading":"WebGPU Selection","level":3,"id":"WebGPU_Selection_0"},{"heading":"Processing Model Decisions","level":2,"id":"Processing_Model_Decisions_0"},{"heading":"CPU vs GPU Assignment","level":3,"id":"CPU_vs_GPU_Assignment_0"},{"heading":"Frame Pipeline Order","level":3,"id":"Frame_Pipeline_Order_0"},{"heading":"Data Storage Decisions","level":2,"id":"Data_Storage_Decisions_0"},{"heading":"Bit-Packed Tile Format","level":3,"id":"Bit-Packed_Tile_Format_0"},{"heading":"Four-Layer Architecture","level":3,"id":"Four-Layer_Architecture_0"},{"heading":"Texture Ping-Ponging","level":3,"id":"Texture_Ping-Ponging_0"},{"heading":"Optimization Decisions","level":2,"id":"Optimization_Decisions_0"},{"heading":"Active Region System","level":3,"id":"Active_Region_System_0"},{"heading":"Rule Compilation Strategy","level":3,"id":"Rule_Compilation_Strategy_0"},{"heading":"Resource Management Decisions","level":2,"id":"Resource_Management_Decisions_0"},{"heading":"Mana Flower Economy","level":3,"id":"Mana_Flower_Economy_0"},{"heading":"Tile Type Limits","level":3,"id":"Tile_Type_Limits_0"},{"heading":"Performance Constraint Decisions","level":2,"id":"Performance_Constraint_Decisions_0"},{"heading":"Determinism Requirements","level":3,"id":"Determinism_Requirements_0"},{"heading":"World Size Constraints","level":3,"id":"World_Size_Constraints_0"},{"heading":"Development Workflow Decisions","level":2,"id":"Development_Workflow_Decisions_0"},{"heading":"Visual Rule Editor","level":3,"id":"Visual_Rule_Editor_0"},{"heading":"Containerized Build Environment","level":3,"id":"Containerized_Build_Environment_0"},{"heading":"Open Questions Requiring Further Decision","level":2,"id":"Open_Questions_Requiring_Further_Decision_0"}],"links":[".html"],"author":"","coverImageURL":"","fullURL":"architecture/general/technical-decisions.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506320,"modifiedTime":1760380506321,"sourceSize":5007,"sourcePath":"architecture/general/technical-decisions.md","exportPath":"architecture/general/technical-decisions.html","showInTree":true,"treeOrder":10,"backlinks":["architecture/general/general.html","architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/general/variable-timing.html":{"title":"variable-timing","icon":"","description":"⚠️ PROPOSED SYSTEM: This document describes the proposed time slice scheduling system that enables variable player action timing while maintaining deterministic 60 FPS execution.Variable Player Speeds: Different players can have different action timing based on status effects.Fixed Mana Timing: Mana recharge remains strategically consistent regardless of player speed changes.Smooth Physics: Maintain 60 FPS physics simulation for fluid movement.Deterministic Execution: All timing decisions must be reproducible for multiplayer.Frame Duration: 16.67ms (60 FPS)\nTime Slices: 8 slices per frame\nSlice Duration: 2.08ms per sliceRationale: 8 slices provides sufficient granularity for speed effects (0.5x to 2x) while maintaining reasonable processing overhead.interface TimeSliceSchedule { // Base timing (normal speed) baseActionInterval: 8; // 8 slices = 1 action baseManaInterval: 24; // 24 slices = 3 actions // Physics runs every slice for smooth motion physicsInterval: 1; // Reactions run less frequently for performance reactionInterval: 4; // Every 4 slices\n}\nSpeed Effects: Status effects modify player action timing immediately.Calculation: newInterval = baseInterval / speedMultiplierSpeed Ranges: Slowed: 0.5x (16 slices per action)\nNormal: 1.0x (8 slices per action) Hasted: 2.0x (4 slices per action)\ninterface PlayerActionSchedule { playerId: string; currentInterval: number; // Current slices between actions nextActionSlice: number; // When next action executes queuedActions: PlayerAction[]; // 3 actions lookahead speedMultiplier: number; // Current speed effect\n} class TimeSliceScheduler { private playerSchedules = new Map&lt;string, PlayerActionSchedule&gt;(); private currentSlice = 0; // Process all scheduled actions for this slice processSlice(sliceIndex: number) { this.currentSlice = sliceIndex; // Process players in deterministic order (by ID) const sortedPlayerIds = Array.from(this.playerSchedules.keys()).sort(); for (const playerId of sortedPlayerIds) { this.processPlayerSchedule(playerId, sliceIndex); } } private processPlayerSchedule(playerId: string, slice: number) { const schedule = this.playerSchedules.get(playerId); if (schedule.nextActionSlice === slice) { // Execute queued action const action = schedule.queuedActions.shift(); this.executePlayerAction(playerId, action); // Schedule next action schedule.nextActionSlice = slice + schedule.currentInterval; // Request new action for queue this.requestNextAction(playerId); } }\n}\nIndependence: Mana timing unaffected by player speed changes.Strategic Consistency: Players can rely on consistent mana timing for tactical planning.Implementation: Separate timing system running parallel to player actions.class ManaRechargeScheduler { private readonly MANA_RECHARGE_INTERVAL = 24; // 3 base actions worth private nextRechargeSlice = 24; processSlice(sliceIndex: number) { if (sliceIndex === this.nextRechargeSlice) { this.rechargeManaFlowers(); this.nextRechargeSlice += this.MANA_RECHARGE_INTERVAL; } } private rechargeManaFlowers() { // Recharge all mana flowers regardless of player speeds for (const flower of this.getAllManaFlowers()) { flower.recharge(); } }\n}\nTiming Update: Speed effects immediately modify next action timing.Queue Preservation: Existing action queue remains valid but timing adjusts.Deterministic Application: Speed changes processed in consistent order.class StatusEffectManager { applySpeedEffect(playerId: string, newMultiplier: number) { const schedule = this.scheduler.getPlayerSchedule(playerId); const currentSlice = this.scheduler.getCurrentSlice(); // Calculate remaining time to next action const remainingSlices = schedule.nextActionSlice - currentSlice; // Apply speed change to remaining time const speedChange = newMultiplier / schedule.speedMultiplier; const newRemainingSlices = Math.ceil(remainingSlices / speedChange); // Update schedule schedule.speedMultiplier = newMultiplier; schedule.currentInterval = Math.ceil(8 / newMultiplier); // 8 = base interval schedule.nextActionSlice = currentSlice + newRemainingSlices; // Invalidate affected ghost predictions this.ghostSimulator.invalidatePlayerPredictions(playerId); }\n}\nSimultaneous Actions: When multiple players have actions scheduled for same slice, process in deterministic order (player ID).Queue Validation: Validate action legality when scheduled, not when executed.Timing Consistency: Ensure identical timing calculations across all clients and server.class SchedulingEdgeCases { // Handle sub-slice timing precision handleFractionalSlices(calculatedSlices: number): number { // Always round up to ensure actions don't execute too early return Math.ceil(calculatedSlices); } // Handle extreme speed changes clampSpeedMultiplier(multiplier: number): number { return Math.max(0.1, Math.min(10.0, multiplier)); } // Handle action queue overflow validateActionQueue(queue: PlayerAction[]): boolean { // Ensure queue never exceeds 3 actions return queue.length &lt;= 3; }\n}\nSparse Processing: Only process slices with scheduled events.Batch Operations: Group similar operations within same slice.Memory Efficiency: Use circular buffers for timing data.Consistent Frequency: Physics processes every slice for smooth motion.Interpolation: Visual interpolation between physics updates for display.State Synchronization: Ensure physics state consistency with action timing.Lookahead: Simulate 3 queued actions for each player.Timing Prediction: Account for current speed effects in predictions.Invalidation: Update predictions when speed effects change.class GhostTimingPredictor { predictActionTiming(playerId: string, actionCount: number): number[] { const schedule = this.scheduler.getPlayerSchedule(playerId); const predictions: number[] = []; let nextSlice = schedule.nextActionSlice; for (let i = 0; i &lt; actionCount; i++) { predictions.push(nextSlice); nextSlice += schedule.currentInterval; } return predictions; }\n}\nDeterminism Tests: Verify identical timing across multiple runs.Edge Case Coverage: Test extreme speed values and rapid changes.Synchronization Validation: Ensure client-server timing consistency.Slice Processing Overhead: Measure time slice processing cost.Memory Usage: Monitor scheduling data structure efficiency.Scalability: Test with varying player counts and speed effects.\ncross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Parent pipeline architecture\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/deterministic-execution.html\" data-href=\"deterministic-execution\" aria-label=\"deterministic-execution\" data-tooltip-position=\"top\" target=\"_self\">Deterministic Execution</a> - Execution order and consistency\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/state-management.html\" data-href=\"state-management\" aria-label=\"state-management\" data-tooltip-position=\"top\" target=\"_self\">State Management</a> - Integration with state snapshots\n⚠️ NEEDS TEAM DISCUSSION:\nOptimal slice count (current proposal: 8 slices per frame)\nSpeed multiplier ranges (current proposal: 0.1x to 10x)\nGhost prediction complexity vs performance trade-offs\n⚠️ NEEDS IMPLEMENTATION:\nDetailed performance benchmarking of time slice overhead\nIntegration testing with existing Core Engine texture management\nMultiplayer synchronization validation\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Variable Timing System","level":1,"id":"Variable_Timing_System_0"},{"heading":"Design Goals","level":2,"id":"Design_Goals_0"},{"heading":"Core Requirements","level":3,"id":"Core_Requirements_0"},{"heading":"Time Slice Architecture","level":2,"id":"Time_Slice_Architecture_0"},{"heading":"Frame Subdivision","level":3,"id":"Frame_Subdivision_0"},{"heading":"Slice Allocation Strategy","level":3,"id":"Slice_Allocation_Strategy_0"},{"heading":"Player Action Scheduling","level":2,"id":"Player_Action_Scheduling_0"},{"heading":"Speed Multiplier System","level":3,"id":"Speed_Multiplier_System_0"},{"heading":"Action Queue Management","level":3,"id":"Action_Queue_Management_0"},{"heading":"Mana Recharge System","level":2,"id":"Mana_Recharge_System_0"},{"heading":"Fixed Timing Strategy","level":3,"id":"Fixed_Timing_Strategy_0"},{"heading":"Status Effect Integration","level":2,"id":"Status_Effect_Integration_0"},{"heading":"Immediate Speed Changes","level":3,"id":"Immediate_Speed_Changes_0"},{"heading":"Deterministic Scheduling","level":2,"id":"Deterministic_Scheduling_0"},{"heading":"Conflict Resolution","level":3,"id":"Conflict_Resolution_0"},{"heading":"Edge Case Handling","level":3,"id":"Edge_Case_Handling_0"},{"heading":"Performance Optimizations","level":2,"id":"Performance_Optimizations_0"},{"heading":"Scheduling Efficiency","level":3,"id":"Scheduling_Efficiency_0"},{"heading":"Integration with Physics","level":3,"id":"Integration_with_Physics_0"},{"heading":"Ghost Simulation Integration","level":2,"id":"Ghost_Simulation_Integration_0"},{"heading":"Prediction Timeline","level":3,"id":"Prediction_Timeline_0"},{"heading":"Testing and Validation","level":2,"id":"Testing_and_Validation_0"},{"heading":"Timing Accuracy","level":3,"id":"Timing_Accuracy_0"},{"heading":"Performance Benchmarks","level":3,"id":"Performance_Benchmarks_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/state-management.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/variable-timing.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506321,"modifiedTime":1760380506321,"sourceSize":9400,"sourcePath":"architecture/general/variable-timing.md","exportPath":"architecture/general/variable-timing.html","showInTree":true,"treeOrder":11,"backlinks":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/state-management.html"],"type":"markdown"},"architecture/systems/config/config.html":{"title":"config","icon":"","description":"Status: 🚧 Stub - This system documentation needs completionSystem for managing game configuration, settings, and runtime parameters.TODO: Add links to configuration components when implemented:\nConfiguration file formats and schemas\nRuntime configuration management\nEnvironment-specific settings\nValidation and error handling\nTODO: Document configuration system responsibilities:\nGame settings and parameters\nEnvironment configuration (dev/test/prod)\nRuntime parameter management\nConfiguration validation and defaults\nTODO: Define configuration categories:\nGame Settings: Tile limits, world parameters, gameplay constants\nPerformance Settings: GPU options, rendering quality, frame rate targets\nNetwork Settings: Server endpoints, timeout values, retry policies\nDevelopment Settings: Debug flags, logging levels, profiling options\nTODO: Add implementation details:\nConfiguration file loading and parsing\nHot-reloading of configuration changes\nConfiguration override hierarchy\nValidation and schema enforcement\n🚧 This file is a stub and needs completion","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Configuration System","level":1,"id":"Configuration_System_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Configuration Categories","level":2,"id":"Configuration_Categories_0"},{"heading":"Implementation Notes","level":2,"id":"Implementation_Notes_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/config/config.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506322,"modifiedTime":1760380506322,"sourceSize":1478,"sourcePath":"architecture/systems/config/config.md","exportPath":"architecture/systems/config/config.html","showInTree":true,"treeOrder":14,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/core/active-regions.html":{"title":"active-regions","icon":"","description":"Chunk-based processing optimization to avoid processing static regions.Purpose: Avoid processing static regions to maintain performance.Core Characteristic: Automatic scaling with activity level rather than world size.\nChunk Size: 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)\nWorld Organization: Divide entire world into fixed chunk grid\nChunk Coordinates: Each chunk identified by (chunk_x, chunk_y) coordinates Active Chunk Buffer: GPU buffer maintains list of chunks with active tiles\nShader Processing: Shaders only process tiles in listed active chunks\nDynamic Updates: Chunks added/removed from active list based on tile changes Neighbor Activation: Activity automatically propagates to neighboring chunks\nMovement Spreading: Moving tiles mark their destination chunks as active\nCollision Effects: Collisions spread activity to neighboring regions\nGradual Decay: Activity in stable regions decays over time\n@compute @workgroup_size(8, 8)\nfn process_active_chunks(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let chunk_coord = active_chunks[workgroup_id.x]; let local_coord = global_id.xy; let world_coord = chunk_coord * 32u + local_coord; // Process only tiles in active chunks if (world_coord.x &lt; world_size.x &amp;&amp; world_coord.y &lt; world_size.y) { process_tile(world_coord); }\n}\nGPU Alignment: 32×32 chunks align well with GPU workgroup sizes\nMemory Coalescing: Chunk-based processing improves memory access patterns\nThread Utilization: Reduces wasted GPU threads on empty regions\nActivity-Based Cost: Processing cost scales with active tiles, not world size\nDormant Regions: Static areas have minimal GPU cost\nMemory Access: Reduced texture memory accesses in inactive regions\nActive Chunk Buffer: Small GPU buffer storing active chunk coordinates\nTracking Data: Minimal per-chunk metadata for activity state\nNegligible Cost: Buffer size insignificant compared to texture memory\nTile Movement: Moving tiles activate their current and destination chunks\nSpell Casting: Rune placement activates target chunks\nEnvironmental Changes: Rule transformations mark chunks active\nForce Application: Physics forces spread activation\n⚠️ NEEDS DESIGN: Specific strategy for marking chunks inactive\nPotential approaches: Timer-based decay, change detection, activity counters\nChallenge: Balance between responsiveness and performance\nChunk Boundaries: Ensure proper handling of tiles affecting multiple chunks\nLarge Effects: Spells or explosions affecting many chunks simultaneously\nPerformance Spikes: Sudden activation of many dormant regions\nMovement Processing: Physics updates active chunk list based on tile movement\nCollision Detection: Collision effects activate neighboring chunks Rule Processing: Environmental transformations mark affected chunks active\nPattern Matching: Large-scale patterns may activate multiple chunks Rune Placement: Spell casting activates target chunks immediately\nArea Effects: Large spells properly handle multi-chunk activation\n⚠️ NEEDS SPECIFICATION: Detailed implementation approach for:\nActive chunk buffer data structure\nGPU buffer update mechanisms Integration with existing texture ping-ponging\nPerformance monitoring and tuning capabilities\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Active Region System","level":1,"id":"Active_Region_System_0"},{"heading":"Purpose","level":2,"id":"Purpose_0"},{"heading":"Implementation Strategy","level":2,"id":"Implementation_Strategy_0"},{"heading":"Chunk Division","level":3,"id":"Chunk_Division_0"},{"heading":"Activity Tracking","level":3,"id":"Activity_Tracking_0"},{"heading":"Activity Propagation","level":3,"id":"Activity_Propagation_0"},{"heading":"GPU Shader Integration","level":2,"id":"GPU_Shader_Integration_0"},{"heading":"Compute Shader Architecture","level":3,"id":"Compute_Shader_Architecture_0"},{"heading":"Workgroup Efficiency","level":3,"id":"Workgroup_Efficiency_0"},{"heading":"Performance Characteristics","level":2,"id":"Performance_Characteristics_0"},{"heading":"Scaling Characteristics","level":3,"id":"Scaling_Characteristics_0"},{"heading":"Memory Overhead","level":3,"id":"Memory_Overhead_0"},{"heading":"Activity Management","level":2,"id":"Activity_Management_0"},{"heading":"Activation Triggers","level":3,"id":"Activation_Triggers_0"},{"heading":"Deactivation Strategy","level":3,"id":"Deactivation_Strategy_0"},{"heading":"Edge Cases","level":3,"id":"Edge_Cases_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Physics Engine","level":3,"id":"Physics_Engine_0"},{"heading":"Reaction Engine","level":3,"id":"Reaction_Engine_0"},{"heading":"Spell System","level":3,"id":"Spell_System_0"},{"heading":"Technical Implementation","level":2,"id":"Technical_Implementation_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/core/active-regions.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506322,"modifiedTime":1760380506322,"sourceSize":4003,"sourcePath":"architecture/systems/core/active-regions.md","exportPath":"architecture/systems/core/active-regions.html","showInTree":true,"treeOrder":16,"backlinks":["architecture/systems/core/core.html"],"type":"markdown"},"architecture/systems/core/api-reference.html":{"title":"api-reference","icon":"","description":"Classes, interfaces, and integration points for the Core Engine system.⚠️ STATUS: API design has not been established yet. The following are suggestions for future design work.⚠️ SUGGESTION: Manages texture allocation and bit-packing operations.Potential Responsibilities:\nBit-packing and unpacking of tile data\nTexture allocation and memory management\nLayer-specific data access patterns\n⚠️ NEEDS DESIGN: Detailed method signatures and data structuresHandles ping-ponging and GPU synchronization.Responsibilities:\nTexture pair management for each layer\nPing-pong switching between frames\nGPU resource lifecycle management\nSynchronization barrier coordination\n⚠️ NEEDS DESIGN: WebGPU integration patterns and error handlingCoordinates frame execution pipeline across all modules.Responsibilities:\nFrame timing and execution order\nModule coordination and communication\nPerformance monitoring and bottleneck detection\n⚠️ NEEDS SPECIFICATION: Integration with different module update frequenciesOptimizes chunk-based processing across GPU modules.Responsibilities:\nActive chunk list management\nActivity propagation logic\nGPU buffer updates for active regions\nPerformance scaling based on activity\n⚠️ NEEDS SPECIFICATION: Activity detection and decay algorithmsRune Placement API:// Preliminary interface - subject to change\ninterface RunePlacementAPI { placeRune(position: TileCoord, rune: RuneData): void; removeRune(position: TileCoord): void; queryRune(position: TileCoord): RuneData | null;\n}\nVelocity Management API:// Preliminary interface - subject to change\ninterface VelocityAPI { setVelocity(position: TileCoord, velocity: Vector2): void; getVelocity(position: TileCoord): Vector2; applyForce(position: TileCoord, force: Vector2): void;\n}\nTile State API:// Preliminary interface - subject to change interface TileStateAPI { getTile(position: TileCoord, layer: LayerType): TileData; setTile(position: TileCoord, layer: LayerType, data: TileData): void; queryNeighborhood(center: TileCoord, radius: number): TileData[];\n}\nRead-Only Display API:// Preliminary interface - subject to change\ninterface DisplayAPI { getCurrentTileState(position: TileCoord): LayeredTileData; getVisibleRegion(viewport: Rectangle): TileData[]; subscribeToChanges(callback: (changes: TileChange[]) =&gt; void): void;\n}\n⚠️ NEEDS FINALIZATION: Specific bit allocation during implementation// Preliminary structure - bit allocation TBD\ninterface TileData { type: number; // ~6 bits - tile type identifier velocity: Vector2; // 16 bits - movement vector (signed) customData: number; // ~10 bits - health, timers, charges\n}\nenum LayerType { Ground = 0, // Terrain foundation Object = 1, // Interactive entities Air = 2, // Gases and effects Rune = 3 // Spell-placed effects\n}\ninterface TileCoord { x: number; y: number;\n} interface ChunkCoord { chunkX: number; chunkY: number;\n}\n⚠️ NEEDS DESIGN: Comprehensive error handling strategy for:\nGPU resource allocation failures\nWebGPU device lost scenarios Texture memory exhaustion\nInvalid tile coordinate access\nSynchronization failures\n⚠️ NEEDS IMPLEMENTATION: Built-in profiling capabilities for:\nFrame timing breakdown by module\nGPU utilization and memory bandwidth\nActive region processing efficiency\nTexture ping-pong overhead measurement WebGPU API: Core dependency for all GPU operations\nTypeScript: Type safety and development experience Integration with all other game modules\nShared type definitions across the codebase\nCommon utility functions and error types\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Core Engine API Reference","level":1,"id":"Core_Engine_API_Reference_0"},{"heading":"Core Classes","level":2,"id":"Core_Classes_0"},{"heading":"TileStorage","level":3,"id":"TileStorage_0"},{"heading":"TextureManager","level":3,"id":"TextureManager_0"},{"heading":"GameLoop","level":3,"id":"GameLoop_0"},{"heading":"ActiveRegionTracker","level":3,"id":"ActiveRegionTracker_0"},{"heading":"Integration Interfaces","level":2,"id":"Integration_Interfaces_0"},{"heading":"Spell System Integration","level":3,"id":"Spell_System_Integration_0"},{"heading":"Physics Engine Integration","level":3,"id":"Physics_Engine_Integration_0"},{"heading":"Reaction Engine Integration","level":3,"id":"Reaction_Engine_Integration_0"},{"heading":"Renderer Integration","level":3,"id":"Renderer_Integration_0"},{"heading":"Data Structures","level":2,"id":"Data_Structures_0"},{"heading":"TileData Format","level":3,"id":"TileData_Format_0"},{"heading":"LayerType Enumeration","level":3,"id":"LayerType_Enumeration_0"},{"heading":"TileCoord System","level":3,"id":"TileCoord_System_0"},{"heading":"Error Handling","level":2,"id":"Error_Handling_0"},{"heading":"Performance Monitoring","level":2,"id":"Performance_Monitoring_0"},{"heading":"Dependencies","level":2,"id":"Dependencies_0"},{"heading":"External Dependencies","level":3,"id":"External_Dependencies_0"},{"heading":"Internal Dependencies","level":3,"id":"Internal_Dependencies_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/core/api-reference.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506322,"modifiedTime":1760380506323,"sourceSize":4406,"sourcePath":"architecture/systems/core/api-reference.md","exportPath":"architecture/systems/core/api-reference.html","showInTree":true,"treeOrder":17,"backlinks":["architecture/systems/core/core.html"],"type":"markdown"},"architecture/systems/core/core.html":{"title":"core","icon":"","description":"Central coordination and tile data management for the Reaction v2 game engine.The Core Engine coordinates data flow between CPU spell logic and GPU simulation systems while maintaining high performance and deterministic execution.Key Challenge: Synchronize three different processing systems (CPU spells, GPU physics, GPU reactions) without race conditions or performance bottlenecks.\nBit-packed tile storage across 4 layers (Ground, Object, Air, Rune)\nGPU texture management with ping-ponging for race-condition prevention Active region optimization using 32×32 chunks\nFrame execution pipeline coordination <a class=\"internal-link\" data-href=\"tile-storage.md\" href=\"architecture/systems/core/tile-storage.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Tile Storage System - Bit-packing format and layer organization\n<br><a class=\"internal-link\" data-href=\"texture-management.md\" href=\"architecture/systems/core/texture-management.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Texture Management - GPU texture coordination and ping-ponging\n<br><a class=\"internal-link\" data-href=\"active-regions.md\" href=\"architecture/systems/core/active-regions.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Active Regions - Chunk-based processing optimization\n<br><a class=\"internal-link\" data-href=\"api-reference.md\" href=\"architecture/systems/core/api-reference.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>API Reference - Classes and integration points Ground Layer: Terrain foundation (dirt, stone, water)\nObject Layer: Interactive entities (rocks, trees, creatures, players)\nAir Layer: Gases and effects (fire, smoke, magic) Rune Layer: Spell-placed magical effects (temporary) Active Region System: Only process chunks with changing tiles\nTexture Ping-Ponging: Prevents GPU read-after-write hazards\nBit-Packed Storage: 32-bit tile representation\nChunk-Based Processing: 32×32 tile regions Spell System: Writes rune data to rune layer textures\nPhysics Engine: Reads/writes velocity data via texture pairs\nReaction Engine: Processes transformation rules on tile data Renderer: Provides read-only access to current tile states for display\nGame Logic: Exposes tile query API for validation and state checking WebGPU API: Required for texture management and GPU compute coordination\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Core Engine System","level":1,"id":"Core_Engine_System_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Core Responsibilities","level":2,"id":"Core_Responsibilities_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Components","level":3,"id":"Core_Components_0"},{"heading":"Key Technical Features","level":2,"id":"Key_Technical_Features_0"},{"heading":"Four-Layer Architecture","level":3,"id":"Four-Layer_Architecture_0"},{"heading":"Technical Features","level":3,"id":"Technical_Features_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Input Interfaces","level":3,"id":"Input_Interfaces_0"},{"heading":"Output Interfaces","level":3,"id":"Output_Interfaces_0"},{"heading":"Dependencies","level":2,"id":"Dependencies_0"}],"links":["architecture/systems/core/tile-storage.html","architecture/systems/core/texture-management.html","architecture/systems/core/active-regions.html","architecture/systems/core/api-reference.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/core/core.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506323,"modifiedTime":1760380506323,"sourceSize":2195,"sourcePath":"architecture/systems/core/core.md","exportPath":"architecture/systems/core/core.html","showInTree":true,"treeOrder":18,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/core/texture-management.html":{"title":"texture-management","icon":"","description":"GPU texture coordination and ping-ponging system for race-condition prevention.Challenge: Prevent GPU read-after-write hazards when multiple systems access the same tile data simultaneously.Solution: Texture ping-ponging using paired textures for each layer.Each layer uses paired textures (layer_A, layer_B) enabling GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards.\nRead Phase: Modules read from texture set A\nWrite Phase: Modules write to texture set B Swap Phase: Texture roles switch for next frame\nBarrier: GPU compute dispatch barriers ensure proper execution ordering\nFormat: r32uint for optimal GPU cache performance\nRationale: Single 32-bit channel matches bit-packed tile format2D Layout: Textures leverage GPU's optimized 2D memory access patterns\nSpatial Locality: Neighboring tiles often accessed together benefit from cache prefetching\nInput Processing: Reads from current texture set\nPhysics Pass: Writes to alternate texture set\nReaction Pass: Reads from physics output textures\nRender Pass: Reads from stable texture set for display\nActive Texture Tracking: Core Engine maintains current read/write texture assignments\nAutomatic Swapping: Texture roles alternate each frame automatically\nResource Cleanup: Proper GPU resource lifecycle management⚠️ NEEDS IMPLEMENTATION DETAIL: Specific WebGPU texture creation and binding patternsTrade-off: Double memory usage (2x textures per layer) for synchronization safety\nOptimization: Memory layout optimized for GPU architecture⚠️ NEEDS DESIGN: GPU resource allocation failure handling and recovery strategies\nRace Condition Prevention: Eliminates GPU synchronization hazards\nPipeline Operations: Allows overlapped read/write operations\nMemory Layout: 2D texture layout for spatial access patterns Memory Overhead: 2x memory usage per layer\nTexture Switching: Minimal GPU overhead for texture binding updates\n⚠️ NEEDS SPECIFICATION: Core classes and methods for texture managementPlanned Classes:\nTextureManager: Handles ping-ponging and synchronization TileStorage: Manages texture allocation and bit-packing\nIntegration with GameLoop for frame coordination\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Texture Management","level":1,"id":"Texture_Management_0"},{"heading":"Purpose","level":2,"id":"Purpose_0"},{"heading":"Ping-Ponging System","level":2,"id":"Ping-Ponging_System_0"},{"heading":"Dual Texture Approach","level":3,"id":"Dual_Texture_Approach_0"},{"heading":"Synchronization Flow","level":3,"id":"Synchronization_Flow_0"},{"heading":"Memory Layout","level":2,"id":"Memory_Layout_0"},{"heading":"Texture Format","level":3,"id":"Texture_Format_0"},{"heading":"Cache Optimization","level":3,"id":"Cache_Optimization_0"},{"heading":"Integration with Pipeline","level":2,"id":"Integration_with_Pipeline_0"},{"heading":"Frame Coordination","level":3,"id":"Frame_Coordination_0"},{"heading":"Buffer Management","level":3,"id":"Buffer_Management_0"},{"heading":"Technical Implementation","level":2,"id":"Technical_Implementation_0"},{"heading":"GPU Resource Management","level":3,"id":"GPU_Resource_Management_0"},{"heading":"Memory Constraints","level":3,"id":"Memory_Constraints_0"},{"heading":"Error Handling","level":3,"id":"Error_Handling_0"},{"heading":"Performance Characteristics","level":2,"id":"Performance_Characteristics_0"},{"heading":"Characteristics","level":3,"id":"Characteristics_0"},{"heading":"Costs","level":3,"id":"Costs_0"},{"heading":"API Design","level":2,"id":"API_Design_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/core/texture-management.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506323,"modifiedTime":1760380506324,"sourceSize":2796,"sourcePath":"architecture/systems/core/texture-management.md","exportPath":"architecture/systems/core/texture-management.html","showInTree":true,"treeOrder":19,"backlinks":["architecture/systems/core/core.html"],"type":"markdown"},"architecture/systems/core/tile-storage.html":{"title":"tile-storage","icon":"","description":"Problem: GPU shaders need packed data, but game logic needs flexible representations.Solution: Bit-packed 32-bit tiles stored in GPU textures.\nGround Layer: Terrain foundation (dirt, stone, water)\nObject Layer: Interactive entities (rocks, trees, creatures)\nAir Layer: Gases and effects (fire, smoke, magic) Rune Layer: Spell-placed magical effects (temporary)\nNote: Specific bit allocation TBD during implementation. Approximate layout:\nTile Type (~6 bits, chosen for comfortable headroom)\nVelocity X/Y (signed values for movement)\nCustom Data (remaining bits for health, timers, charges)\nTexture Ping-Ponging: Each layer uses paired textures (layer_A, layer_B) enabling GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards.Memory Layout: Textures use r32uint format for optimal GPU cache performance.Purpose: Avoid processing static regions to maintain performance.Implementation:\nDivide world into 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)\nTrack chunks with active tiles in GPU buffer\nShaders only process listed active chunks\nActivity propagates to neighboring chunks automatically\nDormant regions have minimal GPU cost TileStorage: Manages texture allocation and bit-packing\nTextureManager: Handles ping-ponging and synchronization\nGameLoop: Coordinates frame execution pipeline\nActiveRegionTracker: Optimizes chunk-based processing Spell System: Writes rune data to rune layer textures\nPhysics Engine: Reads/writes velocity data via texture pairs\nReaction Engine: Processes transformation rules on tile data\nRenderer: Reads current tile states for display\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Tile Storage System","level":1,"id":"Tile_Storage_System_0"},{"heading":"Purpose and Challenge","level":2,"id":"Purpose_and_Challenge_0"},{"heading":"Layer Architecture","level":2,"id":"Layer_Architecture_0"},{"heading":"Layer Organization","level":4,"id":"Layer_Organization_0"},{"heading":"Bit-Packing Format","level":4,"id":"Bit-Packing_Format_0"},{"heading":"Texture Management","level":3,"id":"Texture_Management_0"},{"heading":"Active Region System","level":3,"id":"Active_Region_System_0"},{"heading":"API Design","level":2,"id":"API_Design_0"},{"heading":"Core Classes","level":3,"id":"Core_Classes_0"},{"heading":"Integration Points","level":3,"id":"Integration_Points_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/core/tile-storage.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506324,"modifiedTime":1760380506324,"sourceSize":2010,"sourcePath":"architecture/systems/core/tile-storage.md","exportPath":"architecture/systems/core/tile-storage.html","showInTree":true,"treeOrder":20,"backlinks":["architecture/general/overview.html","architecture/systems/core/core.html"],"type":"markdown"},"architecture/systems/gpu/gpu.html":{"title":"gpu","icon":"","description":"Shared WebGPU resource management and coordination for all GPU-accelerated systems.The GPU Manager System manages the WebGPU instance, device initialization, and resource sharing across all systems that require GPU computation or rendering.Key Challenge: Coordinate GPU resource usage across multiple systems (Physics, Reactions, Renderer) while maintaining performance and preventing resource conflicts.\nWebGPU device initialization and capability detection\nGPU resource allocation and memory management\nCompute pipeline coordination between systems\nError handling and recovery for GPU operations\nPerformance monitoring and resource utilization tracking WebGPU Device: Single device instance shared across all systems\nBuffer Pools: Reusable buffer allocation for different data types\nTexture Management: Coordinate texture creation and lifecycle\nCompute Queue: Prioritized command queue for GPU operations Physics System: Provides compute shaders for collision and movement\nReactions System: Manages rule compilation and execution shaders Renderer: Coordinates rendering pipeline and display\nCore System: Integrates with texture ping-ponging and memory management Automatic Fallback: Handle WebGPU unavailability gracefully\nCapability Detection: Query and adapt to GPU limitations\nError Recovery: Robust handling of GPU context loss\nPerformance Profiling: Built-in GPU timing and resource monitoring Allocation Tracking: Monitor buffer and texture usage across systems\nMemory Optimization: Efficient sharing and reuse of GPU resources\nPriority Management: Coordinate competing GPU workloads\nSynchronization: Ensure proper ordering of GPU operations Device Setup: Initialize WebGPU device with required features\nSystem Registration: Allow systems to register their GPU requirements\nResource Allocation: Provide standardized buffer/texture allocation Command Submission: Centralized GPU command queue management\nResource Sharing: Safe sharing of buffers and textures between systems\nPerformance Monitoring: Real-time GPU utilization reporting WebGPU API: Required for all GPU operations\nBrowser/Platform: WebGPU support and capabilities\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"GPU Manager System","level":1,"id":"GPU_Manager_System_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Core Responsibilities","level":2,"id":"Core_Responsibilities_0"},{"heading":"Resource Management","level":2,"id":"Resource_Management_0"},{"heading":"Shared Resources","level":3,"id":"Shared_Resources_0"},{"heading":"System Integration","level":3,"id":"System_Integration_0"},{"heading":"Technical Features","level":2,"id":"Technical_Features_0"},{"heading":"Device Management","level":3,"id":"Device_Management_0"},{"heading":"Resource Coordination","level":3,"id":"Resource_Coordination_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Initialization Interface","level":3,"id":"Initialization_Interface_0"},{"heading":"Runtime Interface","level":3,"id":"Runtime_Interface_0"},{"heading":"Dependencies","level":2,"id":"Dependencies_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/gpu/gpu.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506324,"modifiedTime":1760380506324,"sourceSize":2656,"sourcePath":"architecture/systems/gpu/gpu.md","exportPath":"architecture/systems/gpu/gpu.html","showInTree":true,"treeOrder":22,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/multiplayer/client-prediction.html":{"title":"client-prediction","icon":"","description":"Local state prediction with rollback mechanisms for responsive gameplay despite network latency.⚠️ UPDATED SYSTEM: Client prediction now uses the unified Deterministic Time-Sliced Execution pipeline. See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/state-management.html\" data-href=\"state-management\" aria-label=\"state-management\" data-tooltip-position=\"top\" target=\"_self\">State Management</a> for complete integration details.Single Engine: Same game engine used for single-player and multiplayer prediction.Deterministic Execution: Time-sliced pipeline ensures identical client/server results.Automatic State Management: Built-in snapshots and rollback through unified state system.Frame Synchronization: Time slice alignment with server for precise synchronization.\nLocal state prediction using identical simulation logic\nServer state comparison with automatic mismrediction detection Rollback and re-execution through unified state management\nGhost simulation for action queue visualization\nPurpose: Runs identical simulation logic for local prediction.Components:\nSame GPU compute shaders as server\nPhysics and reaction processing\nTile state management with active regions\nDeterministic frame execution pipeline\nKey Differences:\nOperates on unconfirmed inputs\nGenerates visual output during prediction\nMaintains rollback state history\nHandles prediction correction smoothly\nConfirmed States: Server-validated game states stored every 5 frames\nPrediction States: Local simulation results with input applied\nRollback Threshold: Maximum 10 frames (167ms at 60 FPS)\nServer State Reception: Authoritative state update arrives\nLocal Comparison: Compare with predicted state at same frame\nDivergence Analysis: Identify significant differences\nRollback Decision: Determine if correction is necessary State Restoration: Revert to last confirmed server state\nInput Replay: Re-apply all inputs since that frame\nSimulation Catch-up: Run physics/reactions to current frame\nVisual Interpolation: Smooth transition to corrected state\nOwn Actions Only: Predict consequences of local player inputs\nPhysics Prediction: Tile movement and basic collisions\nSpell Effects: Immediate visual feedback for cast spells\nAvoid Complex Rules: Don't predict environmental transformationsAll Player Actions: Predict other players' likely actions\nRule Interactions: Attempt complex environmental predictions\nHigher Rollback Risk: More frequent corrections needed\nBetter Responsiveness: Smoother gameplay when predictions succeedNetwork Quality Based: Adjust strategy based on connection stability\nMisprediction History: Learn from previous prediction accuracy\nDynamic Threshold: Modify rollback sensitivity based on gameplay contextinterface PredictedInput { frameNumber: number; playerId: string; inputData: PlayerInput; timestamp: number; confirmed: boolean;\n} Local Input Capture: Player action registration\nImmediate Prediction: Apply to local simulation instantly\nServer Transmission: Send input with frame number\nConfirmation Tracking: Mark inputs as confirmed when server acknowledges\nHistory Cleanup: Remove old confirmed inputs from buffer\nInterpolation: Smooth transition between predicted and actual states\nTemporal Blending: Gradual adjustment over multiple frames\nPriority System: Prioritize corrections for player-controlled entitiesOptimistic Updates: Show immediate response to player actions\nUncertainty Indicators: Visual cues for unconfirmed actions\nRollback Masking: Hide jarring corrections with effectsSpatial Boundaries: Only predict within player's view range\nTemporal Limits: Maximum prediction window of 10 frames\nComplexity Filtering: Skip expensive calculations during predictionState Compression: Efficient storage of rollback snapshots\nGarbage Collection: Automatic cleanup of old prediction data\nGPU Resource Sharing: Reuse textures between prediction and renderingLatency Measurement: Dynamic adjustment of prediction window\nQuality Scaling: Reduce prediction complexity on slow connections\nFallback Mode: Disable prediction on extremely poor connectionsDesync Recovery: Full state resynchronization when prediction fails\nInput Loss: Request missing inputs from server\nState Corruption: Fallback to last known good stateConnection Loss: Maintain prediction until reconnection\nHigh Latency: Extend prediction window with quality reduction\nPacket Loss: Request state recovery from serverFrame Drops: Reduce prediction complexity automatically\nMemory Pressure: Cleanup old snapshots more aggressively\nGPU Issues: Fallback to CPU-only prediction if necessaryThis system provides responsive gameplay while maintaining competitive integrity through authoritative server validation.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Client Prediction System","level":1,"id":"Client_Prediction_System_0"},{"heading":"Prediction Architecture","level":2,"id":"Prediction_Architecture_0"},{"heading":"Unified Pipeline Integration","level":3,"id":"Unified_Pipeline_Integration_0"},{"heading":"Client Prediction Responsibilities","level":3,"id":"Client_Prediction_Responsibilities_0"},{"heading":"Prediction Engine","level":3,"id":"Prediction_Engine_0"},{"heading":"Rollback Mechanism","level":2,"id":"Rollback_Mechanism_0"},{"heading":"State Snapshot System","level":3,"id":"State_Snapshot_System_0"},{"heading":"Misprediction Detection","level":3,"id":"Misprediction_Detection_0"},{"heading":"Rollback Execution Process","level":3,"id":"Rollback_Execution_Process_0"},{"heading":"Prediction Strategies","level":2,"id":"Prediction_Strategies_0"},{"heading":"Conservative Prediction","level":3,"id":"Conservative_Prediction_0"},{"heading":"Aggressive Prediction","level":3,"id":"Aggressive_Prediction_0"},{"heading":"Adaptive Prediction","level":3,"id":"Adaptive_Prediction_0"},{"heading":"Input Management","level":2,"id":"Input_Management_0"},{"heading":"Input Buffer System","level":3,"id":"Input_Buffer_System_0"},{"heading":"Input Processing Pipeline","level":3,"id":"Input_Processing_Pipeline_0"},{"heading":"Visual Smoothing","level":2,"id":"Visual_Smoothing_0"},{"heading":"Prediction Correction","level":3,"id":"Prediction_Correction_0"},{"heading":"Visual Feedback","level":3,"id":"Visual_Feedback_0"},{"heading":"Performance Optimization","level":2,"id":"Performance_Optimization_0"},{"heading":"Prediction Scope Limiting","level":3,"id":"Prediction_Scope_Limiting_0"},{"heading":"Memory Management","level":3,"id":"Memory_Management_0"},{"heading":"Network Adaptation","level":3,"id":"Network_Adaptation_0"},{"heading":"Error Handling","level":2,"id":"Error_Handling_0"},{"heading":"Prediction Failures","level":3,"id":"Prediction_Failures_0"},{"heading":"Network Issues","level":3,"id":"Network_Issues_0"},{"heading":"Performance Degradation","level":3,"id":"Performance_Degradation_0"}],"links":["architecture/general/state-management.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/client-prediction.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506325,"modifiedTime":1760380506325,"sourceSize":5622,"sourcePath":"architecture/systems/multiplayer/client-prediction.md","exportPath":"architecture/systems/multiplayer/client-prediction.html","showInTree":true,"treeOrder":24,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/multiplayer/deployment.html":{"title":"deployment","icon":"","description":"Container orchestration, regional deployment, and horizontal scaling infrastructure for multiplayer servers.Docker Configuration:\nNVIDIA Docker runtime for GPU support\nUbuntu base image with WebGPU drivers\nNode.js runtime with GPU-accelerated libraries\nMinimal attack surface with only required packages\nContainer Specifications:FROM nvidia/ubuntu:22.04\nRUN apt-get update &amp;&amp; apt-get install -y \\ nodejs npm \\ nvidia-driver-525 \\ vulkan-utils\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY dist/ ./dist/\nEXPOSE 8080\nCMD [\"node\", \"dist/server.js\"]\nResource Requirements:\n4 vCPU cores per game server instance\n16GB RAM per server (supports 8-12 concurrent games)\nNVIDIA T4 or equivalent GPU (4GB VRAM minimum)\n1Gbps network interface\nKubernetes Deployment:\nPod scheduling with GPU node affinity\nHorizontal Pod Autoscaler based on CPU/GPU utilization\nService mesh for inter-service communication\nConfigMap and Secret management for configuration\nAlternative: Docker Swarm:\nSimpler orchestration for smaller deployments\nBuilt-in load balancing and service discovery\nGPU resource constraints and placement\nRolling updates with zero-downtime deployment\nPrimary Regions:\nNorth America (East/West Coast)\nEurope (Frankfurt, London)\nAsia-Pacific (Singapore, Tokyo)\nOptional: South America, Australia\nRegion Selection Criteria:\nPlayer population density\nNetwork infrastructure quality\nData sovereignty requirements\nCost optimization opportunities\nMatchmaking Service:\nGlobal player queue management\nRegion assignment based on latency\nCross-region backup for peak times\nLoad balancing across regional clusters\nData Synchronization:\nPlayer profiles and statistics\nMatch history and replay data\nConfiguration and rule updates\nSecurity blacklists and ban information\nAuto-Scaling Configuration:apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata: name: game-server-hpa\nspec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: game-server minReplicas: 3 maxReplicas: 50 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 - type: Resource resource: name: nvidia.com/gpu target: type: Utilization averageUtilization: 80\nScaling Triggers:\nCPU utilization &gt;70%\nGPU utilization &gt;80%\nMemory usage &gt;85%\nQueue length &gt;100 waiting players\nAverage response time &gt;100ms\nResource Optimization:\nGPU memory pooling across game instances\nCPU allocation based on actual usage patterns\nMemory tuning for garbage collection optimization\nNetwork bandwidth allocation per game\nPerformance Monitoring:\nReal-time resource utilization tracking\nApplication performance monitoring (APM)\nCustom metrics for game-specific performance\nAlerting for performance degradation\nCore Services:interface ServiceArchitecture { gameServer: GameServerService; // Game simulation and state matchmaker: MatchmakingService; // Player matching and queuing authentication: AuthService; // Player authentication statistics: StatsService; // Match history and analytics configuration: ConfigService; // Game rules and settings\n}\nService Communication:\ngRPC for internal service communication\nRedis for shared state and caching\nMessage queues for asynchronous processing\nService mesh for secure inter-service communication\nApplication Load Balancer:\nSession affinity for WebSocket connections\nHealth check integration with Kubernetes\nGeographic routing for optimal latency\nSSL termination and certificate management\nGame Server Load Balancing:\nConsistent hashing for player assignment\nCapacity-based routing\nFailover to backup servers\nGraceful shutdown with player migration\nGame State: Redis cluster for real-time state\nPlayer Data: PostgreSQL for persistent player information\nAnalytics: ClickHouse for match statistics and telemetry\nConfiguration: etcd for distributed configuration managementMatch Replays:\nCompressed binary format for efficiency\nObject storage (S3/GCS) for long-term archival\nCDN distribution for replay downloads\nRetention policy with automatic cleanup\nPlayer Profiles:\nDistributed across regions for performance\nEventual consistency for non-critical data\nBackup and disaster recovery procedures\nGDPR compliance for data deletion\nBuild Pipeline:\nSource code compilation and TypeScript checking\nUnit and integration test execution\nDocker image building with security scanning\nImage tagging and registry push\nDeployment manifest generation\nDeployment Strategy:\nBlue-green deployment for zero-downtime updates\nCanary releases for gradual rollout\nFeature flags for controlled feature releases\nAutomated rollback on deployment failures\nDevelopment Environment:\nSingle-region deployment with minimal resources\nMock services for external dependencies\nDebug logging and development tools\nRapid iteration and testing capabilities\nStaging Environment:\nProduction-like configuration with reduced scale\nFull integration testing\nPerformance and load testing\nSecurity vulnerability scanning\nProduction Environment:\nMulti-region deployment with full redundancy\nComprehensive monitoring and alerting\nSecurity hardening and compliance\nDisaster recovery procedures\nSystem Metrics:\nCPU, memory, GPU utilization per node\nNetwork throughput and latency\nDisk I/O and storage utilization\nContainer resource consumption\nApplication Metrics:\nGame server response times\nPlayer connection counts\nMatch completion rates\nError rates and exceptions\nCritical Alerts:\nService downtime or unreachability\nHigh error rates (&gt;5% of requests)\nResource exhaustion warnings\nSecurity incident detection\nPerformance Alerts:\nLatency degradation (&gt;100ms p95)\nGPU utilization spikes (&gt;90%)\nMemory pressure warnings\nNetwork congestion detection\nCentralized Logging:\nELK Stack (Elasticsearch, Logstash, Kibana) or equivalent\nStructured logging with correlation IDs\nLog aggregation from all services\nLong-term log retention for compliance\nSecurity Logging:\nAuthentication and authorization events\nSuspicious activity detection\nSecurity incident correlation\nAudit trail for compliance requirements\nData Backup:\nAutomated database backups with point-in-time recovery\nGame state snapshots for active matches\nConfiguration backup and version control\nCross-region replication for critical data\nRecovery Procedures:\nRecovery Time Objective (RTO): 15 minutes\nRecovery Point Objective (RPO): 5 minutes\nAutomated failover for database services\nManual intervention procedures for complex failures\nService Redundancy:\nMulti-region deployment with active-active configuration\nAutomatic traffic rerouting during outages\nGraceful degradation during partial failures\nCommunication plan for extended outages\nThis deployment architecture provides scalable, reliable multiplayer infrastructure capable of supporting global competitive gameplay with minimal latency and maximum uptime.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Deployment Architecture","level":1,"id":"Deployment_Architecture_0"},{"heading":"Infrastructure Overview","level":2,"id":"Infrastructure_Overview_0"},{"heading":"Container Strategy","level":3,"id":"Container_Strategy_0"},{"heading":"Orchestration Platform","level":3,"id":"Orchestration_Platform_0"},{"heading":"Regional Architecture","level":2,"id":"Regional_Architecture_0"},{"heading":"Global Distribution","level":3,"id":"Global_Distribution_0"},{"heading":"Cross-Region Coordination","level":3,"id":"Cross-Region_Coordination_0"},{"heading":"Scaling Strategy","level":2,"id":"Scaling_Strategy_0"},{"heading":"Horizontal Scaling","level":3,"id":"Horizontal_Scaling_0"},{"heading":"Vertical Scaling","level":3,"id":"Vertical_Scaling_0"},{"heading":"Service Architecture","level":2,"id":"Service_Architecture_0"},{"heading":"Microservices Design","level":3,"id":"Microservices_Design_0"},{"heading":"Load Balancing","level":3,"id":"Load_Balancing_0"},{"heading":"Database Architecture","level":2,"id":"Database_Architecture_0"},{"heading":"Data Storage Strategy","level":3,"id":"Data_Storage_Strategy_0"},{"heading":"Data Persistence","level":3,"id":"Data_Persistence_0"},{"heading":"Deployment Pipeline","level":2,"id":"Deployment_Pipeline_0"},{"heading":"CI/CD Strategy","level":3,"id":"CI/CD_Strategy_0"},{"heading":"Environment Management","level":3,"id":"Environment_Management_0"},{"heading":"Monitoring and Alerting","level":2,"id":"Monitoring_and_Alerting_0"},{"heading":"Infrastructure Monitoring","level":3,"id":"Infrastructure_Monitoring_0"},{"heading":"Alerting Strategy","level":3,"id":"Alerting_Strategy_0"},{"heading":"Log Management","level":3,"id":"Log_Management_0"},{"heading":"Disaster Recovery","level":2,"id":"Disaster_Recovery_0"},{"heading":"Backup Strategy","level":3,"id":"Backup_Strategy_0"},{"heading":"Business Continuity","level":3,"id":"Business_Continuity_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/deployment.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506325,"modifiedTime":1760380506325,"sourceSize":8009,"sourcePath":"architecture/systems/multiplayer/deployment.md","exportPath":"architecture/systems/multiplayer/deployment.html","showInTree":true,"treeOrder":25,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/multiplayer/multiplayer.html":{"title":"multiplayer","icon":"","description":"Real-time PvP multiplayer architecture using authoritative servers with client-side prediction.The multiplayer system leverages Reaction's deterministic engine design to enable competitive real-time gameplay. An authoritative server runs the identical simulation while clients predict local actions to maintain responsive gameplay.Authoritative game simulation with GPU-accelerated processing identical to client engine.Local state prediction with rollback mechanisms for responsive gameplay despite network latency.WebSocket-based communication with optimized state synchronization and delta compression.Bandwidth optimization, server scaling, and latency management strategies.Input validation, state integrity, and cheat detection systems.Container orchestration, regional deployment, and horizontal scaling infrastructure.Core Engine Integration\nServer runs headless version of identical simulation\nLeverages existing GPU compute shaders for physics and reactions\nUses bit-packed tile format for efficient network transmission\nDeterministic Design Benefits\nInteger-only mathematics ensures identical client/server results\nStrict execution order enables reliable rollback mechanisms\nActive region system scales network bandwidth with activity level\nWebGPU Compatibility\nServer requires GPU-capable infrastructure\nCompute shaders run identically on both client and server\nTexture ping-ponging system adapted for network synchronization Core Networking: WebSocket protocol and basic state synchronization\nServer Engine: Headless game engine with GPU compute capabilities\nClient Prediction: Local state management with rollback\nPerformance: Bandwidth compression and server scaling\nSecurity: Anti-cheat and input validation systems\nServer Infrastructure\nGPU-capable servers (NVIDIA T4 or equivalent)\nWebGPU-compatible Node.js environment\n16GB RAM per game instance (4-8 players)\nPerformance Targets\n60 FPS authoritative simulation\n&lt;50ms input processing latency\n&lt;16MB bandwidth per player per minute\nSupport 100+ concurrent matches per server\nThis architecture provides competitive multiplayer performance while building on Reaction's existing deterministic engine design.","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Multiplayer System","level":1,"id":"Multiplayer_System_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Architecture Components","level":2,"id":"Architecture_Components_0"},{"heading":"<a class=\"internal-link\" data-href=\"server-architecture.md\" href=\"server-architecture.md\" target=\"_blank\" rel=\"noopener nofollow\">Server Architecture</a>","level":3,"id":"[Server_Architecture](server-architecture.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"client-prediction.md\" href=\"client-prediction.md\" target=\"_blank\" rel=\"noopener nofollow\">Client Prediction</a>","level":3,"id":"[Client_Prediction](client-prediction.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"network-protocol.md\" href=\"network-protocol.md\" target=\"_blank\" rel=\"noopener nofollow\">Network Protocol</a>","level":3,"id":"[Network_Protocol](network-protocol.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"performance.md\" href=\"performance.md\" target=\"_blank\" rel=\"noopener nofollow\">Performance Optimization</a>","level":3,"id":"[Performance_Optimization](performance.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"security.md\" href=\"security.md\" target=\"_blank\" rel=\"noopener nofollow\">Security &amp; Anti-Cheat</a>","level":3,"id":"[Security_&_Anti-Cheat](security.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"deployment.md\" href=\"deployment.md\" target=\"_blank\" rel=\"noopener nofollow\">Deployment Architecture</a>","level":3,"id":"[Deployment_Architecture](deployment.md)_0"},{"heading":"Integration with Core Systems","level":2,"id":"Integration_with_Core_Systems_0"},{"heading":"Development Priority","level":2,"id":"Development_Priority_0"},{"heading":"Technical Requirements","level":2,"id":"Technical_Requirements_0"}],"links":["architecture/systems/multiplayer/server-architecture.html","architecture/systems/multiplayer/client-prediction.html","architecture/systems/multiplayer/network-protocol.html","architecture/systems/multiplayer/performance.html","architecture/systems/multiplayer/security.html","architecture/systems/multiplayer/deployment.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/multiplayer.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506326,"modifiedTime":1760380506326,"sourceSize":2734,"sourcePath":"architecture/systems/multiplayer/multiplayer.md","exportPath":"architecture/systems/multiplayer/multiplayer.html","showInTree":true,"treeOrder":26,"backlinks":["architecture/general/state-management.html","architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/multiplayer/network-protocol.html":{"title":"network-protocol","icon":"","description":"WebSocket-based communication protocol with optimized state synchronization and delta compression.WebSocket Connection: Persistent bidirectional communication\nMessage Format: Binary protocol with structured headers\nCompression: LZ4 compression for large state updates\nReliability: Application-level acknowledgments and retransmission\nInput Messages: Client actions (spell casts, movement)\nState Updates: Server game state changes\nControl Messages: Connection management and metadata\nHeartbeat Messages: Connection health monitoring\ninterface NetworkMessage { type: MessageType; frameNumber: number; playerId: string; sequence: number; timestamp: number; checksum: number; payload: MessagePayload;\n}\ninterface SpellCastInput { spellId: number; targetX: number; targetY: number; manaType: ManaType;\n} interface MovementInput { direction: number; // 8-directional movement intensity: number; // 0-255 for analog input\n} interface SpellSelectInput { spellIndex: number; handPosition: number;\n}\ninterface TileDelta { x: number; y: number; layer: Layer; oldTile: number; // bit-packed tile data newTile: number; // bit-packed tile data\n} interface PlayerUpdate { playerId: string; positionX: number; positionY: number; health: number; manaLevels: number[]; // array of mana amounts\n} interface FullStateSnapshot { frameNumber: number; tileData: Uint32Array; // complete world state playerStates: PlayerUpdate[]; activeChunks: ChunkCoord[];\n}\nChange Detection: Only transmit modified tiles per frame\nRun-Length Encoding: Compress sequences of identical tiles\nBit-Packing Efficiency: Leverage existing 32-bit tile format\nEstimated Savings: 90% bandwidth reduction vs full stateChunk-Based Updates: Leverage 32×32 active region system\nSpatial Compression: Group changes by geographic proximity\nActivity Propagation: Automatic chunk activation/deactivation\nBandwidth Scaling: Linear with activity level, not world sizeLZ4 Algorithm: Fast compression/decompression for real-time use\nAdaptive Compression: Skip compression for small messages\nDictionary Building: Maintain compression context across framesInput Messages: Send immediately on player action\nState Deltas: Every frame (16.67ms at 60 FPS)\nFull Snapshots: Every 60 frames (1 second) for recovery\nHeartbeat: Every 5 seconds for connection monitoringSequence Numbers: Detect missing or duplicate messages\nAcknowledgment System: Confirm receipt of critical updates\nRetransmission: Resend lost messages with exponential backoff\nRecovery Mode: Request full state snapshot on desyncCritical Updates: Player health, elimination, match state\nHigh Priority: Direct player actions and immediate consequences\nMedium Priority: Environmental changes and rule effects\nLow Priority: Cosmetic updates and distant tile changes\nClient Connection: WebSocket establishment\nAuthentication: Player credentials and session validation\nGame Joining: Match assignment and initial state transfer\nSynchronization: Frame alignment and latency measurement\nLatency Measurement: Round-trip time calculation\nBandwidth Detection: Adaptive compression and update frequency\nConnection Quality: Network stability monitoring\nFallback Modes: Reduced fidelity on poor connectionsGraceful Disconnect: Planned disconnection with state preservation\nTimeout Detection: Automatic disconnection after communication failure\nReconnection: Resume gameplay with state synchronization\nGhost Mode: Temporary AI control during brief disconnectionsTarget Bandwidth: &lt;16MB per player per minute\nPeak Optimization: Burst protection during high-activity periods\nRegional Scaling: Reduced updates for distant regions\nPredictive Filtering: Skip redundant state updatesMessage Batching: Combine multiple updates per frame\nPredictive Transmission: Send likely state changes early\nCompression Caching: Reuse compression dictionaries\nPriority Queuing: Critical messages bypass normal queue// Efficient tile delta encoding\ninterface CompressedTileDelta { chunkId: number; // 16 bits - chunk identifier relativeTiles: number; // 10 bits - tiles changed in chunk deltaData: Uint8Array; // variable length - compressed changes\n}\nInput Sanitization: Validate all client inputs against game rules\nRange Checking: Ensure coordinates and values within bounds\nRate Limiting: Prevent input flooding and spam\nChecksum Verification: Detect message corruption or tamperingMessage Signing: Cryptographic signatures for critical messages\nSequence Validation: Detect replay attacks and message injection\nTiming Verification: Validate message timestamps against server time\nState Integrity: Server-side validation of all game state changesTLS Encryption: Secure WebSocket connections (WSS)\nSession Management: Secure token-based authentication\nDoS Protection: Rate limiting and connection throttling\nIP Filtering: Geographic and reputation-based access controlThis protocol provides efficient, reliable communication optimized for Reaction's real-time gameplay requirements while maintaining competitive integrity.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Network Protocol","level":1,"id":"Network_Protocol_0"},{"heading":"Protocol Overview","level":2,"id":"Protocol_Overview_0"},{"heading":"Transport Layer","level":3,"id":"Transport_Layer_0"},{"heading":"Message Types","level":3,"id":"Message_Types_0"},{"heading":"Message Structure","level":2,"id":"Message_Structure_0"},{"heading":"Base Message Format","level":3,"id":"Base_Message_Format_0"},{"heading":"Input Message Types","level":3,"id":"Input_Message_Types_0"},{"heading":"State Update Types","level":3,"id":"State_Update_Types_0"},{"heading":"Compression Strategy","level":2,"id":"Compression_Strategy_0"},{"heading":"Tile Delta Compression","level":3,"id":"Tile_Delta_Compression_0"},{"heading":"Active Region Optimization","level":3,"id":"Active_Region_Optimization_0"},{"heading":"Payload Compression","level":3,"id":"Payload_Compression_0"},{"heading":"State Synchronization","level":2,"id":"State_Synchronization_0"},{"heading":"Update Frequency","level":3,"id":"Update_Frequency_0"},{"heading":"Reliability Mechanism","level":3,"id":"Reliability_Mechanism_0"},{"heading":"Priority System","level":3,"id":"Priority_System_0"},{"heading":"Connection Management","level":2,"id":"Connection_Management_0"},{"heading":"Handshake Protocol","level":3,"id":"Handshake_Protocol_0"},{"heading":"Quality Adaptation","level":3,"id":"Quality_Adaptation_0"},{"heading":"Disconnection Handling","level":3,"id":"Disconnection_Handling_0"},{"heading":"Performance Optimization","level":2,"id":"Performance_Optimization_0"},{"heading":"Bandwidth Management","level":3,"id":"Bandwidth_Management_0"},{"heading":"Latency Optimization","level":3,"id":"Latency_Optimization_0"},{"heading":"Network Efficiency","level":3,"id":"Network_Efficiency_0"},{"heading":"Security Considerations","level":2,"id":"Security_Considerations_0"},{"heading":"Message Validation","level":3,"id":"Message_Validation_0"},{"heading":"Anti-Tampering","level":3,"id":"Anti-Tampering_0"},{"heading":"Connection Security","level":3,"id":"Connection_Security_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/network-protocol.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506326,"modifiedTime":1760380506326,"sourceSize":6107,"sourcePath":"architecture/systems/multiplayer/network-protocol.md","exportPath":"architecture/systems/multiplayer/network-protocol.html","showInTree":true,"treeOrder":27,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/multiplayer/performance.html":{"title":"performance","icon":"","description":"Bandwidth optimization, server scaling, and latency management strategies for multiplayer infrastructure.Simulation Requirements:\n60 FPS authoritative simulation per game instance\nReal-time response to player input\nSupport multiple players per game instance\nMaintain responsive gameplay experience\nScaling Goals:\nSupport multiple concurrent matches per server\nEfficient bandwidth utilization\nMinimize network latency\nHigh availability for players\nPrediction Requirements:\nMaintain smooth 60 FPS gameplay\nMinimize rollback disruptions\nLow prediction processing overhead\nSeamless visual experience during corrections\nHeadless Rendering Optimization:\nSkip visual pipeline entirely\nRetain compute shaders for physics and reactions\nOptimize GPU memory allocation for multiple instances\nImplement texture pooling across game instances\nMemory Optimization:\nPool GPU textures and buffers across instances\nShare compute pipelines between games\nOptimize memory allocation for multiple instances\nMinimize GPU memory fragmentation\nBatch Processing:\nProcess multiple game instances on single GPU context\nOptimize GPU command buffer submissions\nMinimize GPU state changes between instances\nImplement efficient GPU-CPU synchronization\nInput Processing:\nBatch input validation across multiple players\nOptimize network message deserialization\nImplement efficient player state updates\nMinimize context switching between game instances\nMemory Management:\nOptimize memory allocation patterns\nReduce garbage collection overhead\nEfficient state history management\nPool frequently used objects\nBandwidth Reduction:\nActive region delta compression (90% reduction)\nPredictive state filtering\nSpatial proximity optimization\nTemporal coherence exploitation\nLatency Reduction:\nRegional server deployment\nCDN integration for initial state\nPredictive message transmission\nConnection pooling and reuse\nInstance Management:\nStateless game servers for easy scaling\nLoad balancing based on server utilization\nDynamic instance spawning during peak hours\nGraceful shutdown and player migration\nResource Management:\nMonitor server capacity and utilization\nBalance load across available resources\nTrack GPU, memory, and network usage\nScale instances based on demand\nResource Monitoring:\nReal-time GPU utilization tracking\nMemory pressure detection and management\nCPU bottleneck identification\nNetwork bandwidth monitoring\nAdaptive Quality:\nReduce simulation fidelity under load\nDynamic update frequency adjustment\nSelective feature disabling during peaks\nGraceful degradation strategies\nRegional Deployment:\nMultiple data centers for global coverage\nPlayer assignment based on latency testing\nCross-region backup for failover\nEdge computing for input processing\nProtocol Optimization:\nUDP consideration for non-critical updates\nMessage priority queuing\nBatch transmission optimization\nConnection quality adaptation\nClient-Side Optimization:\nMinimize prediction processing overhead\nEfficient rollback state management\nOptimized visual interpolation\nPredictive input handling\nNetwork Adaptation:\nMonitor connection quality metrics\nAdjust prediction windows based on latency\nAdapt update frequencies to network conditions\nHandle packet loss gracefully\nTile Delta Compression:\nRun-length encoding for similar tiles\nBit-field optimization for tile changes\nSpatial compression for clustered updates\nTemporal compression for predictable patterns\nState Synchronization:\nDifferential state encoding\nChunk-based update grouping\nPriority-based transmission\nRedundancy elimination\nConnection Quality Detection:\nBandwidth measurement and adaptation\nQuality of service monitoring\nCongestion avoidance algorithms\nFallback mode implementation\nTraffic Shaping:\nRate limiting per connection\nBurst protection mechanisms\nPriority queuing for critical updates\nLoad balancing across connections\nServer Monitoring:\nTrack frame processing performance\nMonitor GPU and memory utilization\nMeasure network throughput and connections\nCount active game instances\nClient Monitoring:\nMeasure prediction accuracy and rollbacks\nTrack network latency and frame drops\nMonitor bandwidth consumption\nAssess user experience quality\nAutomated Analysis:\nPerformance regression detection\nCapacity planning based on usage patterns\nPredictive scaling triggers\nAnomaly detection for performance issues\nOptimization Feedback:\nA/B testing for optimization strategies\nPerformance impact measurement\nUser experience correlation\nContinuous improvement cycles\nContainer Optimization:\nMinimal Docker images for game servers\nGPU-optimized container runtime\nEfficient resource allocation\nFast startup and shutdown times\nResource Utilization:\nPack multiple game instances per server\nOptimize GPU memory sharing\nMinimize idle resource consumption\nDynamic resource allocation\nPerformance Alerts:\nLatency threshold violations\nResource utilization warnings\nCapacity planning notifications\nService degradation detection\nAutomated Responses:\nAuto-scaling based on demand\nFailover to backup servers\nLoad rebalancing during issues\nPerformance optimization triggers\nThis comprehensive performance strategy ensures smooth multiplayer gameplay while maintaining cost-effective server operations.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Performance Optimization","level":1,"id":"Performance_Optimization_0"},{"heading":"Performance Goals","level":2,"id":"Performance_Goals_0"},{"heading":"Server Performance Goals","level":3,"id":"Server_Performance_Goals_0"},{"heading":"Client Performance Goals","level":3,"id":"Client_Performance_Goals_0"},{"heading":"Server Optimization Strategies","level":2,"id":"Server_Optimization_Strategies_0"},{"heading":"GPU Resource Management","level":3,"id":"GPU_Resource_Management_0"},{"heading":"CPU Optimization","level":3,"id":"CPU_Optimization_0"},{"heading":"Network Optimization","level":3,"id":"Network_Optimization_0"},{"heading":"Scaling Architecture","level":2,"id":"Scaling_Architecture_0"},{"heading":"Horizontal Scaling","level":3,"id":"Horizontal_Scaling_0"},{"heading":"Vertical Scaling","level":3,"id":"Vertical_Scaling_0"},{"heading":"Latency Management","level":2,"id":"Latency_Management_0"},{"heading":"Network Latency Optimization","level":3,"id":"Network_Latency_Optimization_0"},{"heading":"Prediction Latency","level":3,"id":"Prediction_Latency_0"},{"heading":"Bandwidth Optimization","level":2,"id":"Bandwidth_Optimization_0"},{"heading":"Compression Strategies","level":3,"id":"Compression_Strategies_0"},{"heading":"Adaptive Bandwidth","level":3,"id":"Adaptive_Bandwidth_0"},{"heading":"Performance Monitoring","level":2,"id":"Performance_Monitoring_0"},{"heading":"Real-Time Metrics","level":3,"id":"Real-Time_Metrics_0"},{"heading":"Bottleneck Detection","level":3,"id":"Bottleneck_Detection_0"},{"heading":"Deployment Optimization","level":2,"id":"Deployment_Optimization_0"},{"heading":"Infrastructure Efficiency","level":3,"id":"Infrastructure_Efficiency_0"},{"heading":"Monitoring and Alerting","level":3,"id":"Monitoring_and_Alerting_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/performance.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506327,"modifiedTime":1760380506327,"sourceSize":6185,"sourcePath":"architecture/systems/multiplayer/performance.md","exportPath":"architecture/systems/multiplayer/performance.html","showInTree":true,"treeOrder":28,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/multiplayer/security.html":{"title":"security","icon":"","description":"Input validation, state integrity, and cheat detection systems for competitive multiplayer security.Authoritative Validation: All game-affecting decisions made on server\nInput Processing: Client inputs validated against current game state\nState Enforcement: Server never trusts client-reported game state\nDamage Calculation: All combat calculations performed server-sideAuthority Boundaries:\nServer: Health, mana, spell effects, tile transformations\nClient: UI interactions, prediction, visual effects\nValidated: Movement inputs, spell targeting, timing\nZero-Trust Client Model: Assume all client data is potentially malicious\nValidation Layers: Multiple verification stages for critical operations\nState Reconciliation: Continuous comparison of client predictions with server realityinterface InputValidation { syntaxCheck: boolean; // Message format validity rangeCheck: boolean; // Coordinate and value bounds gameRuleCheck: boolean; // Legal according to current state timingCheck: boolean; // Within expected timing windows rateCheck: boolean; // Not exceeding rate limits\n}\nMana Verification: Server tracks actual mana levels independently\nTargeting Validation: Ensure spell targets are within range and line-of-sight\nCooldown Enforcement: Server-side spell cooldown tracking\nRule Compliance: Validate spell effects against current game rulesExample Validation:function validateSpellCast(input: SpellCastInput, gameState: GameState): ValidationResult { // Check mana availability if (gameState.playerMana[input.playerId] &lt; spell.manaCost) { return { valid: false, reason: \"Insufficient mana\" }; } // Validate targeting if (!isValidTarget(input.target, gameState.playerPosition[input.playerId])) { return { valid: false, reason: \"Invalid target\" }; } // Check cooldowns if (gameState.spellCooldowns[input.playerId][input.spellId] &gt; 0) { return { valid: false, reason: \"Spell on cooldown\" }; } return { valid: true };\n}\nPosition Bounds: Ensure movement stays within world boundaries\nPhysics Constraints: Validate movement against physics simulation\nSpeed Limits: Enforce maximum movement speeds\nCollision Detection: Prevent movement through solid tilesInput Frequency: Maximum inputs per second per player\nSpell Casting Rate: Prevent rapid-fire spell casting\nConnection Limits: Maximum connections per IP address\nBandwidth Throttling: Prevent network floodingChecksum Verification: Regular state checksums between server instances\nReplay Validation: Ability to replay matches for verification\nCross-Instance Checking: Multiple servers validate critical calculations\nInteger-Only Mathematics: Prevent floating-point determinism issuesinterface StateIntegrityCheck { playerHealthSum: number; totalManaInWorld: number; tileTypeDistribution: Map&lt;TileType, number&gt;; activeRuneCount: number; frameChecksum: number;\n}\nImpossible State Detection: Identify states that violate game physics\nStatistical Analysis: Detect patterns that suggest cheating\nPerformance Anomalies: Identify suspiciously perfect play patterns\nNetwork Timing Analysis: Detect inhuman reaction timesInput Analysis:\nTiming analysis for inhuman precision\nPattern recognition for bot behavior\nStatistical analysis of success rates\nConsistency checking across sessions\nState Validation:\nImpossible game state detection\nResource tracking (mana, health)\nPosition validation and teleport detection\nDamage calculation verification\nPerformance Fingerprinting:\nHardware capability profiling\nRender timing analysis\nInput device characteristics\nSystem performance patterns\nBehavior Analysis:\nMouse movement patterns\nReaction time distributions\nDecision-making patterns\nPlay style consistency\nSpeed Hacking: Movement faster than physics allows\nTeleportation: Position changes without valid movement\nResource Manipulation: Invalid mana or health values\nInformation Cheating: Actions suggesting knowledge of hidden information\nAutomation: Bot-like behavior patterns\nNetwork Manipulation: Lag switching or packet manipulationTLS Encryption: All WebSocket connections use WSS protocol\nCertificate Validation: Proper SSL certificate verification\nSession Management: Secure token-based authentication\nIP Reputation: Block known malicious IP addressesRate Limiting: Connection and message rate limits\nGeographic Filtering: Restrict connections by region if needed\nTraffic Analysis: Detect and mitigate attack patterns\nLoad Balancing: Distribute traffic across multiple serversMessage Authentication: Cryptographic signatures for critical messages\nReplay Attack Prevention: Timestamp and sequence number validation\nMan-in-the-Middle Protection: Certificate pinning where appropriate\nSession Hijacking Prevention: Secure session token managementImmediate Actions:\nFlag suspicious activity for review\nIncrease monitoring for flagged players\nCollect evidence for manual review\nApply temporary restrictions if necessary\nInvestigation Process:\nAutomated evidence collection\nManual review by security team\nPlayer interview if needed\nFinal determination and action\nEnforcement Actions:\nWarning for minor violations\nTemporary suspension for moderate violations\nPermanent ban for severe violations\nHardware ID banning for repeat offenders\nBreach Detection: Automated monitoring for security compromises\nResponse Team: Dedicated security incident response team\nCommunication Plan: Player notification for security issues\nRecovery Procedures: Service restoration after security incidentsReplay System: Complete match recordings for investigation\nLog Aggregation: Centralized logging for security analysis\nPlayer Behavior History: Long-term behavioral pattern tracking\nSystem State Snapshots: Capture game state during suspicious eventsMinimal Data Collection: Only collect data necessary for security\nData Retention: Automatic deletion of old security logs\nPlayer Privacy: Protect personal information during investigations\nConsent Management: Clear privacy policy for security monitoringAppeals Process: Fair system for contested security actions\nEvidence Disclosure: Provide evidence for security decisions where appropriate\nPolicy Communication: Clear communication of security policies\nRegular Auditing: Third-party security audits of anti-cheat systemsThis comprehensive security framework ensures competitive integrity while maintaining player privacy and providing fair enforcement mechanisms.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Security &amp; Anti-Cheat Systems","level":1,"id":"Security_&_Anti-Cheat_Systems_0"},{"heading":"Authority Model","level":2,"id":"Authority_Model_0"},{"heading":"Server-Side Authority","level":3,"id":"Server-Side_Authority_0"},{"heading":"Trust Boundaries","level":3,"id":"Trust_Boundaries_0"},{"heading":"Input Security","level":2,"id":"Input_Security_0"},{"heading":"Input Validation Pipeline","level":3,"id":"Input_Validation_Pipeline_0"},{"heading":"Spell Cast Validation","level":3,"id":"Spell_Cast_Validation_0"},{"heading":"Movement Validation","level":3,"id":"Movement_Validation_0"},{"heading":"Rate Limiting","level":3,"id":"Rate_Limiting_0"},{"heading":"State Integrity","level":2,"id":"State_Integrity_0"},{"heading":"Determinism Validation","level":3,"id":"Determinism_Validation_0"},{"heading":"State Monitoring","level":3,"id":"State_Monitoring_0"},{"heading":"Anomaly Detection","level":3,"id":"Anomaly_Detection_0"},{"heading":"Anti-Cheat Systems","level":2,"id":"Anti-Cheat_Systems_0"},{"heading":"Server-Side Detection","level":3,"id":"Server-Side_Detection_0"},{"heading":"Client-Side Monitoring","level":3,"id":"Client-Side_Monitoring_0"},{"heading":"Cheat Detection Categories","level":3,"id":"Cheat_Detection_Categories_0"},{"heading":"Network Security","level":2,"id":"Network_Security_0"},{"heading":"Connection Security","level":3,"id":"Connection_Security_0"},{"heading":"DDoS Protection","level":3,"id":"DDoS_Protection_0"},{"heading":"Protocol Security","level":3,"id":"Protocol_Security_0"},{"heading":"Incident Response","level":2,"id":"Incident_Response_0"},{"heading":"Cheat Detection Response","level":3,"id":"Cheat_Detection_Response_0"},{"heading":"Security Incident Handling","level":3,"id":"Security_Incident_Handling_0"},{"heading":"Evidence Collection","level":3,"id":"Evidence_Collection_0"},{"heading":"Privacy and Compliance","level":2,"id":"Privacy_and_Compliance_0"},{"heading":"Data Protection","level":3,"id":"Data_Protection_0"},{"heading":"Transparency","level":3,"id":"Transparency_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/security.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506327,"modifiedTime":1760380506328,"sourceSize":7536,"sourcePath":"architecture/systems/multiplayer/security.md","exportPath":"architecture/systems/multiplayer/security.html","showInTree":true,"treeOrder":29,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/multiplayer/server-architecture.html":{"title":"server-architecture","icon":"","description":"Authoritative game server design with GPU-accelerated simulation identical to client engine.Purpose: Central coordinator for multiplayer matches.Responsibilities:\nWebSocket connection management per match\nPlayer authentication and session management\nFrame timing coordination at 60 FPS\nMatch lifecycle (creation, joining, termination)\nDependencies: NetworkManager, ServerGameEnginePurpose: Authoritative game simulation without rendering.Responsibilities:\nIdentical deterministic simulation to client engine\nGPU compute shader execution for physics and reactions\nTile storage and active region management\nState validation and integrity checking\nKey Differences from Client:\nNo rendering pipeline (headless)\nAdditional input validation layers\nState snapshot creation for rollback\nNetwork delta generation\nPurpose: Real-time communication with game clients.Responsibilities:\nWebSocket server lifecycle management\nInput message validation and deserialization\nState update broadcasting with compression\nConnection quality monitoring and adaptation Client Input Reception: WebSocket message containing player actions\nInput Validation: Verify action legality (mana costs, targeting, timing)\nState Application: Apply validated inputs to authoritative game state\nSimulation Step: Execute physics, reactions, and rule processing\nDelta Generation: Create compressed state updates for clients\n60 FPS Target: 16.67ms frame budget\nInput processing: 2ms\nSimulation execution: 12ms\nNetwork transmission: 2ms\nBuffer time: 0.67ms\nFull State Snapshots: Every 60 frames (1 second) as fallback recovery\nDelta Updates: Every frame with active region optimization\nPriority System: Critical updates (player health) sent immediately\nAcknowledgment Tracking: Ensure reliable delivery with retransmissionServer Environment: Node.js with WebGPU adapter\nGPU Requirements: NVIDIA T4 or equivalent with compute capability\nMemory Management: Shared texture pools across game instancesIdentical Logic: Same shaders as client for deterministic results\nTexture Management: Ping-pong system adapted for server environment\nActive Region Processing: Leverage existing chunk optimizationInstance Batching: Multiple games on single GPU context\nMemory Pooling: Reuse GPU resources between matches\nAdaptive Quality: Reduce simulation fidelity under high loadRoom Creation: Dynamic game instance spawning\nPlayer Assignment: Region-based server selection\nCapacity Management: Load balancing across server instances\nInitialization: GPU resource allocation and world setup\nPlayer Joining: Connection establishment and state synchronization\nActive Gameplay: 60 FPS simulation with network updates\nMatch Conclusion: Resource cleanup and statistics recording\nGPU Failures: Automatic instance migration to backup servers\nNetwork Issues: Client reconnection with state recovery\nCrash Recovery: Persistent state snapshots for match restoration\nFrame timing consistency (target: &lt;16.67ms)\nGPU utilization per instance\nMemory bandwidth consumption\nNetwork throughput per match\nCPU Bound: Input processing and network I/O optimization\nGPU Bound: Shader optimization and batch processing\nMemory Bound: Texture management and garbage collection\nNetwork Bound: Compression and prioritization improvements\nPlayer queue length\nAverage frame processing time\nGPU memory utilization\nNetwork bandwidth per server\nThis architecture provides the authoritative foundation for competitive multiplayer while leveraging Reaction's existing deterministic engine design.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Server Architecture","level":1,"id":"Server_Architecture_0"},{"heading":"Core Components","level":2,"id":"Core_Components_0"},{"heading":"GameServer Class","level":3,"id":"GameServer_Class_0"},{"heading":"ServerGameEngine","level":3,"id":"ServerGameEngine_0"},{"heading":"NetworkManager","level":3,"id":"NetworkManager_0"},{"heading":"Data Flow Architecture","level":2,"id":"Data_Flow_Architecture_0"},{"heading":"Input Processing Pipeline","level":3,"id":"Input_Processing_Pipeline_0"},{"heading":"Frame Execution Timing","level":3,"id":"Frame_Execution_Timing_0"},{"heading":"State Synchronization Strategy","level":3,"id":"State_Synchronization_Strategy_0"},{"heading":"GPU Integration","level":2,"id":"GPU_Integration_0"},{"heading":"Headless WebGPU Setup","level":3,"id":"Headless_WebGPU_Setup_0"},{"heading":"Compute Shader Execution","level":3,"id":"Compute_Shader_Execution_0"},{"heading":"Performance Scaling","level":3,"id":"Performance_Scaling_0"},{"heading":"Match Management","level":2,"id":"Match_Management_0"},{"heading":"Matchmaking Integration","level":3,"id":"Matchmaking_Integration_0"},{"heading":"Game Instance Lifecycle","level":3,"id":"Game_Instance_Lifecycle_0"},{"heading":"Error Handling","level":3,"id":"Error_Handling_0"},{"heading":"Performance Monitoring","level":2,"id":"Performance_Monitoring_0"},{"heading":"Server Metrics","level":3,"id":"Server_Metrics_0"},{"heading":"Bottleneck Detection","level":3,"id":"Bottleneck_Detection_0"},{"heading":"Scaling Indicators","level":3,"id":"Scaling_Indicators_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/server-architecture.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506328,"modifiedTime":1760380506329,"sourceSize":4288,"sourcePath":"architecture/systems/multiplayer/server-architecture.md","exportPath":"architecture/systems/multiplayer/server-architecture.html","showInTree":true,"treeOrder":30,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/physics/determinism.html":{"title":"determinism","icon":"","description":"Ensuring reproducible physics simulation for fair PvP gameplay.Identical Inputs → Identical Outputs: Essential for fair PvP gameplay\nCross-Platform Consistency: Same results across different hardware and drivers\nReplay Capability: Matches should be perfectly reproducible✅ SOLVED: GPU determinism achieved through Spatial Ordering StrategySolution: Deterministic tile processing order using spatial coordinates\nImplementation: See <a class=\"internal-link\" data-href=\"../../architecture/deterministic-execution.md\" href=\".html\" target=\"_self\" rel=\"noopener nofollow\">../../architecture/deterministic-execution.md</a> for complete solution\nStatus: Integrated into Deterministic Time-Sliced Execution pipeline\nSpatial Ordering: Process tiles in strict top-left to bottom-right order\nInteger Mathematics: Fixed-point arithmetic prevents floating-point drift Cross-Platform Consistency: Identical results across GPU architectures\nValidation Framework: Automated testing for deterministic execution\nNo Floating-Point Drift: Use integer-only calculations to prevent precision accumulation\nFixed-Point Arithmetic: ⚠️ NEEDS SPECIFICATION - Specific fixed-point formats for velocity and position\nRounding Consistency: Deterministic rounding rules across all calculationsNo Shared State: Tiles don't share mutable state during processing\nAtomic Operations: Critical for marking active chunks and activity propagation\nData Races: Prevent concurrent read/write conflicts⚠️ CRITICAL REQUIREMENT: Automated testing for deterministic execution\nReplay Tests: Same input sequence produces identical results\nCross-Platform Validation: Consistency across different hardware\nStress Testing: Determinism under high load and complex scenarios\nExecution Tracing: Track tile state changes for debugging non-determinism\nState Snapshots: Capture game state at specific frames for comparison\nRegression Detection: Identify when determinism breaks during developmentHardware Differences: Different GPU architectures may behave differently\nDriver Updates: Graphics driver changes could affect determinism\nFallback Strategies: ⚠️ NEEDS DESIGN - CPU fallback for determinism-critical operations?Implementation Limits: Some optimizations may break determinism\nTesting Requirements: Extensive validation needed for any physics changes\nDocumentation: ⚠️ SUGGESTION - Clear guidelines for maintaining determinism during developmentDeterminism-First: Always consider determinism impact of changes\nValidation Testing: Test determinism before and after modifications\nDocumentation: Document any assumptions about execution order\nCode Review: Explicit review of determinism implicationsShared Memory: Avoid shared memory between GPU threads where possible\nSynchronization: Use barriers and synchronization appropriately\nData Dependencies: Carefully manage data dependencies between processing stages","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Determinism and Precision","level":1,"id":"Determinism_and_Precision_0"},{"heading":"Determinism Requirements","level":2,"id":"Determinism_Requirements_0"},{"heading":"Core Requirement","level":3,"id":"Core_Requirement_0"},{"heading":"Implementation Challenges","level":2,"id":"Implementation_Challenges_0"},{"heading":"GPU Thread Execution Order","level":3,"id":"GPU_Thread_Execution_Order_0"},{"heading":"Deterministic Processing Strategy","level":3,"id":"Deterministic_Processing_Strategy_0"},{"heading":"Precision Control","level":2,"id":"Precision_Control_0"},{"heading":"Integer Mathematics","level":3,"id":"Integer_Mathematics_0"},{"heading":"State Isolation","level":3,"id":"State_Isolation_0"},{"heading":"Validation and Testing","level":2,"id":"Validation_and_Testing_0"},{"heading":"Determinism Testing","level":3,"id":"Determinism_Testing_0"},{"heading":"Debug Capabilities","level":3,"id":"Debug_Capabilities_0"},{"heading":"Risk Mitigation","level":2,"id":"Risk_Mitigation_0"},{"heading":"GPU Driver Variations","level":3,"id":"GPU_Driver_Variations_0"},{"heading":"Performance vs. Determinism Trade-offs","level":3,"id":"Performance_vs._Determinism_Trade-offs_0"},{"heading":"Implementation Guidelines","level":2,"id":"Implementation_Guidelines_0"},{"heading":"Development Practices","level":3,"id":"Development_Practices_0"},{"heading":"Architecture Constraints","level":3,"id":"Architecture_Constraints_0"}],"links":[".html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/determinism.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506329,"modifiedTime":1760380506329,"sourceSize":3480,"sourcePath":"architecture/systems/physics/determinism.md","exportPath":"architecture/systems/physics/determinism.html","showInTree":true,"treeOrder":32,"backlinks":["architecture/systems/physics/physics.html"],"type":"markdown"},"architecture/systems/physics/forces.html":{"title":"forces","icon":"","description":"Spell-driven velocity changes and directional movement constraints.Velocity Model: Discrete directional movement (8 directions) with bit-packed representation.Input Source: Spell system provides velocity change requests processed in the velocity setting pass.Movement Constraints: No traditional forces - tiles move in grid-aligned directions only.Spell Integration: First pass of physics pipeline processes spell system velocity requests.Velocity Changes: Direct velocity modifications rather than force accumulation.Tile Type Changes: Spell effects can modify tile types alongside velocity changes.Bit-Packed Format: 3 bits for direction (8 cardinal/diagonal directions)\nRemaining bits for magnitude/speed\nOptimized for GPU memory bandwidth\nDirection Constraints: Movement limited to 8 directions to maintain grid alignment:\n4 Cardinal: North, South, East, West 4 Diagonal: Northeast, Northwest, Southeast, Southwest\nContext-Dependent Changes: May examine local neighborhood for spell effects that depend on surrounding tiles.Area Effects: Handle spell effects that modify velocities across multiple tiles simultaneously.Pipeline Position: Velocity setting occurs before collision detection passes.State Preparation: Establishes initial velocity state for collision calculation./Data Flow: Reads spell inputs → applies velocity changes → writes updated tile data.Velocity Changes from Collisions: Collision resolution can modify tile velocities.Type-Dependent Collision: Different tile types may have different collision behaviors affecting resulting velocities.Destruction Events: Collisions can destroy tiles, removing them from velocity processing.Velocity Change Requests: Structured data from spell system specifying:\nTarget tile position\nNew velocity vector (direction + magnitude)\nOptional tile type changes\nPriority/timing information\nBatch Processing: Handle multiple spell effects per tile in single pass.Direct Velocity: Set tile velocity to specific value.Velocity Modification: Add/subtract from existing velocity.Conditional Changes: Velocity changes based on tile type or neighborhood.Area Effects: Velocity changes applied to regions around spell targets.Offset System: Tiles maintain sub-grid offsets between discrete positions.Smooth Interpolation: Renderer uses offsets for smooth visual movement.Physics Tick Alignment: Offset precision ensures tiles align with grid at physics ticks.Variable Speeds: Different tiles can move at different rates.Physics Tick Coordination: All speeds calibrated to reach grid positions at physics ticks.Deterministic Movement: Consistent timing across all platforms and runs.// Velocity setting pass structure\n@compute @workgroup_size(8, 8)\nfn velocity_setting_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); // Read current state let current_tile = read_tile(world_coord); let spell_inputs = read_spell_velocity_changes(world_coord); // Apply velocity modifications var updated_tile = current_tile; for (let i = 0; i &lt; spell_inputs.count; i++) { updated_tile = apply_spell_effect(updated_tile, spell_inputs.effects[i]); } write_tile(world_coord, updated_tile);\n}\nCompact Storage: Velocity data packed into minimal bits within tile data structure.Efficient Access: Velocity reading/writing optimized for GPU memory patterns.Spell Input Buffer: Temporary buffer for spell system velocity change requests.Parallel Processing: Each tile processes its velocity changes independently.Minimal Computation: Simple velocity assignment rather than complex force calculations.Memory Bandwidth: Optimized data structures minimize GPU memory access.Spell Load: Performance scales with number of active spell effects.Area Effects: Efficient handling of spells affecting multiple tiles.Context Processing: Optional neighborhood examination for context-dependent effects.Input Interface: Structured velocity change requests from spell processing.Timing Coordination: Velocity changes applied at correct physics tick timing.Effect Validation: Ensure spell effects produce valid velocity values.State Handoff: Provides initial velocity state for collision detection passes.Result Integration: Accepts velocity changes from collision resolution.Type Coordination: Handles tile type changes that affect collision behavior.Interpolation Data: Provides velocity and offset data for smooth visual movement.Event Coordination: Velocity changes may trigger visual effects.Grid Alignment: Force-based physics would complicate grid-aligned movement.Determinism: Direct velocity setting is more predictable than force accumulation.Performance: Simpler calculations than continuous force integration.Spell Integration: Direct velocity control better matches spell effect design.Grid Consistency: 8-direction movement maintains tile alignment with grid.Visual Clarity: Predictable movement directions improve gameplay readability.Collision Simplification: Limited directions simplify collision detection algorithms.Memory Efficiency: 3 bits sufficient for direction encoding.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Velocity System","level":1,"id":"Velocity_System_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Velocity Setting Pass","level":2,"id":"Velocity_Setting_Pass_0"},{"heading":"Input Processing","level":3,"id":"Input_Processing_0"},{"heading":"Velocity Representation","level":3,"id":"Velocity_Representation_0"},{"heading":"Neighborhood Context","level":3,"id":"Neighborhood_Context_0"},{"heading":"Integration with Multi-Pass System","level":2,"id":"Integration_with_Multi-Pass_System_0"},{"heading":"Pass 1 Role","level":3,"id":"Pass_1_Role_0"},{"heading":"Collision Response","level":3,"id":"Collision_Response_0"},{"heading":"Spell System Integration","level":2,"id":"Spell_System_Integration_0"},{"heading":"Input Format","level":3,"id":"Input_Format_0"},{"heading":"Spell Effect Types","level":3,"id":"Spell_Effect_Types_0"},{"heading":"Movement Model","level":2,"id":"Movement_Model_0"},{"heading":"Sub-Grid Positioning","level":3,"id":"Sub-Grid_Positioning_0"},{"heading":"Speed and Timing","level":3,"id":"Speed_and_Timing_0"},{"heading":"Technical Implementation","level":2,"id":"Technical_Implementation_0"},{"heading":"GPU Compute Integration","level":3,"id":"GPU_Compute_Integration_0"},{"heading":"Memory Layout","level":3,"id":"Memory_Layout_0"},{"heading":"Performance Characteristics","level":2,"id":"Performance_Characteristics_0"},{"heading":"Processing Efficiency","level":3,"id":"Processing_Efficiency_0"},{"heading":"Scalability Considerations","level":3,"id":"Scalability_Considerations_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Spell System","level":3,"id":"Spell_System_0"},{"heading":"Collision System","level":3,"id":"Collision_System_0"},{"heading":"Renderer","level":3,"id":"Renderer_0"},{"heading":"Design Rationale","level":2,"id":"Design_Rationale_0"},{"heading":"No Traditional Forces","level":3,"id":"No_Traditional_Forces_0"},{"heading":"Direction Constraints","level":3,"id":"Direction_Constraints_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/forces.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506329,"modifiedTime":1760380506330,"sourceSize":6138,"sourcePath":"architecture/systems/physics/forces.md","exportPath":"architecture/systems/physics/forces.html","showInTree":true,"treeOrder":33,"backlinks":["architecture/systems/physics/physics.html"],"type":"markdown"},"architecture/systems/physics/gpu-shaders.html":{"title":"gpu-shaders","icon":"","description":"Multi-pass compute shader pipeline for collision detection and resolution.The physics system uses a sequence of compute shader passes to resolve collisions deterministically:\nVelocity Setting Pass: Process spell inputs and update tile velocities\nCollision Detection Pass: Calculate initial collision paths\nIterative Resolution Passes: Refine collision paths through multiple iterations Final Execution Pass: Execute movements and handle conflicts\n@compute @workgroup_size(8, 8)\nfn velocity_setting_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); // Read current tile and spell inputs let current_tile = read_tile(world_coord); let spell_inputs = read_spell_velocity_changes(world_coord); // Apply velocity modifications let updated_tile = apply_velocity_changes(current_tile, spell_inputs); write_tile(world_coord, updated_tile);\n}\n@compute @workgroup_size(8, 8)\nfn collision_detection_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); let current_tile = read_tile(world_coord); if (!has_velocity(current_tile)) { return; // Skip stationary tiles in initial pass } // Load neighborhood into workgroup shared memory let neighborhood = load_neighborhood(world_coord, 7); // 7x7 for moving tiles // Calculate collision paths let collision_result = calculate_minimum_collision_time(current_tile, neighborhood); // Store collision path and timing write_collision_path(world_coord, collision_result);\n}\n@compute @workgroup_size(8, 8) fn iterative_resolution_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); let current_tile = read_tile(world_coord); // Load neighborhood with updated collision paths let neighborhood = load_neighborhood_with_paths(world_coord); // Recalculate collision assuming neighbors follow their stored paths let updated_collision = recalculate_collision_with_paths(current_tile, neighborhood); // Update collision path if changed if (path_changed(updated_collision)) { write_collision_path(world_coord, updated_collision); mark_convergence_flag(false); }\n}\n@compute @workgroup_size(8, 8)\nfn execution_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let world_coord = calculate_world_coord(global_id); let current_tile = read_tile(world_coord); let collision_path = read_collision_path(world_coord); // Check for convergence - would another pass change the result? if (would_collision_change(current_tile, collision_path)) { // Write error tile for non-convergent scenario write_error_tile(world_coord); return; } // Execute collision resolution let final_position = collision_path.final_position; let collision_events = collision_path.events; // Atomic write to destination (handles conflicts) if (!atomic_write_tile(final_position, current_tile)) { // Conflict detected - write error tile write_error_tile(world_coord); } // Write collision events for renderer write_collision_events(collision_events);\n}\nShared Memory Caching: Each workgroup loads neighborhood data into local memory.Cache Size: 7×7 neighborhood fits within workgroup shared memory limits.Synchronization: Workgroup barriers ensure data consistency across threads.// Workgroup shared memory for neighborhood caching\nvar&lt;workgroup&gt; neighborhood_cache: array&lt;array&lt;TileData, 7&gt;, 7&gt;;\nvar&lt;workgroup&gt; cache_loaded: bool; @compute @workgroup_size(8, 8)\nfn collision_pass(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;, @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;) { // First thread in workgroup loads neighborhood if (local_id.x == 0 &amp;&amp; local_id.y == 0) { load_neighborhood_to_cache(); cache_loaded = true; } workgroupBarrier(); // All threads process using cached data process_tile_with_cached_neighborhood(global_id, local_id);\n}\nRead Phase: Sample from texture set A (stable data from previous frame).Write Phase: Output to texture set B (prevents read-after-write hazards).Buffer Swapping: Core engine swaps texture sets between physics ticks.Dynamic Sizing: Calculate required neighborhood based on tile velocity and offset.Boundary Handling: World wrapping for neighborhoods that extend beyond edges.Memory Coalescing: Thread groups access contiguous texture regions for GPU cache efficiency.Iterative Resolution: Determinism achieved through multi-pass convergence rather than processing order.Consistent Results: Same collision scenarios produce identical outcomes across runs and platforms.Atomic Operations: GPU atomics ensure consistent conflict resolution when multiple tiles target same location.// Integer-only collision time calculation\nfn calculate_collision_time(tile_a: TileData, tile_b: TileData) -&gt; u32 { // Use fixed-point arithmetic to avoid floating-point drift let relative_velocity = tile_a.velocity - tile_b.velocity; let distance = tile_a.position - tile_b.position; // Integer division with proper rounding return fixed_point_divide(distance, relative_velocity);\n}\nConvergence Detection: Global flag indicates when no collision paths change.Pass Skipping: Skip remaining iterative passes when convergence reached.Implementation: Atomic flag updated by any thread that changes a collision path.Bit-Packed Data: Compress tile data to minimize texture memory usage.Coalesced Access: Align memory access patterns with GPU architecture.Cache Optimization: Structure data layout for optimal GPU cache utilization.Active Region Processing: Only dispatch shaders for chunks containing moving tiles.Indirect Compute: Use indirect dispatch for dynamic workload sizing.Workgroup Scaling: Adjust workgroup count based on active tile density.Texture Management: Coordinate with core engine texture ping-ponging system.Active Chunks: Receive list of active chunks to focus processing.Resource Sharing: Share GPU resources with other compute systems.Collision Events: Write collision timing and results to structured buffer.Renderer Integration: Format events for efficient renderer consumption.Memory Layout: Optimize event buffer layout for sequential access patterns.WGSL Source: Write shaders in WebGPU Shading Language.Compilation: Compile shaders during build process for validation.Hot Reload: Development builds support shader hot-reloading.Compilation Failures: Graceful handling of shader compilation errors.Runtime Validation: Verify shader resources and binding compatibility.Fallback Behavior: Default error handling for GPU context loss.Pass Limiting: Configurable maximum iteration count prevents infinite loops.Memory Bandwidth: Texture access patterns optimized for GPU memory hierarchy.Compute Utilization: Workgroup sizing balanced for GPU architecture efficiency.GPU Utilization: Monitor compute shader execution timing.Memory Bandwidth: Track texture access patterns and cache hit rates.Convergence Speed: Measure average iterations needed for collision resolution.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"GPU Shader Architecture","level":1,"id":"GPU_Shader_Architecture_0"},{"heading":"Pipeline Overview","level":2,"id":"Pipeline_Overview_0"},{"heading":"Compute Shader Structure","level":2,"id":"Compute_Shader_Structure_0"},{"heading":"Pass 1: Velocity Setting Shader","level":3,"id":"Pass_1_Velocity_Setting_Shader_0"},{"heading":"Pass 2: Initial Collision Detection Shader","level":3,"id":"Pass_2_Initial_Collision_Detection_Shader_0"},{"heading":"Pass 3+: Iterative Resolution Shaders","level":3,"id":"Pass_3+_Iterative_Resolution_Shaders_0"},{"heading":"Final Pass: Execution Shader","level":3,"id":"Final_Pass_Execution_Shader_0"},{"heading":"Workgroup Architecture","level":2,"id":"Workgroup_Architecture_0"},{"heading":"Memory Management","level":3,"id":"Memory_Management_0"},{"heading":"Workgroup Organization","level":3,"id":"Workgroup_Organization_0"},{"heading":"Memory Access Patterns","level":2,"id":"Memory_Access_Patterns_0"},{"heading":"Texture Ping-Ponging","level":3,"id":"Texture_Ping-Ponging_0"},{"heading":"Neighborhood Access","level":3,"id":"Neighborhood_Access_0"},{"heading":"Deterministic Execution","level":2,"id":"Deterministic_Execution_0"},{"heading":"Convergence-Based Determinism","level":3,"id":"Convergence-Based_Determinism_0"},{"heading":"Precision Control","level":3,"id":"Precision_Control_0"},{"heading":"Performance Optimizations","level":2,"id":"Performance_Optimizations_0"},{"heading":"Early Termination","level":3,"id":"Early_Termination_0"},{"heading":"Memory Bandwidth Optimization","level":3,"id":"Memory_Bandwidth_Optimization_0"},{"heading":"Dynamic Dispatch","level":3,"id":"Dynamic_Dispatch_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Core Engine Integration","level":3,"id":"Core_Engine_Integration_0"},{"heading":"Event Buffer Management","level":3,"id":"Event_Buffer_Management_0"},{"heading":"Shader Compilation Pipeline","level":2,"id":"Shader_Compilation_Pipeline_0"},{"heading":"Build Process","level":3,"id":"Build_Process_0"},{"heading":"Error Handling","level":3,"id":"Error_Handling_0"},{"heading":"Performance Characteristics","level":2,"id":"Performance_Characteristics_0"},{"heading":"Scalability Considerations","level":3,"id":"Scalability_Considerations_0"},{"heading":"Bottleneck Identification","level":3,"id":"Bottleneck_Identification_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/gpu-shaders.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506330,"modifiedTime":1760380506330,"sourceSize":8456,"sourcePath":"architecture/systems/physics/gpu-shaders.md","exportPath":"architecture/systems/physics/gpu-shaders.html","showInTree":true,"treeOrder":34,"backlinks":["architecture/systems/physics/physics.html"],"type":"markdown"},"architecture/systems/physics/movement-system.html":{"title":"movement-system","icon":"","description":"Free-form positioning with cohesion forces and multi-pass collision resolution architecture.Movement Model: Unconstrained movement using integer-precision positioning for deterministic physics.Collision Resolution: Multi-pass GPU compute pipeline for deterministic collision handling.Cohesion Forces: Automatic gap-closing and tile clustering for natural density management.Integration: Provides collision events and position data to renderer for smooth visual interpolation.Precision: Fixed-point arithmetic using texture-optimized bit precision for deterministic results.Unconstrained Direction: Tiles can move in any direction based on collision physics and spell effects.Offset Storage: Each tile stores its precise x,y offsets from grid center as integer values within texture memory.Renderer Interpolation: Smooth visual movement using precise position data and collision event timing.Continuous Positioning: Tiles can have any offset from their grid centers using integer coordinates.Velocity Representation: Two-component velocity vectors (x,y) stored with texture-optimized precision.Purpose: Automatically close gaps between tiles and maintain dense tile coverage without rigid grid constraints.Force Calculation: Clamped linear attraction between tiles within 1.5 block radius.Neighborhood Processing: 5x5 grid examination to account for tile positioning at sub-grid locations.Distance Calculation: Calculate center-to-center distance between current tile and all neighbors in 5x5 area.Force Formula: Force = max(0, cohesion_strength * (1.5 - distance) / 1.5)Force Direction: Attraction toward the centroid (average position) of nearby tiles within cohesion radius.Dense Coverage: Tiles automatically maintain dense world coverage without explicit positioning rules.Gap Elimination: Empty spaces between adjacent tiles get naturally filled by cohesion attraction.Breaking Force: High-velocity impacts can overcome cohesion to separate tiles and create temporary gaps.Emergent Organization: Organic tile distribution that responds dynamically to collisions and spell effects while maintaining coverage.The collision system uses multiple GPU compute passes to resolve complex scenarios:\nVelocity Setting Pass: Apply spell inputs to update tile velocities\nInitial Collision Pass: Calculate collision times assuming straight-line paths Iterative Passes: Recalculate collisions based on updated paths from previous passes\nFinal Pass: Execute collisions or generate error tiles for conflicts\nInput Processing: Read spell system velocity change requests\nApply velocity modifications to affected tiles\nHandle spell-induced tile type changes\nNeighborhood Analysis: May examine local area for context-dependent velocity changes.Neighborhood Scanning: Moving tiles: Examine 7×7 grid around tile position\nStationary tiles: Examine 5×5 grid for efficiency Dynamic sizing: Calculate affected cells based on velocity and current position\nCollision Calculation: Project straight-line paths for all tiles in neighborhood\nCalculate collision time based on tile size and relative velocities\nFind minimum collision time across all potential collisions\nPath Storage: Write collision path, timing, and tile type changes to tile's memory location.Updated Collision Detection:\nRecalculate collisions assuming tiles follow stored paths from previous pass\nUpdate neighborhood based on new projected movements\nStore refined collision paths and timings\nConvergence Checking: Continue until paths stabilize or maximum pass count reached.Convergence Verification: Check if collision times would change with another iteration.Collision Resolution: Execute tile movements to calculated positions\nApply collision-induced tile type changes\nHandle tile destruction from collision results\nConflict Handling: Use GPU atomics to generate error tiles when multiple tiles target same location.Workgroup Organization: Each workgroup processes a neighborhood region with shared local memory cache.Memory Access Patterns:\nPreload neighborhood data into workgroup local memory\nSequential processing to maintain deterministic order\nAtomic operations for collision conflict resolution\nWorld Wrapping: Tiles at world edges wrap to opposite side by default.Neighborhood Handling: 7×7 neighborhoods near edges access wrapped coordinates for collision detection.Early Termination: Skip remaining passes if no collision paths change.Workgroup Caching: Load full neighborhood into local memory when possible.Bit-Packed Data: Minimize memory bandwidth with compact data structures.Texture Coordination: Read from stable textures, write to ping-pong buffers.Active Region Processing: Focus compute resources on chunks containing moving tiles.Velocity Input: Receive velocity changes from spell processing.Event Coordination: Provide collision timing for spell trigger synchronization.Event Buffer: Generate collision events with precise timing data.Interpolation Data: Provide sub-grid positioning for smooth visual movement.Layer Separation: Physics handles same-layer interactions; reactions handle cross-layer effects.Performance Integration: May merge shaders for efficiency if beneficial.\nOffset: Unconstrained x,y offset from grid center (texture-optimized precision)\nVelocity Vector: Two-component velocity (x,y) with texture-optimized precision\nCollision Path: Projected movement and collision points\nType Changes: Tile transformations from collision results Collision Timing: When collisions occur within physics tick\nCollision Results: Tile movements, destructions, type changes\nInterpolation Points: Data needed for smooth rendering\nPass Limiting: Configurable maximum iterations prevent infinite loops.Workgroup Efficiency: Balance neighborhood size with GPU architecture.Memory Bandwidth: Optimized data layout for GPU texture cache.Convergence-Based Determinism: Multi-pass iteration ensures consistent collision resolution regardless of processing order.Integer Mathematics: Fixed-point arithmetic prevents floating-point drift.Atomic Consistency: GPU atomics ensure deterministic conflict resolution when multiple tiles target same destination.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Movement System","level":1,"id":"Movement_System_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Free-Form Movement Model","level":2,"id":"Free-Form_Movement_Model_0"},{"heading":"Offset Positioning System","level":3,"id":"Offset_Positioning_System_0"},{"heading":"Movement Integration","level":3,"id":"Movement_Integration_0"},{"heading":"Cohesion Force System","level":2,"id":"Cohesion_Force_System_0"},{"heading":"Gap-Closing Mechanics","level":3,"id":"Gap-Closing_Mechanics_0"},{"heading":"Cohesion Force Implementation","level":3,"id":"Cohesion_Force_Implementation_0"},{"heading":"Benefits","level":3,"id":"Benefits_0"},{"heading":"Multi-Pass Collision Pipeline","level":2,"id":"Multi-Pass_Collision_Pipeline_0"},{"heading":"Pipeline Overview","level":3,"id":"Pipeline_Overview_0"},{"heading":"Pass 1: Velocity Setting","level":3,"id":"Pass_1_Velocity_Setting_0"},{"heading":"Pass 2: Initial Collision Detection","level":3,"id":"Pass_2_Initial_Collision_Detection_0"},{"heading":"Pass 3 to 3+n: Iterative Resolution","level":3,"id":"Pass_3_to_3+n_Iterative_Resolution_0"},{"heading":"Final Pass: Collision Execution","level":3,"id":"Final_Pass_Collision_Execution_0"},{"heading":"Technical Implementation","level":2,"id":"Technical_Implementation_0"},{"heading":"GPU Compute Architecture","level":3,"id":"GPU_Compute_Architecture_0"},{"heading":"Boundary Conditions","level":3,"id":"Boundary_Conditions_0"},{"heading":"Performance Optimizations","level":3,"id":"Performance_Optimizations_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Core Engine","level":3,"id":"Core_Engine_0"},{"heading":"Spell System","level":3,"id":"Spell_System_0"},{"heading":"Renderer","level":3,"id":"Renderer_0"},{"heading":"Reaction System","level":3,"id":"Reaction_System_0"},{"heading":"Data Structures","level":2,"id":"Data_Structures_0"},{"heading":"Tile Physics Data","level":3,"id":"Tile_Physics_Data_0"},{"heading":"Event Buffer Format","level":3,"id":"Event_Buffer_Format_0"},{"heading":"Performance Characteristics","level":2,"id":"Performance_Characteristics_0"},{"heading":"Scalability Considerations","level":3,"id":"Scalability_Considerations_0"},{"heading":"Determinism Guarantees","level":3,"id":"Determinism_Guarantees_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/movement-system.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506330,"modifiedTime":1760380506331,"sourceSize":7325,"sourcePath":"architecture/systems/physics/movement-system.md","exportPath":"architecture/systems/physics/movement-system.html","showInTree":true,"treeOrder":35,"backlinks":["architecture/systems/physics/physics.html"],"type":"markdown"},"architecture/systems/physics/physics.html":{"title":"physics","icon":"","description":"GPU-accelerated physics simulation providing smooth tile movement between grid locations with sub-grid positioning and deterministic collision resolution.Design Principle: Multi-pass GPU compute pipeline optimized for parallel collision detection and resolution.Movement Model: Free-form movement with integer-precision positioning for deterministic physics calculations.\nFree-form tile movement with unconstrained offsets from grid centers\nMulti-pass collision detection and deterministic resolution Velocity management from spell inputs and collision results\nCohesion forces for natural gap-closing and tile clustering\nEvent generation for renderer interpolation between physics ticks <a class=\"internal-link\" data-href=\"movement-system.md\" href=\"architecture/systems/physics/movement-system.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Movement System - Velocity and collision mechanics\n<br><a class=\"internal-link\" data-href=\"gpu-shaders.md\" href=\"architecture/systems/physics/gpu-shaders.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>GPU Shaders - Compute shader architecture and implementation\n<br><a class=\"internal-link\" data-href=\"forces.md\" href=\"architecture/systems/physics/forces.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Forces - Rune forces and environmental effects\n<br><a class=\"internal-link\" data-href=\"determinism.md\" href=\"architecture/systems/physics/determinism.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Determinism - Precision and reproducibility guarantees\nOffset Positioning: Tiles store unconstrained offsets from grid centers using fixed-point arithmetic with texture-optimized precision.Unconstrained Movement: Tiles can move in any direction with collision-determined velocities and bouncing.Renderer Integration: Physics generates collision events with timing data for smooth visual interpolation.Iterative Resolution: Multiple GPU compute passes resolve complex multi-tile collision scenarios.Deterministic Results: Configurable pass limit ensures consistent behavior across platforms.Atomic Conflict Handling: Multiple tiles targeting the same location generate error tiles through GPU atomics.Gap Closure: Tiles within 1.5 block radius attract each other using clamped linear forces.5x5 Neighborhood: Cohesion calculations examine 5x5 area to account for sub-grid positioning.Natural Clustering: Automatic tile density management without rigid grid constraints.\nTexture Coordination: Read/write physics data via texture ping-ponging\nWorld Boundaries: Wrapping system for tiles at world edges\nMemory Efficiency: Direct texture operations with workgroup caching Velocity Input: Receive velocity changes from spell processing\nCollision Response: Tile type changes and destruction from collision results\nEvent Output: Collision timing and results for spell trigger coordination Event Buffer: Collision events with precise timing for smooth interpolation\nOffset Data: Tile offsets from grid centers for accurate visual positioning\nVelocity Data: Current tile velocities for motion blur and particle effects Core Engine: Required for texture management and active region optimization\nWebGPU: GPU compute shaders for parallel processing\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Physics Engine System","level":1,"id":"Physics_Engine_System_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Core Responsibilities","level":2,"id":"Core_Responsibilities_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Components","level":3,"id":"Core_Components_0"},{"heading":"Key Technical Features","level":2,"id":"Key_Technical_Features_0"},{"heading":"Free-Form Movement System","level":3,"id":"Free-Form_Movement_System_0"},{"heading":"Multi-Pass Collision Pipeline","level":3,"id":"Multi-Pass_Collision_Pipeline_0"},{"heading":"Cohesion Force System","level":3,"id":"Cohesion_Force_System_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Core Engine Integration","level":3,"id":"Core_Engine_Integration_0"},{"heading":"Spell System Integration","level":3,"id":"Spell_System_Integration_0"},{"heading":"Renderer Integration","level":3,"id":"Renderer_Integration_0"},{"heading":"Dependencies","level":2,"id":"Dependencies_0"}],"links":["architecture/systems/physics/movement-system.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/forces.html","architecture/systems/physics/determinism.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/physics.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506331,"modifiedTime":1760380506331,"sourceSize":3222,"sourcePath":"architecture/systems/physics/physics.md","exportPath":"architecture/systems/physics/physics.html","showInTree":true,"treeOrder":36,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/reactions/reactions.html":{"title":"reactions","icon":"","description":"Rule-based environmental transformations through GPU shader compilation for complex tile interactions.Transform human-readable tile interaction rules into highly optimized GPU shaders for environmental transformations like fire spreading, water extinguishing flames, and magical interactions.Design Approach: Designed for ease of rule creation and modification during development, allowing rules to be defined in JSON and automatically converted to efficient GPU code. Alternative approaches may be considered during implementation.\nJSON rule compilation to optimized GPU shaders\nCompetitive rule scoring and execution for deterministic behavior\nEnvironmental pattern matching (fire spreading, water interactions, etc.)\nRule optimization pipeline (specific implementation TBD) <a class=\"internal-link\" data-href=\"rule-compilation.md\" href=\"architecture/systems/reactions/rule-compilation.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Rule Compilation - JSON to GPU shader pipeline\n<br><a class=\"internal-link\" data-href=\"rule-system.md\" href=\".html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Rule System - Competitive scoring model and execution\n<br><a class=\"internal-link\" data-href=\"visual-editor.md\" href=\".html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Visual Editor - Development tools and rule creation interface\n<br><a class=\"internal-link\" data-href=\"examples.md\" href=\".html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Examples - Sample rules and common patterns\nProblem: Multiple rules may apply to the same tile simultaneously.\nSolution: Competitive evaluation where highest-scoring rule wins.Design Philosophy: Move all possible computational work to build time for minimal runtime overhead.Lower frequency than physics: Reactions may run less frequently for performance.\n⚠️ Challenge: Coordination with physics timing is a major technical issue to solve.\nCore Engine: Required for texture access and coordination\nBuild Toolchain: Rule compilation requires build-time processing\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Reaction Engine System","level":1,"id":"Reaction_Engine_System_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Core Responsibilities","level":2,"id":"Core_Responsibilities_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Components","level":3,"id":"Core_Components_0"},{"heading":"Key Technical Features","level":2,"id":"Key_Technical_Features_0"},{"heading":"Competitive Scoring Model","level":3,"id":"Competitive_Scoring_Model_0"},{"heading":"Offline Optimization","level":3,"id":"Offline_Optimization_0"},{"heading":"Processing Model","level":2,"id":"Processing_Model_0"},{"heading":"GPU Execution","level":3,"id":"GPU_Execution_0"},{"heading":"Dependencies","level":2,"id":"Dependencies_0"}],"links":["architecture/systems/reactions/rule-compilation.html",".html",".html",".html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/reactions/reactions.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506331,"modifiedTime":1760380506332,"sourceSize":1952,"sourcePath":"architecture/systems/reactions/reactions.md","exportPath":"architecture/systems/reactions/reactions.html","showInTree":true,"treeOrder":38,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/reactions/rule-compilation.html":{"title":"rule-compilation","icon":"","description":"Transform human-readable tile interaction rules into GPU shaders for environmental transformations like fire spreading, water extinguishing flames, and magical interactions.Design Approach: Designed for ease of rule creation and modification during development, allowing rules to be defined in JSON and automatically converted to GPU code. Alternative approaches may be considered during implementation.Offline Processing: Move computational work to build time for reduced runtime overhead. JSON Rule Definition Human-readable transformation rules\nVisual editor exports structured rule data\nDeclarative condition and action specifications GLSL Code Generation Rust-based rule-to-shader compiler\nConverts declarative rules to imperative GPU code\nGenerates helper functions for tile data access SPIR-V Compilation Standard glslangValidator compilation\nProduces unoptimized intermediate representation\nPlatform-independent shader bytecode Optimization (⚠️ NEEDS DESIGN - specific tools TBD) Dead code elimination, function inlining\nConstant folding, loop unrolling\nRegister allocation optimization WebGPU Conversion Convert to WebGPU-compatible shader format\nRuntime loading and execution Problem: Multiple rules may apply to the same tile simultaneously.Solution: Competitive evaluation where highest-scoring rule wins.Characteristics:\nDeterministic rule resolution\nPriority-based rule ordering\nComplex conditional logic support\nComplex interaction behaviors\nLogical Operators: AND, OR, NOT for complex conditions\nSpatial Queries: Check neighboring tiles and patterns\nAggregate Functions: Count tiles in regions, calculate thresholds\nBoolean Conversion: Transform true/false to numeric scoresBase Priority: Fixed score for rule importance\nEnvironmental Bonuses: Dynamic scoring based on surroundings\nMandatory Conditions: Huge negative scores for rule violations\nThreshold Logic: Activation based on neighbor countsTile Transformation: Change tile type and properties\nProperty Modification: Update velocity, health, timers\nForce Application: Apply velocity changes\nState Changes: Modify custom data fields{ \"grass\": [ { \"id\": \"GrassIgnition\", \"action\": { \"type\": \"SetType\", \"new_type\": \"fire\" }, \"score_calculation\": { \"type\": \"Add\", \"children\": [ { \"type\": \"Constant\", \"value\": 30 }, { \"type\": \"BooleanToValue\", \"condition\": { \"type\": \"Aggregate\", \"region\": \"3x3\", \"tile_type\": \"fire\", \"comparison\": \"GreaterThan\", \"count\": 0 }, \"value_if_true\": 0, \"value_if_false\": -10000 }, { \"type\": \"Aggregate\", \"region\": \"3x3\", \"tile_type\": \"water\", \"expression\": \"count * -50\" } ] } } ]\n}\nLower frequency than physics: Reactions may run less frequently for performance.Challenge: Coordination with physics timing is a major technical issue to solve.\nRule Evaluation: Each tile evaluates all applicable rules\nScore Calculation: Parallel computation of rule priorities Winner Selection: Deterministic highest-score selection\nAction Application: Transform winning tiles Input: Read post-physics tile states\nProcessing: Local neighborhood sampling for conditions\nOutput: Write transformed tiles for next physics cycle\nIntegration: Seamless data flow with physics engine\n⚠️ SUGGESTION: Potential editor features for future development:\nGrid-based visual neighborhood editor\nPoint-and-click rule creation interface\nReal-time rule testing and preview\nDirect JSON generation for compilation\n⚠️ SUGGESTION: Potential debugging capabilities:\nRule tracing: Debug which rules activated and why\nScore visualization: See rule competition in real-time\nValidation tools: Detect impossible or conflicting rules\nPerformance profiling: Shader execution timing\n⚠️ SUGGESTION: Potential compilation optimizations:\nCompile-time specialization for specific use cases\nDead code elimination for unused rule paths\nConstant folding for pre-computed values\nLoop unrolling for neighbor checks Rule Complexity: Handles arbitrary rule complexity through compilation\nRule Count: Compilation-time scaling, not runtime cost\nMemory Efficiency: Optimized data access patterns\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Rule Compilation Pipeline","level":1,"id":"Rule_Compilation_Pipeline_0"},{"heading":"Purpose and Compilation Strategy","level":2,"id":"Purpose_and_Compilation_Strategy_0"},{"heading":"Rule Compilation Pipeline","level":2,"id":"Rule_Compilation_Pipeline_1"},{"heading":"Design Philosophy","level":3,"id":"Design_Philosophy_0"},{"heading":"Compilation Stages","level":3,"id":"Compilation_Stages_0"},{"heading":"Rule System Architecture","level":2,"id":"Rule_System_Architecture_0"},{"heading":"Competitive Scoring Model","level":3,"id":"Competitive_Scoring_Model_0"},{"heading":"Rule Structure Components","level":3,"id":"Rule_Structure_Components_0"},{"heading":"Condition Trees","level":4,"id":"Condition_Trees_0"},{"heading":"Scoring System","level":4,"id":"Scoring_System_0"},{"heading":"Actions","level":4,"id":"Actions_0"},{"heading":"Example Rule: Fire Spreading","level":3,"id":"Example_Rule_Fire_Spreading_0"},{"heading":"GPU Execution Model","level":2,"id":"GPU_Execution_Model_0"},{"heading":"Processing Frequency","level":3,"id":"Processing_Frequency_0"},{"heading":"Shader Architecture","level":3,"id":"Shader_Architecture_0"},{"heading":"Memory Access","level":3,"id":"Memory_Access_0"},{"heading":"Development Workflow","level":2,"id":"Development_Workflow_0"},{"heading":"Visual Rule Editor Integration","level":3,"id":"Visual_Rule_Editor_Integration_0"},{"heading":"Debugging and Validation","level":3,"id":"Debugging_and_Validation_0"},{"heading":"Performance Characteristics","level":2,"id":"Performance_Characteristics_0"},{"heading":"Potential Optimizations","level":3,"id":"Potential_Optimizations_0"},{"heading":"Scalability","level":3,"id":"Scalability_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/reactions/rule-compilation.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506332,"modifiedTime":1760380506332,"sourceSize":5254,"sourcePath":"architecture/systems/reactions/rule-compilation.md","exportPath":"architecture/systems/reactions/rule-compilation.html","showInTree":true,"treeOrder":39,"backlinks":["architecture/systems/reactions/reactions.html"],"type":"markdown"},"architecture/systems/rendering/rendering.html":{"title":"rendering","icon":"","description":"Status: Incomplete documentationThe Renderer system handles visual display and UI rendering for Reaction v2.The renderer is responsible for:\nGPU-based visual display of the game grid\nUI rendering and interface elements\nFrame coordination with other systems\nVisual effects and animations\nDocumentation incomplete - details to be added during implementationDocumentation incomplete - optimization details to be addedDocumentation incomplete - WebGPU implementation details to be added","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Renderer System","level":1,"id":"Renderer_System_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Architecture","level":2,"id":"Architecture_0"},{"heading":"Performance Considerations","level":2,"id":"Performance_Considerations_0"},{"heading":"GPU Integration","level":2,"id":"GPU_Integration_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/rendering/rendering.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506332,"modifiedTime":1760380506333,"sourceSize":639,"sourcePath":"architecture/systems/rendering/rendering.md","exportPath":"architecture/systems/rendering/rendering.html","showInTree":true,"treeOrder":41,"backlinks":["architecture/general/ghost-simulation.html","architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/spells/cpu-architecture.html":{"title":"cpu-architecture","icon":"","description":"Processing model and integration approach for the spell system's CPU-based design.Initial Decision: Initially chosen for CPU because it handles direct player input and seemed more straightforward to implement. This choice may be revisited during implementation.Current Advantages:\nComplex conditional logic: Spell rules without GPU shader limitations\nEasy debugging: Step-through debugging and rule modification\nImmediate response: Direct response to player input without GPU compilation delays\nRuntime flexibility: Dynamic spell behavior changes possible\n⚠️ POTENTIAL FUTURE CHANGE: Moving some spell processing to GPU if CPU becomes performance bottleneck\nSimple Operations: Rune countdown timers could be GPU-accelerated\nComplex Logic: Combination rules and validation likely remain CPU-bound\nHybrid Approach: CPU for logic, GPU for simple state updates\nInput Phase: Process player spell casts and UI interactions during input processing phase\nRune Phase: Handle rune countdown and triggering during dedicated rune processing phase\nCoordination: Seamless integration with GPU-based physics and reaction systems⚠️ NEEDS SPECIFICATION: Approach to concurrent spell processing\nMulti-threading: Can spell logic be parallelized safely?\nState Isolation: Ensure thread safety for simultaneous spell processing\nPerformance Scaling: CPU utilization across multiple player actions\nRune Placement: Direct texture writes to rune layer\nTexture Access: CPU writes directly to GPU texture memory\nSynchronization: Coordinate with GPU texture ping-ponging system\nError Handling: Manage GPU resource allocation failures\nState Queries: Read tile data for spell validation\nCache Strategy: Minimize CPU-GPU memory transfers\nData Freshness: Ensure CPU reads current game state\nPerformance Impact: Balance query frequency vs. accuracy\nForce Application: Queue forces for physics engine processing\nForce Buffer: Accumulate forces from multiple spell sources\nTiming Coordination: Ensure forces apply at correct physics update\nVector Math: Proper force calculation and combination\nRead Operations: CPU reads game state for spell validation\nWrite Operations: CPU writes rune data and force applications\nSynchronization: Coordinate with GPU pipeline phasesSpell Complexity: Complex spells may create CPU bottlenecks\nPlayer Scaling: Performance impact of multiple simultaneous players\nRune Management: Cost of tracking many active runes across players⚠️ SUGGESTIONS for potential CPU optimizations:\nCaching: Cache frequently-accessed tile data\nBatching: Group multiple spell operations for efficiency Lazy evaluation: Delay expensive calculations until needed\nState compression: Efficient rune data representations\n⚠️ NEEDS SPECIFICATION: Efficient data transfer patterns\nTransfer Minimization: Reduce CPU-GPU memory bandwidth usage\nBuffer Management: Proper GPU buffer allocation and lifecycle\nMemory Mapping: Efficient access to GPU texture data from CPU\nActive Rune Tracking: CPU data structures for rune management\nLifecycle Management: Efficient creation and cleanup of rune objects\nMemory Pooling: Reuse memory allocations for performanceMana Verification: Ensure sufficient mana flowers available\nRange Checking: Validate spell targets within allowed range\nObstruction Testing: ⚠️ NEEDS DESIGN - Line of sight or targeting rules\nCooldown Enforcement: Prevent casting during mana rechargeGPU Communication Failures: Handle GPU resource unavailability\nInvalid State Recovery: Respond to corrupted game state\nPlayer Disconnection: Manage spells from disconnected players\nPerformance Degradation: Respond to CPU performance bottlenecksStep-through Debugging: Full debugging support for spell logic\nState Inspection: Real-time examination of spell and rune state\nPerformance Profiling: CPU usage monitoring and bottleneck identification\nLogic Tracing: Track spell execution and rule application\nRapid iteration: Quick testing of new spell mechanics\nRule modification: Runtime changes to spell behavior possible\nComplex logic: Support for complex spell interactions\nIntegration testing: Easy testing of CPU-GPU coordination\n⚠️ POTENTIAL EVOLUTION: Areas where GPU processing might be beneficial\nSimple State Updates: Rune countdown timers\nParallel Operations: Multiple rune processing simultaneously Mathematical Operations: Complex force calculations\nPlayer Count Scaling: CPU performance with many simultaneous players\nSpell Complexity Growth: Performance impact of increasingly complex spells\nReal-time Requirements: Maintaining responsiveness under load","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"CPU Architecture","level":1,"id":"CPU_Architecture_0"},{"heading":"Design Rationale","level":2,"id":"Design_Rationale_0"},{"heading":"CPU-Only Processing Choice","level":3,"id":"CPU-Only_Processing_Choice_0"},{"heading":"Alternative Considerations","level":3,"id":"Alternative_Considerations_0"},{"heading":"Processing Architecture","level":2,"id":"Processing_Architecture_0"},{"heading":"Frame Integration","level":3,"id":"Frame_Integration_0"},{"heading":"Concurrent Processing","level":3,"id":"Concurrent_Processing_0"},{"heading":"Integration with GPU Systems","level":2,"id":"Integration_with_GPU_Systems_0"},{"heading":"Core Engine Integration","level":3,"id":"Core_Engine_Integration_0"},{"heading":"Physics Engine Coordination","level":3,"id":"Physics_Engine_Coordination_0"},{"heading":"Data Flow Management","level":3,"id":"Data_Flow_Management_0"},{"heading":"Performance Characteristics","level":2,"id":"Performance_Characteristics_0"},{"heading":"CPU Load Considerations","level":3,"id":"CPU_Load_Considerations_0"},{"heading":"Optimization Opportunities","level":3,"id":"Optimization_Opportunities_0"},{"heading":"Memory Management","level":2,"id":"Memory_Management_0"},{"heading":"CPU-GPU Memory Coordination","level":3,"id":"CPU-GPU_Memory_Coordination_0"},{"heading":"Rune Data Storage","level":3,"id":"Rune_Data_Storage_0"},{"heading":"Error Handling and Validation","level":2,"id":"Error_Handling_and_Validation_0"},{"heading":"Spell Validation","level":3,"id":"Spell_Validation_0"},{"heading":"Runtime Error Recovery","level":3,"id":"Runtime_Error_Recovery_0"},{"heading":"Development and Debugging","level":2,"id":"Development_and_Debugging_0"},{"heading":"Debugging Capabilities","level":3,"id":"Debugging_Capabilities_0"},{"heading":"Development Benefits","level":3,"id":"Development_Benefits_0"},{"heading":"Future Architectural Considerations","level":2,"id":"Future_Architectural_Considerations_0"},{"heading":"Hybrid Processing Potential","level":3,"id":"Hybrid_Processing_Potential_0"},{"heading":"Scalability Challenges","level":3,"id":"Scalability_Challenges_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/cpu-architecture.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506333,"modifiedTime":1760380506333,"sourceSize":5616,"sourcePath":"architecture/systems/spells/cpu-architecture.md","exportPath":"architecture/systems/spells/cpu-architecture.html","showInTree":true,"treeOrder":43,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/systems/spells/customization.html":{"title":"customization","icon":"","description":"Deck building and curse mechanics for player customization and risk/reward gameplay.\nSpell Collection: Players build from available spell library\nPre-game Construction: Deck built before match starts\nStrategic Focus: Deck size limits encourage focused strategies\nSynergistic Design: Spells designed to work together thematically\n⚠️ NEEDS SPECIFICATION: Specific deck building rules\nDeck Size: Minimum and maximum spell counts TBD\nDuplicate Limits: How many copies of same spell allowed?\nRarity System: Different spell availability or costs?\nMana Balance: Requirements for mana type distribution?\n⚠️ NEEDS DESIGN: How players acquire new spells for their collection\nProgression System: Unlock spells through gameplay?\nDefault Collection: Starting spells available to all players?\nExpansion Content: New spells added over time?\nPower vs. Risk: Cursed builds offer advantages with meaningful drawbacks\nBuild Balance: ⚠️ NEEDS DISCUSSION - Balance approach between pure and cursed builds\nDiversity: ⚠️ SUGGESTION - Support multiple build approaches⚠️ SUGGESTION: Potential curse concepts for future design:Glass Cannon: +50% spell damage, -50% health\nMana Leak: -1 mana cost for spells, 20% spell failure rate\nBerserker: +2 spell range when below 25% health, -1 max health⚠️ NEEDS BALANCING: Specific numbers and effects require playtesting⚠️ NEEDS SPECIFICATION: Implementation details for curse system\nCurse Selection: How many curses can player choose?\nStacking Rules: Can multiple curses be combined?\nActivation Conditions: When do curse effects trigger?\nBalancing: How to ensure curses remain balanced risk/reward choices?\n⚠️ SUGGESTION: Potential build approaches to consider:\nDirect damage focus\nArea control emphasis\nSpell combination reliance\nDefensive/survival priority\n⚠️ ONGOING BALANCE CHALLENGE:\nPreventing dominant strategies from overshadowing others\nEncouraging experimentation with different build types\nMaintaining viability of both cursed and pure builds\nAdapting to emerging player strategies\nMeaningful Choices: Each deck building decision impacts gameplay significantly\nPersonal Style: Support for different tactical preferences and risk tolerances\nSkill Expression: Reward players who master complex spell combinationsLearning Curve: New players need viable simple strategies\nMastery Ceiling: Expert players should have room for optimization and innovation\nClear Feedback: Players should understand why their builds succeed or failFlower Allocation: Deck composition influences optimal mana flower distribution\nRecharge Timing: Curse effects may interact with mana recharge cycles\nResource Planning: Spell costs drive strategic resource managementMatch Duration: Deck composition affects typical game length\nPower Scaling: Prevent early-game dominance or late-game stalls\nInteractive Gameplay: Encourage player-vs-player interaction over solitaire optimization⚠️ NEEDS SPECIFICATION: How deck and curse data is stored and validated\nDeck Validation: Ensure legal deck construction\nCurse Verification: Prevent invalid curse combinations\nPersistence: Save player collections and preferred builds\n⚠️ NEEDS DESIGN: Deck building and curse selection interfaces\nDeck Builder: Intuitive spell selection and organization\nCurse Interface: Clear presentation of risk/reward trade-offs\nPreview System: Show how builds affect gameplay before committing\n⚠️ ONGOING REQUIREMENT: Systems for monitoring and adjusting balance\nData Collection: Track win rates and usage patterns\nAdjustment Mechanisms: How to modify spell or curse balance\nCommunity Feedback: Integration of player feedback into balance decisions\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Customization Systems","level":1,"id":"Customization_Systems_0"},{"heading":"Deck Building System","level":2,"id":"Deck_Building_System_0"},{"heading":"Collection and Selection","level":3,"id":"Collection_and_Selection_0"},{"heading":"Deck Constraints","level":3,"id":"Deck_Constraints_0"},{"heading":"Spell Acquisition","level":3,"id":"Spell_Acquisition_0"},{"heading":"Curse System","level":2,"id":"Curse_System_0"},{"heading":"Design Philosophy","level":3,"id":"Design_Philosophy_0"},{"heading":"Example Curses","level":3,"id":"Example_Curses_0"},{"heading":"Curse Mechanics","level":3,"id":"Curse_Mechanics_0"},{"heading":"Strategic Considerations","level":2,"id":"Strategic_Considerations_0"},{"heading":"Build Archetypes","level":3,"id":"Build_Archetypes_0"},{"heading":"Meta Considerations","level":3,"id":"Meta_Considerations_0"},{"heading":"Player Expression","level":2,"id":"Player_Expression_0"},{"heading":"Customization Depth","level":3,"id":"Customization_Depth_0"},{"heading":"Accessibility vs. Depth","level":3,"id":"Accessibility_vs._Depth_0"},{"heading":"Integration with Game Systems","level":2,"id":"Integration_with_Game_Systems_0"},{"heading":"Mana System Integration","level":3,"id":"Mana_System_Integration_0"},{"heading":"Gameplay Balance","level":3,"id":"Gameplay_Balance_0"},{"heading":"Implementation Considerations","level":2,"id":"Implementation_Considerations_0"},{"heading":"Data Storage","level":3,"id":"Data_Storage_0"},{"heading":"User Interface","level":3,"id":"User_Interface_0"},{"heading":"Balance Maintenance","level":3,"id":"Balance_Maintenance_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/customization.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506334,"modifiedTime":1760380506334,"sourceSize":4494,"sourcePath":"architecture/systems/spells/customization.md","exportPath":"architecture/systems/spells/customization.html","showInTree":true,"treeOrder":44,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/systems/spells/mana-system.html":{"title":"mana-system","icon":"","description":"Purpose: Create resource allocation decisions without resource scarcity pressure.Philosophy: Focus on timing and positioning over resource conservation.Purpose: Create resource allocation decisions.Mechanics:\nDefault: 3 flowers per mana type (fire, water, earth, air)\nRecharge: 3 non-stunned turns to restore after use (balances spell casting incentive vs saving)\nStrategy: Specialization vs. flexibility trade-offs Hand Size: TBD based on UI and gameplay needs\nReplenishment: Draw from personal spell deck each turn\nDeck Construction: Pre-game selection from available spells Selection: Player chooses spell from hand\nValidation: Check mana cost and target range\nExecution: Place runes according to spell pattern\nCost: Exhaust required mana flowers\nCooldown: Start mana flower recharge timers Mana Cost: Specific mana types and quantities required\nRange: Maximum targeting distance from caster\nPattern: Grid layout of runes placed around target\nEffects: Rune types, forces, and delays in pattern Type: Determines transformation effects (fire, ice, force, etc.)\nForce: Velocity applied when triggered\nDelay: Countdown timer before activation Placement: Created by spell casting\nDelay: Countdown each CPU processing cycle\nTriggering: Apply transformations and forces when delay reaches zero\nCombination: Merge with other runes on same tile\nRemoval: Clean up spent runes\nPurpose: Create emergent spell combinations.Mechanics:\nMultiple runes on same tile combine automatically\nResult has combined force and minimum delay\nType determined by combination rules table\nSome combinations cancel forces or produce no rune\nPurpose: Power vs. risk trade-offs.Balance Philosophy: Pure builds viable but less interesting than cursed builds.Example Curses:\nGlass Cannon: +50% spell damage, -50% health\nMana Leak: -1 mana cost, 20% spell failure rate\nBerserker: +2 spell range when below 25% health, -1 max health Collection: Players build from available spell library\nConstraints: Deck size limits encourage focused strategies\nSynergies: Spells designed to work together thematically\nCPU-Only Design: See <a class=\"internal-link\" data-href=\"../../architecture/technical-decisions.md\" href=\".html\" target=\"_self\" rel=\"noopener nofollow\">../../architecture/technical-decisions.md</a> for architecture rationale and integration details.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Mana System","level":1,"id":"Mana_System_0"},{"heading":"Purpose and Design Goals","level":2,"id":"Purpose_and_Design_Goals_0"},{"heading":"Player Resources","level":2,"id":"Player_Resources_0"},{"heading":"Mana Flower System","level":3,"id":"Mana_Flower_System_0"},{"heading":"Spell Hand Management","level":3,"id":"Spell_Hand_Management_0"},{"heading":"Spell Mechanics","level":2,"id":"Spell_Mechanics_0"},{"heading":"Casting Process","level":3,"id":"Casting_Process_0"},{"heading":"Spell Properties","level":3,"id":"Spell_Properties_0"},{"heading":"Rune System","level":2,"id":"Rune_System_0"},{"heading":"Rune Properties","level":3,"id":"Rune_Properties_0"},{"heading":"Rune Lifecycle","level":3,"id":"Rune_Lifecycle_0"},{"heading":"Rune Interactions","level":3,"id":"Rune_Interactions_0"},{"heading":"Customization Systems","level":2,"id":"Customization_Systems_0"},{"heading":"Curse System","level":3,"id":"Curse_System_0"},{"heading":"Deck Building","level":3,"id":"Deck_Building_0"},{"heading":"Processing Architecture","level":2,"id":"Processing_Architecture_0"}],"links":[".html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/mana-system.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506334,"modifiedTime":1760380506334,"sourceSize":2810,"sourcePath":"architecture/systems/spells/mana-system.md","exportPath":"architecture/systems/spells/mana-system.html","showInTree":true,"treeOrder":45,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/systems/spells/spells.html":{"title":"spells","icon":"","description":"Player-controlled spellcasting, mana management, and rune interactions.Player-controlled spellcasting with resource management and rune interactions.Design Goal: CPU-based processing allows flexible spell logic without GPU shader constraints.\nMana flower economy and recharge timers\nSpell validation and execution\nRune lifecycle management (placement, delay, triggering, combinations)\nDeck building and curse system\nPlayer customization options <a class=\"internal-link\" data-href=\"mana-system.md\" href=\"architecture/systems/spells/mana-system.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Mana System - Flower economy and recharge mechanics\n<br><a class=\"internal-link\" data-href=\"spells-and-runes.md\" href=\"architecture/systems/spells/spells-and-runes.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Spells and Runes - Casting mechanics and rune lifecycle\n<br><a class=\"internal-link\" data-href=\"customization.md\" href=\"architecture/systems/spells/customization.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Customization - Deck building and curse system\n<br><a class=\"internal-link\" data-href=\"cpu-architecture.md\" href=\"architecture/systems/spells/cpu-architecture.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>CPU Architecture - Processing model and integration\nSee individual component documentation for detailed mechanics:\n<br><a class=\"internal-link\" data-href=\"mana-system.md\" href=\"architecture/systems/spells/mana-system.html\" target=\"_self\" rel=\"noopener nofollow\">Mana System</a> - Resource management and recharge cycles\n<br><a class=\"internal-link\" data-href=\"spells-and-runes.md\" href=\"architecture/systems/spells/spells-and-runes.html\" target=\"_self\" rel=\"noopener nofollow\">Spells and Runes</a> - Casting mechanics and rune interactions Pre-game Selection: Choose spells from available collection\nDeck Constraints: ⚠️ NEEDS DISCUSSION - Specific deck building rules TBD\nSpell Relationships: ⚠️ SUGGESTION - Consider thematic spell interactions Risk/Reward: Power vs. risk trade-offs\nBuild Balance: ⚠️ NEEDS DISCUSSION - Balance between pure and cursed builds\nImplementation: ⚠️ NEEDS DESIGN - Specific curse mechanics and effects\n<br>CPU-Only Design: See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/technical-decisions.html\" data-href=\"technical-decisions\" target=\"_self\">technical-decisions</a> for processing architecture rationale.\nCore Engine: Direct texture writes to rune layer KeyValue\nPhysics Engine: Queue forces for tile movement\nPlayer Input: Immediate response to spell casting actions Core Engine: Required for rune placement and tile data access\nUser Interface: Integration with spell hand and mana flower display\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Spell System","level":1,"id":"Spell_System_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Core Responsibilities","level":2,"id":"Core_Responsibilities_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Components","level":3,"id":"Core_Components_0"},{"heading":"Key Mechanics","level":2,"id":"Key_Mechanics_0"},{"heading":"Customization Features","level":2,"id":"Customization_Features_0"},{"heading":"Deck Building","level":3,"id":"Deck_Building_0"},{"heading":"Curse System","level":3,"id":"Curse_System_0"},{"heading":"Processing Model","level":2,"id":"Processing_Model_0"},{"heading":"Integration Points","level":3,"id":"Integration_Points_0"},{"heading":"Dependencies","level":2,"id":"Dependencies_0"}],"links":["architecture/systems/spells/mana-system.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/customization.html","architecture/systems/spells/cpu-architecture.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells-and-runes.html","architecture/general/technical-decisions.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/spells.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506335,"modifiedTime":1760380506335,"sourceSize":2194,"sourcePath":"architecture/systems/spells/spells.md","exportPath":"architecture/systems/spells/spells.html","showInTree":true,"treeOrder":46,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/spells/spells-and-runes.html":{"title":"spells-and-runes","icon":"","description":"Casting mechanics, rune lifecycle, and spell combinations.\nSelection: Player chooses spell from hand\nValidation: Check mana cost and target range\nExecution: Place runes according to spell pattern\nCost: Exhaust required mana flowers\nCooldown: Start mana flower recharge timers Mana Cost: Specific mana types and quantities required\nRange: Maximum targeting distance from caster\nPattern: Grid layout of runes placed around target\nEffects: Rune types, forces, and delays in pattern\nMana Requirements: Must have sufficient flowers of correct types\nRange Limits: Target must be within spell's maximum range\nObstruction Checks: ⚠️ NEEDS DESIGN - Line of sight or other targeting restrictions\nCooldown Status: Cannot cast if required mana flowers still recharging\nType: Determines transformation effects (fire, ice, force, etc.)\nForce: Velocity applied when triggered Delay: Countdown timer before activation Placement: Created by spell casting on rune layer\nDelay: Countdown each CPU processing cycle\nTriggering: Apply transformations and forces when delay reaches zero\nCombination: Merge with other runes on same tile\nRemoval: Clean up spent runes after effects applied\nPurpose: Create spell combinations.Automatic Merging: Multiple runes on same tile combine automatically\nForce Combination: Result has combined force vectors\nDelay Resolution: Combined rune uses minimum delay of components\nType Resolution: New type determined by combination rules table⚠️ NEEDS SPECIFICATION: Detailed combination rules and outcomesFire + Water: Steam rune with area effect\nEarth + Air: Dust storm with movement effects\nForce + Force: Amplified knockback effects\nConflicting Types: Some combinations may cancel forces or produce no runeSimple Rules: Basic combination table creates complex interactions\nStrategic Depth: Players can plan multi-spell combinations\nUnpredictable Results: Opponent spells can interfere with combinations\nHand Size: ⚠️ TBD based on UI and gameplay needs\nReplenishment: Draw from personal spell deck each turn\nDeck Construction: Pre-game selection from available spells\nTurn-based Drawing: New spells available each turn\nDeck Cycling: ⚠️ NEEDS DESIGN - What happens when deck is exhausted?\nHand Limits: Maximum spells available at once for UI and balanceForce Application: Runes queue forces for physics processing\nTiming Coordination: Rune triggers coordinate with physics updates\nMovement Effects: Spell effects can alter tile velocitiesEnvironmental Triggers: Runes can trigger environmental transformations\nRule Interactions: Spell effects interact with world transformation rules\nCompound Effects: Spells + environment create complex interactionsRune Placement: Direct texture writes to rune layer\nState Queries: Read tile data for spell validation\nLayer Coordination: Ensure proper interaction between spell effects and world stateComplex Logic: Conditional spell rules without shader limitations\nEasy Debugging: Step-through debugging of spell logic\nImmediate Response: No GPU compilation delays for spell modifications\nDynamic Rules: Runtime spell behavior changes possible⚠️ FUTURE CONSIDERATION: Moving some spell processing to GPU if CPU becomes bottleneck\nSimple rune countdown could be GPU-accelerated\nComplex combination logic likely remains CPU-bound\n⚠️ NEEDS RESOLUTION:\nHand Size Balancing: Too many spells overwhelming, too few limiting strategy\nDeck Exhaustion: What happens when player runs out of spells?\nCombination Complexity: How complex should rune interactions become?\nPerformance Scaling: CPU spell processing vs. large numbers of active runes\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Spells and Runes","level":1,"id":"Spells_and_Runes_0"},{"heading":"Spell Casting Process","level":2,"id":"Spell_Casting_Process_0"},{"heading":"Casting Flow","level":3,"id":"Casting_Flow_0"},{"heading":"Spell Properties","level":3,"id":"Spell_Properties_0"},{"heading":"Validation Rules","level":3,"id":"Validation_Rules_0"},{"heading":"Rune System","level":2,"id":"Rune_System_0"},{"heading":"Rune Properties","level":3,"id":"Rune_Properties_0"},{"heading":"Rune Lifecycle","level":3,"id":"Rune_Lifecycle_0"},{"heading":"Rune Interactions","level":2,"id":"Rune_Interactions_0"},{"heading":"Combination Mechanics","level":3,"id":"Combination_Mechanics_0"},{"heading":"Combination Examples","level":3,"id":"Combination_Examples_0"},{"heading":"Emergent Complexity","level":3,"id":"Emergent_Complexity_0"},{"heading":"Spell Hand Management","level":2,"id":"Spell_Hand_Management_0"},{"heading":"Hand Mechanics","level":3,"id":"Hand_Mechanics_0"},{"heading":"Spell Availability","level":3,"id":"Spell_Availability_0"},{"heading":"Integration with Game Systems","level":2,"id":"Integration_with_Game_Systems_0"},{"heading":"Physics Engine Integration","level":3,"id":"Physics_Engine_Integration_0"},{"heading":"Reaction Engine Integration","level":3,"id":"Reaction_Engine_Integration_0"},{"heading":"Core Engine Integration","level":3,"id":"Core_Engine_Integration_0"},{"heading":"Performance Considerations","level":2,"id":"Performance_Considerations_0"},{"heading":"CPU Processing Benefits","level":3,"id":"CPU_Processing_Benefits_0"},{"heading":"Potential Optimizations","level":3,"id":"Potential_Optimizations_0"},{"heading":"Design Challenges","level":2,"id":"Design_Challenges_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/spells-and-runes.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506335,"modifiedTime":1760380506335,"sourceSize":4502,"sourcePath":"architecture/systems/spells/spells-and-runes.md","exportPath":"architecture/systems/spells/spells-and-runes.html","showInTree":true,"treeOrder":47,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/systems/tools/tools.html":{"title":"tools","icon":"","description":"Status: Incomplete documentation The Tools system provides development utilities and visual editing capabilities for Reaction v2.The tools system includes:\nVisual rule editor for creating and testing transformation rules\nDevelopment debugging utilities\nPerformance profiling tools\nAsset management utilities\nDocumentation incomplete - editor interface and functionality to be detailedDocumentation incomplete - debugging and profiling tools to be documentedDocumentation incomplete - asset processing and management tools to be added","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Tools System","level":1,"id":"Tools_System_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Visual Rule Editor","level":2,"id":"Visual_Rule_Editor_0"},{"heading":"Development Utilities","level":2,"id":"Development_Utilities_0"},{"heading":"Asset Pipeline","level":2,"id":"Asset_Pipeline_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/tools/tools.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506336,"modifiedTime":1760380506336,"sourceSize":688,"sourcePath":"architecture/systems/tools/tools.md","exportPath":"architecture/systems/tools/tools.html","showInTree":true,"treeOrder":49,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/ui/ui.html":{"title":"ui","icon":"","description":"Status: 🚧 Stub - This system documentation needs completionUser interface system for game controls, HUD elements, and player interaction.TODO: Add links to UI components when implemented:\nInterface layout and component hierarchy\nInput handling and interaction patterns\nHUD elements and game overlays\nMenu systems and navigation\nTODO: Document UI system responsibilities:\nGame HUD: Mana flowers, spell hand, player status indicators\nGame Controls: Spell casting interface, movement controls, action queuing\nMenu Systems: Main menu, settings, deck building, game lobby\nVisual Feedback: Action confirmations, error states, loading indicators\nTODO: Define major UI components:\nMana Flower Display: Visual representation of mana types and recharge status\nSpell Hand Interface: Spell selection and casting controls\nGrid Overlay: Tile highlighting, targeting cursors, range indicators\nAction Queue Visualization: Preview of queued player actions\nGame Status: Timer, player health, elimination status\nTODO: Add design guidelines:\nClarity: Clear visual hierarchy and information priority\nResponsiveness: Immediate feedback for all player actions\nAccessibility: Keyboard navigation, screen reader support, color accessibility\nScalability: Support for different screen sizes and resolutions\nTODO: Document system integrations:\nInput System: Mouse, keyboard, and touch input handling\nRenderer: UI rendering pipeline and performance considerations\nGame State: Real-time updates from game simulation\nSpell System: Integration with spell casting and mana management\n🚧 This file is a stub and needs completion","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"User Interface System","level":1,"id":"User_Interface_System_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"UI Components","level":2,"id":"UI_Components_0"},{"heading":"Design Principles","level":2,"id":"Design_Principles_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/ui/ui.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506336,"modifiedTime":1760380506337,"sourceSize":2063,"sourcePath":"architecture/systems/ui/ui.md","exportPath":"architecture/systems/ui/ui.html","showInTree":true,"treeOrder":51,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/systems.html":{"title":"systems","icon":"","description":"Complete documentation for the Reaction v2 game engine.\n<a class=\"internal-link\" data-href=\"core/core.md\" href=\"architecture/systems/core/core.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Core Engine - Central coordination and tile data management\n<br><a class=\"internal-link\" data-href=\"spells/spells.md\" href=\"architecture/systems/spells/spells.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Spell System - Player spellcasting and mana management\n<br><a class=\"internal-link\" data-href=\"physics/physics.md\" href=\"architecture/systems/physics/physics.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Physics Engine - GPU-accelerated tile movement and collisions\n<br><a class=\"internal-link\" data-href=\"reactions/reactions.md\" href=\"architecture/systems/reactions/reactions.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Reaction Engine - Rule-based environmental transformations\n<br><a class=\"internal-link\" data-href=\"rendering/rendering.md\" href=\"architecture/systems/rendering/rendering.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Renderer - Visual display and UI rendering\n<br><a class=\"internal-link\" data-href=\"multiplayer/multiplayer.md\" href=\"architecture/systems/multiplayer/multiplayer.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Multiplayer - Real-time PvP networking and client prediction\n<br><a class=\"internal-link\" data-href=\"ui/ui.md\" href=\"architecture/systems/ui/ui.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>User Interface - Game controls, HUD elements, and player interaction\n<br><a class=\"internal-link\" data-href=\"config/config.md\" href=\"architecture/systems/config/config.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Configuration - System settings and runtime parameters\n<br><a class=\"internal-link\" data-href=\"gpu/gpu.md\" href=\"architecture/systems/gpu/gpu.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>GPU Manager - WebGPU resource management and coordination\n<br><a class=\"internal-link\" data-href=\"tools.md\" href=\"architecture/systems/tools/tools.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Tools - Development utilities and visual rule editor <br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"legacy/legacy.html\" data-href=\"legacy\" aria-label=\"legacy\" data-tooltip-position=\"top\" target=\"_self\">Legacy V1 Analysis</a> - V1 system concepts for V2 development reference <br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"gameplay/gameplay.html\" data-href=\"gameplay\" aria-label=\"gameplay\" data-tooltip-position=\"top\" target=\"_self\">Gameplay Mechanics</a> - Core rules and player systems\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"development/development.html\" data-href=\"development\" aria-label=\"development\" data-tooltip-position=\"top\" target=\"_self\">Development Workflow</a> - Setup, testing, and build processes <br>New to the project? Start with <a class=\"internal-link\" data-href=\"architecture/overview.md\" href=\".html\" target=\"_self\" rel=\"noopener nofollow\">Architecture Overview</a>\n<br>Want to contribute? See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"development/getting-started.html\" data-href=\"getting-started\" aria-label=\"getting-started\" data-tooltip-position=\"top\" target=\"_self\">Development Getting Started</a> and cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"development/development_principles.html\" data-href=\"DEVELOPMENT_PRINCIPLES\" aria-label=\"DEVELOPMENT_PRINCIPLES\" data-tooltip-position=\"top\" target=\"_self\">Development Principles</a>\nLooking for specific system? Use the navigation above\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Reaction v2 Documentation","level":1,"id":"Reaction_v2_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Systems","level":3,"id":"Systems_0"},{"heading":"Reference","level":3,"id":"Reference_0"},{"heading":"Game Design &amp; Development","level":3,"id":"Game_Design_&_Development_0"},{"heading":"Getting Started","level":2,"id":"Getting_Started_0"}],"links":["architecture/systems/core/core.html","architecture/systems/spells/spells.html","architecture/systems/physics/physics.html","architecture/systems/reactions/reactions.html","architecture/systems/rendering/rendering.html","architecture/systems/multiplayer/multiplayer.html","architecture/systems/ui/ui.html","architecture/systems/config/config.html","architecture/systems/gpu/gpu.html","architecture/systems/tools/tools.html","legacy/legacy.html","gameplay/gameplay.html","development/development.html",".html","development/getting-started.html","development/development_principles.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/systems.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506336,"modifiedTime":1760380506336,"sourceSize":1650,"sourcePath":"architecture/systems/systems.md","exportPath":"architecture/systems/systems.html","showInTree":true,"treeOrder":52,"backlinks":["architecture/architecture.html"],"type":"markdown"},"architecture/architecture.html":{"title":"architecture","icon":"","description":"High-level system design, technical decisions, and performance considerations for Reaction v2.\ncross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/overview.html\" data-href=\"overview\" aria-label=\"overview\" data-tooltip-position=\"top\" target=\"_self\">System Overview</a> - Complete architectural design and module relationships\n<br><a class=\"internal-link\" data-href=\"general/general.md\" href=\"architecture/general/general.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>General Architecture - Core architectural concepts and design patterns <br><a class=\"internal-link\" data-href=\"systems/systems.md\" href=\"architecture/systems/systems.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Systems - Individual system modules and implementations\nModular Design: Modules with focused responsibilitiesWebGPU Processing: Physics, reactions, and rendering use GPU computeDeterministic Requirements: Identical inputs must produce identical outputs for PvPActive Region System: Process only chunks with changing tiles⚠️ Unsolved Issues Requiring Design Work:\nFrame rate coordination between physics, reactions, and rendering systems\nGPU thread execution determinism guarantees\nSpecific rule compilation pipeline implementation Tile Storage: 4 layers (Ground, Object, Air, Rune) with bit-packed 32-bit tiles\nChunk Size: 32×32 tiles (balances GPU workgroup efficiency with memory overhead)\nProcessing Order: Input → Physics → Runes → Reactions → Render\nCommunication: Core Engine coordinates data flow between modules\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Architecture Documentation","level":1,"id":"Architecture_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Architecture","level":3,"id":"Core_Architecture_0"},{"heading":"System Implementations","level":3,"id":"System_Implementations_0"},{"heading":"Architectural Approach","level":2,"id":"Architectural_Approach_0"},{"heading":"Major Technical Challenges","level":2,"id":"Major_Technical_Challenges_0"},{"heading":"System Summary","level":2,"id":"System_Summary_0"}],"links":["architecture/general/overview.html","architecture/general/general.html","architecture/systems/systems.html"],"author":"","coverImageURL":"","fullURL":"architecture/architecture.html","pathToRoot":"..","attachments":[],"createdTime":1760380506316,"modifiedTime":1760380506316,"sourceSize":1425,"sourcePath":"architecture/architecture.md","exportPath":"architecture/architecture.html","showInTree":true,"treeOrder":53,"backlinks":["docs.html","index.html"],"type":"markdown"},"development/building-documentation.html":{"title":"building-documentation","icon":"","description":"The documentation system uses Obsidian for authoring (in docs/) and exports to HTML for GitHub Pages deployment via git subtree.\nObsidian with \"Webpage HTML Export\" plugin installed\nGit command line tools Open the docs/ folder as a vault in Obsidian\nEither: Click the \"Export as HTML\" button (added by Webpage HTML Export plugin)\nOr run command \"Webpage HTML Export: Export using previous settings\" Ensure export target is set to build/docs\nAfter exporting, commit and push the changes in the worktree:cd build/docs\ngit add .\ngit commit -m \"Update documentation\"\ngit push\ncd ../.. Documentation source files (Markdown) live in docs/ on the main branch\nBuilt HTML files are in build/docs/ which is a git worktree of the gh-pages branch\nThe worktree allows direct commits to gh-pages without switching branches\nChanges to documentation require rebuilding and redeploying\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Building Documentation","level":1,"id":"Building_Documentation_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Prerequisites","level":2,"id":"Prerequisites_0"},{"heading":"Build Process","level":2,"id":"Build_Process_0"},{"heading":"1. Export Documentation from Obsidian","level":3,"id":"1._Export_Documentation_from_Obsidian_0"},{"heading":"2. Deploy to GitHub Pages","level":3,"id":"2._Deploy_to_GitHub_Pages_0"},{"heading":"Notes","level":2,"id":"Notes_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"development/building-documentation.html","pathToRoot":"..","attachments":[],"createdTime":1760380506338,"modifiedTime":1760380506338,"sourceSize":1084,"sourcePath":"development/building-documentation.md","exportPath":"development/building-documentation.html","showInTree":true,"treeOrder":55,"backlinks":["index.html"],"type":"markdown"},"development/development.html":{"title":"development","icon":"","description":"Setup, workflow, and development processes for Reaction v2.\n<a class=\"internal-link\" data-href=\"getting-started.md\" href=\"development/getting-started.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Getting Started - Project setup and first build\n<br><a class=\"internal-link\" data-href=\"DEVELOPMENT_PRINCIPLES.md\" href=\"development/development_principles.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Development Principles - Core values and guidelines for contributors\n<br><a class=\"internal-link\" data-href=\"DOCUMENTATION_STRUCTURE.md\" href=\"development/documentation_structure.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Documentation Structure - How to organize and navigate documentation <br><a class=\"internal-link\" data-href=\"tasklist.md\" href=\"development/tasklist.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Task List - Auto-generated TODO items, warnings, and documentation status\nnpm install\nnpm run dev # Development server\nnpm run test # Test suite npm run build # Production build\nnpm run lint # ESLint\nnpm run format # Prettier Core types: src/core/types.ts\nSpell types: src/spell-system/types.ts\nDocumentation: docs/\nArchitecture: docs/architecture/\n<br>See <a class=\"internal-link\" data-href=\"DEVELOPMENT_PRINCIPLES.md\" href=\"development/development_principles.html\" target=\"_self\" rel=\"noopener nofollow\">Development Principles</a> for core values and <a class=\"internal-link\" data-href=\"DOCUMENTATION_STRUCTURE.md\" href=\"development/documentation_structure.html\" target=\"_self\" rel=\"noopener nofollow\">Documentation Structure</a> for information organization guidelines.","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Development Documentation","level":1,"id":"Development_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Getting Started","level":3,"id":"Getting_Started_0"},{"heading":"Project Management","level":3,"id":"Project_Management_0"},{"heading":"Quick Start","level":2,"id":"Quick_Start_0"},{"heading":"Development Commands","level":3,"id":"Development_Commands_0"},{"heading":"Project Structure","level":3,"id":"Project_Structure_0"},{"heading":"Development Principles","level":2,"id":"Development_Principles_0"},{"heading":"Development Guidelines","level":3,"id":"Development_Guidelines_0"}],"links":["development/getting-started.html","development/development_principles.html","development/documentation_structure.html","development/tasklist.html","development/development_principles.html","development/documentation_structure.html"],"author":"","coverImageURL":"","fullURL":"development/development.html","pathToRoot":"..","attachments":[],"createdTime":1760380506338,"modifiedTime":1760380506338,"sourceSize":1203,"sourcePath":"development/development.md","exportPath":"development/development.html","showInTree":true,"treeOrder":56,"backlinks":["docs.html","architecture/systems/systems.html","index.html"],"type":"markdown"},"development/development_principles.html":{"title":"DEVELOPMENT_PRINCIPLES","icon":"","description":"\nNever fabricate performance numbers, statistics, or benchmarks\nMark personal ideas as such - don't present speculation as team decisions\nSay \"I don't know\" when you don't know\nUncertainty is better than false confidence Code should explain itself through naming and structure\nIf you need extensive comments to explain what code does, rewrite it\nMagic numbers and unclear constants are tech debt\nOptimize for the next person who reads your code Distinguish between your ideas and team decisions\nMake it easy for others to understand and build on your work\nAsk questions when design decisions aren't clear\nShare context behind your choices Use descriptive names for functions, variables, and files\nHandle error cases explicitly - don't ignore or hide failures\nPrefer simple, obvious solutions over clever optimizations\nDocument the \"why\" behind non-obvious business logic Be honest about what's decided vs. what you're proposing\nInclude enough context for someone to understand and challenge your reasoning\nAvoid inventing performance claims or user behavior assumptions\nNote when something needs team input or further research Understand the problem before jumping to solutions\nConsider the person who will maintain this code in 6 months\nChoose consistency with existing patterns over personal preference\nMeasure performance claims rather than guessing Write clear, descriptive commit messages that explain the \"why\" not just the \"what\"\nMake atomic commits - each commit should represent one logical change\nNever commit broken code or failing tests to main branch\nUse branches for feature development and merge via pull requests\nReview your own changes before committing - check diffs carefully\nKeep commits focused - avoid mixing unrelated changes\nTest your changes locally before pushing\nBefore committing work, ask:\nCan someone else understand this without asking me questions?\nAm I making any claims I can't back up?\nIs this the simplest solution that solves the actual problem?\nHave I clearly indicated what needs team discussion?\nAre my commit messages clear and descriptive?\nHave I tested my changes locally?\nThe goal is sustainable development where team members can confidently build on each other's work.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Development Principles","level":1,"id":"Development_Principles_0"},{"heading":"Core Values","level":2,"id":"Core_Values_0"},{"heading":"Truth Over Polish","level":3,"id":"Truth_Over_Polish_0"},{"heading":"Clarity Over Cleverness","level":3,"id":"Clarity_Over_Cleverness_0"},{"heading":"Collaboration Over Ego","level":3,"id":"Collaboration_Over_Ego_0"},{"heading":"Practical Guidelines","level":2,"id":"Practical_Guidelines_0"},{"heading":"When Writing Code","level":3,"id":"When_Writing_Code_0"},{"heading":"When Writing Documentation","level":3,"id":"When_Writing_Documentation_0"},{"heading":"When Making Decisions","level":3,"id":"When_Making_Decisions_0"},{"heading":"Source Control Practices","level":3,"id":"Source_Control_Practices_0"},{"heading":"Quality Questions","level":2,"id":"Quality_Questions_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"development/development_principles.html","pathToRoot":"..","attachments":[],"createdTime":1760380506337,"modifiedTime":1760380506337,"sourceSize":2569,"sourcePath":"development/DEVELOPMENT_PRINCIPLES.md","exportPath":"development/development_principles.html","showInTree":true,"treeOrder":57,"backlinks":["development/development.html","architecture/systems/systems.html","index.html"],"type":"markdown"},"development/documentation_structure.html":{"title":"DOCUMENTATION_STRUCTURE","icon":"","description":"Documentation should function as a navigational search tree where each level provides just enough information to guide readers to the right destination.Parent nodes are signposts, not encyclopedias\nOverview documents help readers navigate to specifics\nInclude enough detail to make informed navigation choices\nAvoid comprehensive coverage at high levels\nNo redundant information\nEach piece of information has one authoritative location\nLink to sources rather than copying content\nUpdate links when information moves\nHierarchical information flow\nOverview → Category → Implementation Details\nGeneral concepts → Specific examples\nArchitecture → Component details\nOverview Documents\nList what's covered and where to find it\nProvide context for understanding relationships\nInclude links to detailed documentation\nDon't duplicate content from linked pages\nCategory Documents\nExplain concepts specific to that category\nDirect readers to implementation details\nShow how pieces relate within the category\nLink to related categories when relevant\nDetail Documents\nContain complete implementation information\nReference but don't duplicate architectural context\nLink back to parent concepts when helpful\nFocus on specific, actionable content\nTop-Down Discovery\nStart with high-level goals or concepts\nFollow links to increasingly specific information\nEach level adds detail without repeating previous levels\nCross-Referencing\nLink to related concepts at the same level\nReference authoritative sources for shared information\nAvoid circular documentation dependencies\nMaintenance\nWhen information changes, update it in one place\nCheck that navigation paths remain clear\nRemove or redirect broken internal links\nEnsure new content fits the existing hierarchy\nThe goal is that readers can efficiently find exactly what they need without encountering duplicate or outdated information.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Documentation Structure","level":1,"id":"Documentation_Structure_0"},{"heading":"Search Tree Architecture","level":2,"id":"Search_Tree_Architecture_0"},{"heading":"Core Principles","level":3,"id":"Core_Principles_0"},{"heading":"Practical Guidelines","level":3,"id":"Practical_Guidelines_0"},{"heading":"Navigation Patterns","level":3,"id":"Navigation_Patterns_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"development/documentation_structure.html","pathToRoot":"..","attachments":[],"createdTime":1760380506337,"modifiedTime":1760380506338,"sourceSize":2114,"sourcePath":"development/DOCUMENTATION_STRUCTURE.md","exportPath":"development/documentation_structure.html","showInTree":true,"treeOrder":58,"backlinks":["development/development.html"],"type":"markdown"},"development/getting-started.html":{"title":"getting-started","icon":"","description":"Project setup and development environment configuration for Reaction v2.\nNode.js: Latest LTS version recommended\nnpm: Comes with Node.js installation\nWebGPU-compatible browser: Chrome 113+, Firefox 113+, or Safari Technology Preview GPU: WebGPU-compatible graphics card\nMemory: 8GB+ RAM recommended for development\nStorage: 2GB+ free space for dependencies and build artifacts\nnpm install\nnpm run dev\nThis starts the development server with hot reload and debugging enabled.\nOpen browser to development server URL (usually http://localhost:5173)\nCheck browser console for WebGPU support\nVerify no initial compilation errors\nnpm run dev # Development server with hot reload\nnpm run test # Run test suite\nnpm run build # Production build\nnpm run lint # ESLint code checking npm run format # Prettier code formatting\n.\n├── src/ # Source code\n│ ├── core/ # Core Engine module\n│ ├── spell-system/ # Spell System module │ ├── physics-engine/ # Physics Engine module\n│ ├── reaction-engine/ # Reaction Engine module\n│ ├── renderer/ # Renderer module\n│ └── tools/ # Development tools\n├── docs/ # Documentation\n├── tests/ # Test files\n└── package.json # Project configuration\nProblem: Browser doesn't support WebGPU\nSolution: Use Chrome 113+, Firefox 113+, or enable experimental featuresProblem: TypeScript compilation errors\nSolution: Run npm run lint and fix reported issuesProblem: Development server running slowly\nSolution: Close other applications, check GPU drivers are updated\nRead Architecture: Start with cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/overview.html\" data-href=\"overview\" aria-label=\"overview\" data-tooltip-position=\"top\" target=\"_self\">Architecture Overview</a>\nExplore Systems: Browse individual system documentation\nRun Tests: Verify everything works with npm run test\nMake Changes: Try modifying code and see hot reload in action\n⚠️ SUGGESTION: Consider establishing:\nIDE configuration and recommended extensions\nWebGPU debugging extensions\nPerformance profiling tools\nGPU shader debugging setup\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Getting Started","level":1,"id":"Getting_Started_0"},{"heading":"Prerequisites","level":2,"id":"Prerequisites_0"},{"heading":"Required Software","level":3,"id":"Required_Software_0"},{"heading":"Hardware Requirements","level":3,"id":"Hardware_Requirements_0"},{"heading":"Initial Setup","level":2,"id":"Initial_Setup_0"},{"heading":"1. Project Installation","level":3,"id":"1._Project_Installation_0"},{"heading":"2. Development Server","level":3,"id":"2._Development_Server_0"},{"heading":"3. Verify Setup","level":3,"id":"3._Verify_Setup_0"},{"heading":"Development Workflow","level":2,"id":"Development_Workflow_0"},{"heading":"Available Commands","level":3,"id":"Available_Commands_0"},{"heading":"File Structure Overview","level":3,"id":"File_Structure_Overview_0"},{"heading":"Common Issues","level":2,"id":"Common_Issues_0"},{"heading":"WebGPU Not Available","level":3,"id":"WebGPU_Not_Available_0"},{"heading":"Build Failures","level":3,"id":"Build_Failures_0"},{"heading":"Performance Issues","level":3,"id":"Performance_Issues_0"},{"heading":"Next Steps","level":2,"id":"Next_Steps_0"},{"heading":"Development Environment","level":2,"id":"Development_Environment_0"},{"heading":"Development Environment Setup","level":3,"id":"Development_Environment_Setup_0"}],"links":["architecture/general/overview.html"],"author":"","coverImageURL":"","fullURL":"development/getting-started.html","pathToRoot":"..","attachments":[],"createdTime":1760380506339,"modifiedTime":1760380506339,"sourceSize":2709,"sourcePath":"development/getting-started.md","exportPath":"development/getting-started.html","showInTree":true,"treeOrder":59,"backlinks":["development/development.html","architecture/systems/systems.html","index.html"],"type":"markdown"},"development/tasklist.html":{"title":"tasklist","icon":"","description":"Automatically generated task list from all TODO items found in the documentation using Dataview.Summary of documentation completion status:Organized view of TODO items grouped by file:<a data-tooltip-position=\"top\" aria-label=\"architecture/systems/config/config.md\" data-href=\"architecture/systems/config/config.md\" href=\"architecture/systems/config/config.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">config</a>: Define configuration system architectureDocument configuration file formatsAdd runtime configuration managementDocument environment-specific settings<br><a data-tooltip-position=\"top\" aria-label=\"docs.md\" data-href=\"docs.md\" href=\"docs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">docs</a>: Complete main documentation indexAdd project overview sectionAdd getting started quick links<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/ghost-simulation.md\" data-href=\"architecture/general/ghost-simulation.md\" href=\"architecture/general/ghost-simulation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ghost-simulation</a>: NEEDS IMPLEMENTATION: Performance benchmarking of different complexity levelsNEEDS IMPLEMENTATION: User experience testing of ghost feedback effectivenessNEEDS IMPLEMENTATION: Integration testing with action queue and timing systems<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/state-management.md\" data-href=\"architecture/general/state-management.md\" href=\"architecture/general/state-management.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">state-management</a>: NEEDS IMPLEMENTATION: Performance benchmarking of snapshot creation overheadNEEDS IMPLEMENTATION: Network bandwidth testing with delta compressionNEEDS IMPLEMENTATION: Cross-platform determinism validation suite<br><a data-tooltip-position=\"top\" aria-label=\"architecture/systems/ui/ui.md\" data-href=\"architecture/systems/ui/ui.md\" href=\"architecture/systems/ui/ui.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ui</a>: Define UI system architectureDocument component hierarchyAdd interaction patternsDocument accessibility requirements<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/variable-timing.md\" data-href=\"architecture/general/variable-timing.md\" href=\"architecture/general/variable-timing.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">variable-timing</a>: NEEDS IMPLEMENTATION: Detailed performance benchmarking of time slice overheadNEEDS IMPLEMENTATION: Integration testing with existing Core Engine texture managementNEEDS IMPLEMENTATION: Multiplayer synchronization validationFiles with warnings or items requiring team discussion:<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/data-flow.md\" data-href=\"architecture/general/data-flow.md\" href=\"architecture/general/data-flow.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">data-flow</a>: OUTDATED DOCUMENT: Physics system has been updated and this document no longer reflects current architectural directionNEEDS TEAM DISCUSSION: Optimal time slice count (8 vs 4 vs 16)NEEDS TEAM DISCUSSION: Performance impact of deterministic GPU orderingNEEDS TEAM DISCUSSION: Ghost simulation complexity vs performance trade-offs<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/ghost-simulation.md\" data-href=\"architecture/general/ghost-simulation.md\" href=\"architecture/general/ghost-simulation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ghost-simulation</a>: PROPOSED SYSTEM: Predictive action visualization system shows players their queued actionsNEEDS TEAM DISCUSSION: Default simulation complexity level (minimal/basic/detailed)NEEDS TEAM DISCUSSION: Ghost prediction accuracy vs performance trade-offsNEEDS TEAM DISCUSSION: Visual design for ghost representation (transparency, colors, indicators)<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/state-management.md\" data-href=\"architecture/general/state-management.md\" href=\"architecture/general/state-management.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">state-management</a>: PROPOSED SYSTEM: Unified state management approach serves both single-player and multiplayerNEEDS TEAM DISCUSSION: Snapshot retention policy (current proposal: 5 seconds)NEEDS TEAM DISCUSSION: Delta compression vs full snapshot frequency (current proposal: every 60 frames)NEEDS TEAM DISCUSSION: Rollback window limits for client prediction<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/variable-timing.md\" data-href=\"architecture/general/variable-timing.md\" href=\"architecture/general/variable-timing.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">variable-timing</a>: PROPOSED SYSTEM: Time slice scheduling system enables variable player action timingNEEDS TEAM DISCUSSION: Optimal slice count (current proposal: 8 slices per frame)NEEDS TEAM DISCUSSION: Speed multiplier ranges (current proposal: 0.1x to 10x)NEEDS TEAM DISCUSSION: Ghost prediction complexity vs performance trade-offsFiles marked as stubs that need to be completed:Note: This task list is automatically generated using Dataview queries. Add todo: fields to any documentation file's frontmatter to have items appear here automatically.Usage: Add TODO items to file frontmatter: todo: [\"Item 1\", \"Item 2\"]\nMark files as stubs: status: stub\nItems will automatically appear in the appropriate sections above\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Development","#TaskList"],"headers":[{"heading":"Development Task List","level":1,"id":"Development_Task_List_0"},{"heading":"Status Overview","level":2,"id":"Status_Overview_0"},{"heading":"TODO Items","level":2,"id":"TODO_Items_0"},{"heading":"Warnings and Discussion Items","level":2,"id":"Warnings_and_Discussion_Items_0"},{"heading":"Stub Files Requiring Completion","level":2,"id":"Stub_Files_Requiring_Completion_0"}],"links":["architecture/general/data-flow.html","architecture/general/ghost-simulation.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/systems/config/config.html","architecture/systems/ui/ui.html","docs.html","architecture/systems/config/config.html","docs.html","architecture/general/ghost-simulation.html","architecture/general/state-management.html","architecture/systems/ui/ui.html","architecture/general/variable-timing.html","architecture/general/data-flow.html","architecture/general/ghost-simulation.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/systems/config/config.html","docs.html","architecture/systems/ui/ui.html"],"author":"","coverImageURL":"","fullURL":"development/tasklist.html","pathToRoot":"..","attachments":[],"createdTime":1760380506339,"modifiedTime":1760380506339,"sourceSize":1233,"sourcePath":"development/tasklist.md","exportPath":"development/tasklist.html","showInTree":true,"treeOrder":60,"backlinks":["development/development.html"],"type":"markdown"},"gameplay/core-mechanics.html":{"title":"core-mechanics","icon":"","description":"Elimination: Last player standing wins. Players are eliminated when their avatar tile is destroyed.Duration: Unlimited match length - games end only when elimination occurs\nPlayer Count: Variable player count, limited only by performance constraints\nReal-Time Execution: Continuous simulation without traditional turnsNon-Turn-Based: Game runs continuously with different processes at different frequencies\nPre-Planning: Players queue actions in advance\nExecution Timing: Player actions execute at regular intervals determined by game state\nDynamic Speed: Object movement speed controlled by time delays between tile position updates\nStatus Effects: Players can be slowed, frozen, or otherwise affected by spells and environmentPlayer → Spell → World → Player: Clear action consequence chain\nPlayer casts spell\nSpell affects world tiles and environment\nWorld changes affect all players through environmental interactions\nPlayer Tiles: Players exist as tiles on the object layer\nPhysics Only: Player avatars affected by physics (velocity, collisions, forces) but never transform into other tile types\nDamage System: Players can take damage and be destroyed but maintain their tile type while alive\nMovement: Players move using same physics system as other object layer tilesDamage Sources: Tiles can deal damage, apply slow effects, or other status conditions to players\nHealing: Either no healing mechanics, or healing through specific terrain tiles\nRegeneration Strategy: No health regeneration vs. tile-based healing zones (to be playtested)\nDestruction: Players eliminated when health reaches zero, but tile type never changesPhysics-Driven: Maps generated through built-in physics simulation and tile reactions\nEmergent Terrain: World evolves naturally through rule-based transformations\nDynamic Environment: Continuous world changes create evolving strategic opportunitiesStrategic Terrain: Different tile types provide tactical advantages and challenges\nReactive Tiles: Special tiles that explode, ignite, or transform when targeted by spells\nEnvironmental Interactions: Terrain affects tactical gameplay\nSpell-Terrain Synergy: Spells designed to interact meaningfully with terrain typesSize: To be determined through playtesting for optimal performance and gameplay balance\nPerformance Scaling: Map size limited by ability to maintain 60 FPS with active player countNo Scarcity: Unlimited mana flower regeneration - focus on timing and positioning over resource conservation\nMana Recharge: 3-turn recharge cycle provides natural pacing without creating resource pressureTile-Based Escalation: Environmental changes naturally create pressure and opportunities\nNo Regeneration Alternative: Potential no-healing system to ensure permanent consequences\nEnvironmental Pressure: Reactive terrain and ongoing world changes prevent static positioningBalanced Design: Spells designed for diverse strategies\nSituational Advantage: Different spells excel in different terrain and tactical situations\nNo Power Creep: Focus on interesting combinations rather than raw damage scaling\nTerrain Understanding: Learning different tile type behaviors\nSpell Combinations: Combining rune effects Positioning: Tactical movement and area control\nTiming: Execution of pre-planned actions at optimal moments\nEnvironmental Prediction: Anticipating world changes and terrain evolution Rule Interactions: Complex behaviors arising from rule combinations\nAdaptive Strategy: Changing world state requires flexible tactical adaptation\nRisk/Reward: Curse system and aggressive positioning create choices\nLong-term Planning: Pre-planning system rewards strategic foresight\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Core Mechanics","level":1,"id":"Core_Mechanics_0"},{"heading":"Core Game Flow","level":2,"id":"Core_Game_Flow_0"},{"heading":"Victory Conditions","level":3,"id":"Victory_Conditions_0"},{"heading":"Match Structure","level":3,"id":"Match_Structure_0"},{"heading":"Player Action System","level":2,"id":"Player_Action_System_0"},{"heading":"Movement and Timing","level":3,"id":"Movement_and_Timing_0"},{"heading":"Action Flow Pattern","level":3,"id":"Action_Flow_Pattern_0"},{"heading":"Player Representation","level":2,"id":"Player_Representation_0"},{"heading":"Avatar System","level":3,"id":"Avatar_System_0"},{"heading":"Health and Damage","level":3,"id":"Health_and_Damage_0"},{"heading":"World Design","level":2,"id":"World_Design_0"},{"heading":"Map Generation","level":3,"id":"Map_Generation_0"},{"heading":"Terrain Strategy","level":3,"id":"Terrain_Strategy_0"},{"heading":"Map Constraints","level":3,"id":"Map_Constraints_0"},{"heading":"Balance and Progression","level":2,"id":"Balance_and_Progression_0"},{"heading":"Resource Management","level":3,"id":"Resource_Management_0"},{"heading":"Anti-Stalemate Mechanics","level":3,"id":"Anti-Stalemate_Mechanics_0"},{"heading":"Power Scaling","level":3,"id":"Power_Scaling_0"},{"heading":"Strategic Elements","level":2,"id":"Strategic_Elements_0"},{"heading":"Core Strategy Sources","level":3,"id":"Core_Strategy_Sources_0"},{"heading":"Depth Mechanisms","level":3,"id":"Depth_Mechanisms_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"gameplay/core-mechanics.html","pathToRoot":"..","attachments":[],"createdTime":1760380506340,"modifiedTime":1760380506340,"sourceSize":4350,"sourcePath":"gameplay/core-mechanics.md","exportPath":"gameplay/core-mechanics.html","showInTree":true,"treeOrder":62,"backlinks":["gameplay/gameplay.html"],"type":"markdown"},"gameplay/gameplay.html":{"title":"gameplay","icon":"","description":"Core game mechanics, rules, and design philosophy for Reaction v2.\n<a class=\"internal-link\" data-href=\"core-mechanics.md\" href=\"gameplay/core-mechanics.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Core Mechanics - Victory conditions, timing, and elimination rules\nGenre: Real-time PvP grid-based spellcasting game\nVictory: Last player standing (avatar tile elimination)\nCore Loop: Cast spells → Place runes → Transform environment → Tactical positioningNon-Turn-Based: Continuous simulation without traditional turns\nPre-Planning: Players can queue actions in advance\nDynamic Speed: Movement controlled by time delays between position updatesReactive World: Spells transform terrain according to rule-based systems\nTerrain Types: Different tile types provide tactical advantages\nEvolving World: Continuous world changes create evolving opportunitiesNo Scarcity: Unlimited mana regeneration - focus on timing over conservation\nRecharge Timing: 3-turn recharge cycle provides natural rhythm\nAllocation Choice: Specialization vs. flexibility in mana allocation","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Gameplay Documentation","level":1,"id":"Gameplay_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Mechanics","level":3,"id":"Core_Mechanics_0"},{"heading":"Game Overview","level":2,"id":"Game_Overview_0"},{"heading":"Key Design Principles","level":2,"id":"Key_Design_Principles_0"},{"heading":"Real-Time Strategy","level":3,"id":"Real-Time_Strategy_0"},{"heading":"Environmental Focus","level":3,"id":"Environmental_Focus_0"},{"heading":"Resource Philosophy","level":3,"id":"Resource_Philosophy_0"}],"links":["gameplay/core-mechanics.html"],"author":"","coverImageURL":"","fullURL":"gameplay/gameplay.html","pathToRoot":"..","attachments":[],"createdTime":1760380506340,"modifiedTime":1760380506341,"sourceSize":1221,"sourcePath":"gameplay/gameplay.md","exportPath":"gameplay/gameplay.html","showInTree":true,"treeOrder":63,"backlinks":["docs.html","architecture/systems/systems.html","architecture/general/overview.html","index.html"],"type":"markdown"},"legacy/legacy.html":{"title":"legacy","icon":"","description":"Analysis of V1 system concepts and algorithms to inform V2 development decisions.\n<a class=\"internal-link\" data-href=\"v1-reference.md\" href=\"legacy/v1-reference.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 Rules Engine Reference - Mathematical algorithms and GPU optimization from rules system\n<br><a class=\"internal-link\" data-href=\"v1-environmental-examples.md\" href=\"legacy/v1-environmental-examples.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 Environmental Examples - Terrain interaction patterns and emergent behaviors\n<br><a class=\"internal-link\" data-href=\"v1-gpu-patterns.md\" href=\"legacy/v1-gpu-patterns.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 GPU Optimization Patterns - Compute shader strategies and memory management\n<br><a class=\"internal-link\" data-href=\"v1-visual-effects.md\" href=\"legacy/v1-visual-effects.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 Visual Effects - Rendering techniques and material systems\n<br><a class=\"internal-link\" data-href=\"v1-data-strategies.md\" href=\"legacy/v1-data-strategies.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 Data Packing Strategies - Data organization and bit-packing techniques\nReference material extracted from V1 codebase to ensure V2 developers understand the complexity and sophistication of systems being replaced. ","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Legacy V1 Reference Documentation","level":1,"id":"Legacy_V1_Reference_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"System Analysis","level":3,"id":"System_Analysis_0"},{"heading":"Purpose","level":2,"id":"Purpose_0"}],"links":["legacy/v1-reference.html","legacy/v1-environmental-examples.html","legacy/v1-gpu-patterns.html","legacy/v1-visual-effects.html","legacy/v1-data-strategies.html"],"author":"","coverImageURL":"","fullURL":"legacy/legacy.html","pathToRoot":"..","attachments":[],"createdTime":1760380506341,"modifiedTime":1760380506342,"sourceSize":878,"sourcePath":"legacy/legacy.md","exportPath":"legacy/legacy.html","showInTree":true,"treeOrder":65,"backlinks":["docs.html","architecture/systems/systems.html","index.html"],"type":"markdown"},"legacy/v1-data-strategies.html":{"title":"v1-data-strategies","icon":"","description":"This document captures data organization and packing techniques from V1 to inform V2's bit-packed tile system design. V1 demonstrated sophisticated GPU-optimized data structures that V2 developers should understand when designing the core engine's tile storage.Source: Analysis of V1 data structures (src/rules/rules.ts, src/core/types.ts, src/graphics/shaders/reaction.wgsl)\nStatus: Reference material for V2 data architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 data structures and hasn't been reviewed by the team.V1 Architecture: Rules stored as packed data in 128×128 GPU textureTexture format: r32uint (32-bit unsigned integers)\nTotal capacity: 16,384 × 32 bits = 64KB rule storage\nOrganization: 4 u32s horizontally per tile type, 16 vertically per reaction\nSpatial Organization Pattern:X-axis: tile_type * 4 + data_column (0-3)\nY-axis: reaction_index * 16 + condition_index (0-15)\nData access: textureLoad(rules, vec2u(x_coord, y_coord))\nPersonal Assessment: This layout optimized GPU cache access for spatially-related rule queries.My Interpretation: The 4×16 block per reaction ensured related data stayed within GPU cache lines.V1 Condition Data Format (9 bits per leaf condition):Bit allocation:\n- Tile type: 5 bits (0-31, accommodating enum value 20 for sand)\n- Direction: 3 bits (8 compass directions) - Distance: 1 bit (1 or 2 tiles away) Packing formula: (tile_type &lt;&lt; 4) | (direction &lt;&lt; 1) | distance_bit\nPersonal Observation: This encoding maximized information density while staying within GPU bit manipulation capabilities.V1 Internal Node Encoding (2 bits per operator):Operator types: AND=0, OR=1, NOR=2, NAND=3\nPacked format: 7 operators × 2 bits = 14 bits total\nStorage: Combined with condition value in single u32\nMy Assessment: This allowed complex logical trees in minimal memory.V1 Reaction Block Format (4 u32s × 16 conditions):u32[0]: (modes &lt;&lt; 15) | (value &lt;&lt; 10) | (bias &lt;&lt; 5) | result_tile\nu32[1]: leaf_conditions[0,1,2] packed as 3×9 bits + padding\nu32[2]: leaf_conditions[3,4,5] packed as 3×9 bits + padding u32[3]: leaf_conditions[6,7,8] packed as 3×9 bits + padding\nPersonal Note: This distributed related data across multiple texture coordinates while maintaining efficient access.Packed Leaf Storage (3 conditions per u32):Bit layout per u32: [condition2][condition1][condition0][padding]\nBit offsets: 0, 9, 18 bits (LSB-first packing)\nExtraction: (packed_data &gt;&gt; bit_offset) &amp; 0b111111111\nMy Interpretation: This maximized data density while allowing parallel condition evaluation.Contributor: Claude Status: Individual analysis of data flowPersonal Addition: These data access observations haven't been discussed with the team.V1 Rule Loading Strategy: Batch pre-fetch for condition evaluationRule queries per tile:\n- Base reaction data: 1 texture read (bias, result_tile, modes)\n- Leaf condition data: 3 texture reads (chunks 0-2, 3-5, 6-8)\n- Total per condition: 4 texture reads maximum\nPersonal Assessment: This minimized GPU memory bandwidth by batching related reads.Cache-Friendly Access Pattern:Spatial locality: Consecutive X coordinates for condition chunks\nTemporal locality: All rule data for one condition read together\nMemory coalescing: Adjacent GPU threads access adjacent texture coordinates\nMy Interpretation: V1 was designed around GPU memory hierarchy optimization.V1 Initialization Approach: Pre-populate with \"do nothing\" defaultsDefault leaf value: tile=31, direction=0, distance=1 (encoded as 496)\nDefault packed chunk: 3 leaves = 130,277,872\nDefault condition modes: value=0, modes=0 (AND tree)\nPersonal Observation: This eliminated special case handling during rule evaluation.Bounds Safety Pattern:Out-of-bounds behavior: Default values ensure safe evaluation\nMissing rules: \"Do nothing\" transformation (tile unchanged)\nInvalid data: Graceful degradation rather than crashes\nMy Assessment: This defensive programming approach ensured robust GPU execution.Contributor: Claude Status: Individual analysis needing validationPersonal Addition: These efficiency observations need team discussion for V2 design.V1 Rule Capacity (calculated from observed limits):Maximum tile types: 32 (5-bit encoding)\nMaximum reactions per type: 8\nMaximum conditions per reaction: 16\nMaximum tree complexity: 7 internal nodes + 8 leaves per condition\nStorage Efficiency:Bits per condition: 32 × 4 = 128 bits\nInformation density: ~9 bits condition data + 14 bits modes + 10 bits scoring\nUtilization: ~33 bits useful data / 128 bits storage ≈ 26% efficiency\nPersonal Assessment: V1 prioritized access speed over storage efficiency.My Interpretation: The 74% \"waste\" provided padding for GPU cache alignment and simplified addressing.V1 Memory Bandwidth Usage (estimated):Texture reads per tile evaluation:\n- Rule base data: 1 × 32 bits = 32 bits\n- Condition chunks: 3 × 32 bits = 96 bits - Shared cache reads: ~144 × 32 bits = 4,608 bits (amortized across workgroup)\nPersonal Calculation: ~128 bits rule data + ~72 bits shared cache per tileMy Assessment: V1's bandwidth usage was reasonable for the computational complexity achieved.V1 Scaling Limitations (observed):Rule texture size: Fixed 128×128 (no dynamic scaling)\nTile type limit: 32 types maximum (5-bit field)\nReaction complexity: 16 conditions maximum per reaction\nMemory usage: Linear with rule complexity\nPersonal Concern: V1's fixed limits might not scale to V2's ambitions.Research Questions:\nHow do V1's limits compare to V2's requirements?\nShould V2 use similar fixed-size allocations or dynamic scaling?\nContributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Approach: Complex multi-level packing with specialized extraction\nV2 Planned: Bit-packed tiles with ~6 bits type + velocity + custom dataPersonal Questions:\nShould V2 use V1's sophisticated bit manipulation techniques?\nHow will V2's 4-layer system affect packing complexity?\nWill V2's real-time requirements allow V1-style complex unpacking?\nMy Assessment: V2 might benefit from simpler packing schemes than V1's intricate system.V1 Evidence: GPU texture storage with cache-optimized layout\nV2 Plans: Texture ping-ponging with active region optimizationCompatibility Questions:\nCan V2's active regions use V1's texture organization principles?\nShould V2 pre-allocate like V1 or use dynamic allocation?\nHow do V2's performance targets compare to V1's memory usage patterns?\nTeam Discussion Needed: Memory allocation strategy for V2's different requirements.V1 Approach: Maximum density through complex bit manipulation\nV2 Considerations: Balance between efficiency and implementation complexityPersonal Assessment: V1's approach was sophisticated but complex to implement and debug.Research Needed: Whether V2's requirements justify V1-level complexity.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific data design considerations for V2.V1 Evidence: Complex packing achieved high data density and good GPU performance\nV2 Trade-offs: Implementation complexity vs memory/performance benefitsResearch Questions:\nWhat are V2's memory constraints compared to V1?\nHow important is V1-level data density for V2's goals?\nShould V2 prioritize development simplicity or runtime efficiency?\nTeam Discussion Needed: Performance requirements vs implementation complexity balance.V1 Success: Texture-based storage with spatial organization\nV2 Considerations: How to adapt V1's principles to V2's 4-layer systemDesign Questions:\nShould V2 layers share V1's texture organization approach?\nHow do V2's physics requirements affect data layout needs?\nWill V2's active region system benefit from V1's spatial locality patterns?\nPersonal Assessment: V2 should consider adapting V1's spatial organization principles.V1 Limitations: Fixed sizes and hardcoded limits\nV2 Opportunities: More flexible systems while preserving V1's efficiencyResearch Areas:\nDynamic data allocation vs V1's pre-allocation approach\nConfigurable complexity limits vs V1's hardcoded maximums\nRuntime data modification vs V1's compile-time rule baking\nTeam Input Needed: V2's flexibility requirements vs performance constraints.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These data architecture recommendations need team review before consideration.\nSpatial data organization for GPU cache efficiency\nBatch data access to minimize memory bandwidth\nDefault value strategies for robust error handling\nBit-level packing where density justifies complexity Layer-aware organization for V2's 4-layer tile system\nActive region integration with V1's spatial locality principles\nFlexible scaling beyond V1's fixed limits\nSimplified packing for easier development while preserving core efficiency Dynamic allocation instead of V1's fixed texture sizes\nConfigurable complexity instead of hardcoded limits\nDevelopment tools for debugging complex data structures\nPerformance monitoring for data access pattern optimization\nStatus: All recommendations need team evaluation and data architecture planning.Personal Suggestions (not discussed with team):\nPrototype V2 bit-packing using lessons from V1's techniques\nBenchmark data access patterns comparing V1 approaches with V2 requirements Design data validation tools to avoid V1's debugging complexity\nPlan scalability testing for V2's data structures under various load scenarios\nStatus: All suggestions need team review and core engine architecture planning.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"V1 Data Packing Strategies","level":1,"id":"V1_Data_Packing_Strategies_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Rule Data Packing System","level":2,"id":"👤_PERSONAL_V1_Rule_Data_Packing_System_0"},{"heading":"GPU Texture-Based Rule Storage","level":3,"id":"GPU_Texture-Based_Rule_Storage_0"},{"heading":"Bit-Level Data Encoding","level":3,"id":"Bit-Level_Data_Encoding_0"},{"heading":"Multi-Level Data Packing Strategy","level":3,"id":"Multi-Level_Data_Packing_Strategy_0"},{"heading":"👤 PERSONAL: V1 Memory Access Patterns","level":2,"id":"👤_PERSONAL_V1_Memory_Access_Patterns_0"},{"heading":"Texture Read Optimization","level":3,"id":"Texture_Read_Optimization_0"},{"heading":"Default Value Strategy","level":3,"id":"Default_Value_Strategy_0"},{"heading":"👤 PERSONAL: V1 Data Structure Efficiency","level":2,"id":"👤_PERSONAL_V1_Data_Structure_Efficiency_0"},{"heading":"Space Utilization Analysis","level":3,"id":"Space_Utilization_Analysis_0"},{"heading":"Access Pattern Efficiency","level":3,"id":"Access_Pattern_Efficiency_0"},{"heading":"Scalability Characteristics","level":3,"id":"Scalability_Characteristics_0"},{"heading":"👤 PERSONAL: V2 Data Design Implications","level":2,"id":"👤_PERSONAL_V2_Data_Design_Implications_0"},{"heading":"Bit-Packing Strategy Comparison","level":3,"id":"Bit-Packing_Strategy_Comparison_0"},{"heading":"Memory Architecture Decisions","level":3,"id":"Memory_Architecture_Decisions_0"},{"heading":"Data Density vs Simplicity Trade-offs","level":3,"id":"Data_Density_vs_Simplicity_Trade-offs_0"},{"heading":"🟠 RESEARCH: V2 Data Architecture Decisions","level":2,"id":"🟠_RESEARCH_V2_Data_Architecture_Decisions_0"},{"heading":"Packing Complexity vs Performance","level":3,"id":"Packing_Complexity_vs_Performance_0"},{"heading":"Data Layout Strategy","level":3,"id":"Data_Layout_Strategy_0"},{"heading":"Scalability and Flexibility","level":3,"id":"Scalability_and_Flexibility_0"},{"heading":"👤 PERSONAL: Recommendations for V2 Data Design","level":2,"id":"👤_PERSONAL_Recommendations_for_V2_Data_Design_0"},{"heading":"Preserve Effective V1 Concepts","level":3,"id":"Preserve_Effective_V1_Concepts_0"},{"heading":"Adapt V1 Patterns for V2","level":3,"id":"Adapt_V1_Patterns_for_V2_0"},{"heading":"Learn from V1 Limitations","level":3,"id":"Learn_from_V1_Limitations_0"},{"heading":"Next Steps for V2 Data Architecture","level":2,"id":"Next_Steps_for_V2_Data_Architecture_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-data-strategies.html","pathToRoot":"..","attachments":[],"createdTime":1760380506342,"modifiedTime":1760380506342,"sourceSize":11299,"sourcePath":"legacy/v1-data-strategies.md","exportPath":"legacy/v1-data-strategies.html","showInTree":true,"treeOrder":66,"backlinks":["legacy/legacy.html"],"type":"markdown"},"legacy/v1-environmental-examples.html":{"title":"v1-environmental-examples","icon":"","description":"This document captures environmental interaction patterns from V1 to inform V2 rule design. These examples demonstrate the complexity and emergent behaviors that V2's JSON compilation system should be capable of expressing.Source: Analysis of V1 game logic examples (src/game.ts lines 48-158)\nStatus: Reference patterns for V2 rule creationContributor: Claude Status: Individual analysis of V1 examplesPersonal Addition: This analysis of V1's environmental behaviors hasn't been discussed with the team.V1 Pattern Observed: Complex water behavior through multiple condition typesWater Flow Detection:Condition: Water north (distance 1) AND Water north (distance 2) AND NOT (Water northwest OR Water northeast)\nPersonal Interpretation: This created directional water flow by detecting \"channels\" without side branching.Water Pooling Detection:Condition: (Water north distance 1 OR 2) AND (Water east distance 1 OR 2) AND (Water south distance 1 OR 2)\nMy Assessment: This detected water collecting in corners or depressions.Water Pressure/Volume Detection:Condition: Water north AND Water east AND Water northeast AND (Water northwest OR Water southeast)\nPersonal Note: This seemed to detect \"enough water pressure\" for certain transformations.V1 Grass-to-Mud Pattern:\nTrigger: Close to water (bias: +4, total reaction bias: -3)\nResult: Net positive when water adjacent\nBehavior: Grass becomes mud near water sources\nV1 Mud-to-Water Pattern:\nMultiple conditions: Water flow (+2), surrounded by water (+2), close to water (+5), close to sand (+2)\nBase bias: -6 (requires multiple conditions to trigger)\nBehavior: Mud liquefies under water pressure\nV1 Mud-to-Grass Recovery:\nNegative conditions: Close to water (-2), kind of close to water (-1), close to mud (-1)\nBase bias: +2\nBehavior: Mud dries to grass when water recedes\nPersonal Observation: This created realistic seasonal or drought cycles in terrain.V1 Water-to-Sand Pattern:\nNegative scoring: All water-related conditions had negative values\nBase bias: -1\nInterpretation: Water became sand only when \"water pressure\" was low\nV1 Sand-to-Water Pattern:\nCondition: Surrounded by water (+2)\nBase bias: -1\nBehavior: Sand eroded when completely surrounded\nV1 Sand-to-Grass Colonization:\nCondition: Lots of grass nearby (+3)\nBase bias: -2\nBehavior: Vegetation gradually reclaimed sandy areas\nPersonal Assessment: This created believable geological processes.V1 Lava Spread Pattern:Condition: Lava northwest AND Lava northeast AND Lava north Pattern: Required 3 adjacent lava tiles in a row formation\nTarget: Grass tiles (turning them to lava)\nBase bias: -1 (requiring the specific pattern to overcome)\nPersonal Interpretation: This created lava \"fronts\" that advanced in lines rather than randomly.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These behavioral observations need team discussion for V2 design.Multiple Transformations per Tile Type: V1 allowed each tile type to have multiple possible reactions with different conditions.Example - Grass Tile Transformations:\nGrass → Mud (when near water)\nGrass → Lava (when in lava line formation) Grass → Sand (when conditions met - though this was commented out)\nPersonal Observation: This created realistic environmental competition where multiple forces could affect the same terrain.Observed Pattern: Mud ↔ Grass ↔ Sand cycles\nWet seasons: Grass → Mud → Water\nDry seasons: Water → Sand, Mud → Grass\nVegetation recovery: Sand → Grass (slow colonization)\nPersonal Assessment: V1's bias system created natural environmental cycles without explicit seasonal programming.Pattern: Many transformations required specific neighbor counts or arrangements\nWater flow: Exactly the right configuration\nLava spread: 3-tile line formation required\nVegetation growth: Multiple grass neighbors needed\nMy Interpretation: This prevented chaotic transformations and created stable intermediate states.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.Observed V1 Complexity:\nConditions checking multiple directions and distances\nLogical combinations with AND, OR, NOT operators\nNegative scoring for inhibitory effects\nDistance-based neighbor detection (1 and 2 tiles away)\nPersonal Question: Can V2's JSON format express this level of spatial complexity?Example V1 Rule Expressed in Potential V2 JSON:{ \"grass\": [ { \"id\": \"WaterFlow_Erosion\", \"action\": {\"type\": \"SetType\", \"new_type\": \"mud\"}, \"score_calculation\": { \"type\": \"Add\", \"children\": [ {\"type\": \"Constant\", \"value\": -3}, { \"type\": \"BooleanToValue\", \"condition\": { \"type\": \"AND\", \"children\": [ {\"type\": \"TileAt\", \"tile\": \"water\", \"direction\": \"N\", \"distance\": 1}, {\"type\": \"TileAt\", \"tile\": \"water\", \"direction\": \"N\", \"distance\": 2}, { \"type\": \"NOT\", \"child\": { \"type\": \"OR\", \"children\": [ {\"type\": \"TileAt\", \"tile\": \"water\", \"direction\": \"NW\", \"distance\": 1}, {\"type\": \"TileAt\", \"tile\": \"water\", \"direction\": \"NE\", \"distance\": 1} ] } } ] }, \"value_if_true\": 4, \"value_if_false\": 0 } ] } } ]\n}\nPersonal Concern: This JSON is already complex for a single V1 condition. V1 reactions had up to 16 conditions.V1 Optimization Evidence: Rules were pre-compiled into GPU textures\nComplex conditions evaluated in parallel across all tiles\nShared memory caching for neighbor access\nPersonal Assessment: V2 needs comparable optimization strategies for similar environmental complexity.Research Needed: Performance testing of JSON compilation vs V1's direct GPU implementation.Identified by: Claude Status: Team input neededPersonal Assessment: V1 examples suggest specific environmental behavior goals that V2 should validate.\nGeological cycles: Water erosion, sediment deposition, vegetation recovery\nCompetitive dynamics: Multiple environmental forces affecting same areas\nThreshold stability: Avoiding chaotic oscillations between states\nDirectional flow: Water and lava following realistic propagation patterns\nTeam Discussion Needed: Should V2 target similar environmental realism?\nHow important are complex multi-condition interactions?\nWhat level of rule complexity should V2 support?\nV1 Evidence: Creating realistic environmental behaviors required intricate condition combinations and careful bias tuning.Personal Question: Will V2's visual editor be capable of creating rules of similar sophistication?Research Needed: UI/UX design for complex rule creation without overwhelming users.Personal Recommendations (not discussed with team):\nUse V1 patterns as test cases for V2 JSON compilation system\nCreate V2 equivalents of key V1 environmental behaviors\nValidate rule complexity limits early in V2 development\nDesign rule editor to handle spatial complexity observed in V1\nStatus: All recommendations need team review and design discussion.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Environmental Interaction Examples","level":1,"id":"Environmental_Interaction_Examples_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Terrain Interaction Patterns","level":2,"id":"👤_PERSONAL_V1_Terrain_Interaction_Patterns_0"},{"heading":"Water Flow and Pooling Systems","level":3,"id":"Water_Flow_and_Pooling_Systems_0"},{"heading":"Mud Formation and Transformation","level":3,"id":"Mud_Formation_and_Transformation_0"},{"heading":"Sand Erosion and Deposition","level":3,"id":"Sand_Erosion_and_Deposition_0"},{"heading":"Fire and Lava Propagation","level":3,"id":"Fire_and_Lava_Propagation_0"},{"heading":"👤 PERSONAL: Emergent Behavior Patterns","level":2,"id":"👤_PERSONAL_Emergent_Behavior_Patterns_0"},{"heading":"Competitive Environmental Dynamics","level":3,"id":"Competitive_Environmental_Dynamics_0"},{"heading":"Seasonal and Cyclical Behaviors","level":3,"id":"Seasonal_and_Cyclical_Behaviors_0"},{"heading":"Threshold-Based State Changes","level":3,"id":"Threshold-Based_State_Changes_0"},{"heading":"👤 PERSONAL: V2 Design Implications","level":2,"id":"👤_PERSONAL_V2_Design_Implications_0"},{"heading":"Rule Complexity Requirements","level":3,"id":"Rule_Complexity_Requirements_0"},{"heading":"Performance Considerations","level":3,"id":"Performance_Considerations_0"},{"heading":"🟠 RESEARCH: Environmental Behavior Validation","level":2,"id":"🟠_RESEARCH_Environmental_Behavior_Validation_0"},{"heading":"Behavior Realism Targets","level":3,"id":"Behavior_Realism_Targets_0"},{"heading":"Rule Authoring Complexity","level":3,"id":"Rule_Authoring_Complexity_0"},{"heading":"Next Steps for V2 Examples","level":2,"id":"Next_Steps_for_V2_Examples_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-environmental-examples.html","pathToRoot":"..","attachments":[],"createdTime":1760380506342,"modifiedTime":1760380506342,"sourceSize":8492,"sourcePath":"legacy/v1-environmental-examples.md","exportPath":"legacy/v1-environmental-examples.html","showInTree":true,"treeOrder":67,"backlinks":["legacy/legacy.html"],"type":"markdown"},"legacy/v1-gpu-patterns.html":{"title":"v1-gpu-patterns","icon":"","description":"This document captures GPU optimization strategies from V1 to inform V2 compute shader design. V1's reaction compute shader contained sophisticated optimization patterns that V2 developers should understand when designing the core engine's GPU architecture.Source: Analysis of V1 compute shader (src/graphics/shaders/reaction.wgsl)\nStatus: Reference material for V2 GPU architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 GPU code and hasn't been reviewed by the team.V1 Pattern Observed: Sophisticated neighborhood caching systemWorkgroup size: 8×8 threads (64 total)\nCache dimensions: 12×12 tiles (144 total)\nBorder padding: 2 tiles in each direction\nMemory layout: array&lt;array&lt;u32, 12&gt;, 12&gt;\nCaching Algorithm:\nEach thread loads multiple cache pixels (144 pixels ÷ 64 threads = ~2.25 pixels per thread)\nLinear cache index distribution across threads\nWrap-around coordinate calculation for world boundaries\nWorkgroup barrier synchronization before shared memory reads\nPersonal Assessment: This eliminated redundant texture reads for neighbor checks, likely providing significant performance benefits.My Interpretation: The 2-tile border allowed checking neighbors at distance 1 and 2 without additional texture fetches.V1 Coordinate Calculation Pattern:Global origin: workgroup_id * workgroup_size - cache_offset\nLinear thread mapping: local_id.y * workgroup_size_x + local_id.x Wrap-around handling: (coord % tex_dims + tex_dims) % tex_dims\nPersonal Observation: This avoided branching and handled torus world topology efficiently.Cache Access Pattern:Cache position: local_coordinate + cache_offset + relative_neighbor_offset\nNo bounds checking: Relied on cache being large enough for all valid accesses\nMy Assessment: This trusted the cache dimensions to handle all possible neighbor accesses within the 2-tile radius.V1 Pattern: Dual texture approach for race condition prevention\nInput texture: Read-only during compute pass\nOutput texture: Write-only during compute pass Swap textures between frames\nPersonal Note: This matches V2's planned ping-ponging strategy, validating the approach.Contributor: Claude Status: Individual analysis of GPU optimizationPersonal Addition: These observations from V1's data access patterns haven't been discussed with the team.V1 Approach: Minimize texture reads through strategic batchingRule data chunks: 3 texture reads for 9 leaf conditions (3 conditions per u32)\nChunk storage: array&lt;u32, 3&gt; for indexed access\nPre-computation: All rule data loaded before tree evaluation\nPersonal Interpretation: This reduced GPU memory bandwidth usage by batching related data.My Assessment: V2's rule compilation should consider similar data locality optimization.V1 Pattern: Efficient tree traversal without recursionNode results array: Fixed-size array for all tree nodes\nBottom-up evaluation: Leaves first (indices 7-15), then internal nodes (6 down to 0)\nLoop-based traversal: Avoided GPU recursion limitations\nPersonal Note: This was a clever solution to GPU architectural constraints.My Concern: V2's JSON compilation needs similar tree evaluation efficiency.V1 Optimization: Early exit on symmetry successSymmetry loop: 8 iterations (rotations and reflections)\nEarly termination: Break immediately when any symmetry evaluates true\nResult aggregation: OR operation across all symmetries\nPersonal Assessment: This reduced unnecessary computation when patterns matched early.What I Don't Know: Whether V2's compiled rules will include similar short-circuit optimizations.Contributor: Claude Status: Individual analysis of GPU synchronizationPersonal Addition: These synchronization observations need team consideration for V2.V1 Processing Phases:\nCache Loading Phase: All threads cooperatively load neighborhood data\nSynchronization Barrier: workgroupBarrier() ensures cache completion\nIndependent Processing Phase: Each thread processes its assigned tile\nPersonal Observation: Clear separation between cooperative and independent work.My Interpretation: This maximized GPU efficiency by aligning with hardware capabilities.V1 Cache Loading Strategy:Work distribution: (cache_pixels + num_threads - 1) / num_threads // Ceiling division\nLoad balancing: Each thread loads 0-3 cache pixels depending on position\nBounds checking: Prevents threads from loading beyond cache dimensions\nPersonal Assessment: This ensured even work distribution across the workgroup.My Note: V2 should consider similar load balancing for any cooperative operations.V1 Synchronization Points:\nSingle workgroupBarrier() after cache loading\nNo additional barriers during tree evaluation\nIndependent tile processing without cross-thread communication\nPersonal Interpretation: Minimal synchronization overhead while ensuring data consistency.Personal Question: Will V2's active region system require additional synchronization?Contributor: Claude Status: Individual assessment needing team discussionPersonal Addition: These performance observations haven't been validated with actual measurements.V1 Work per Tile:\nReaction evaluation: Up to 8 reactions per tile type\nCondition evaluation: Up to 16 conditions per reaction Symmetry testing: 8 geometric transformations per condition\nTree traversal: 7 internal nodes + 8 leaf evaluations\nPersonal Calculation: Worst case ~8×16×8×15 = 15,360 operations per tileMy Assessment: This suggests V1 could handle very complex environmental behaviors, but at computational cost.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations.V1 Memory Footprint per Workgroup:\nShared cache: 144 × 32-bit = 576 bytes\nNode results array: 16 × 1-bit = 2 bytes (negligible)\nRule data cache: 3 × 32-bit = 12 bytes per condition\nPersonal Note: Shared memory usage was well within typical GPU limits.What I Don't Know: How V2's bit-packed tile format will affect memory access patterns.V1 Texture Access Patterns:\nInput texture reads: 1 per cache pixel (coalesced across workgroup)\nRules texture reads: 4 per tile (base + 3 condition chunks)\nOutput texture writes: 1 per tile\nNeighbor access: From cache (no additional texture reads)\nPersonal Assessment: Well-optimized memory access pattern with minimal bandwidth waste.My Concern: V2's 4-layer system may increase memory bandwidth requirements.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific GPU architecture considerations for V2.V1 Evidence: 8×8 workgroups with 12×12 cache worked well for 2-tile radius operationsResearch Questions for V2:\nShould V2 use similar workgroup dimensions?\nHow does V2's active region system (32×32 chunks) align with workgroup sizes?\nWill V2's tile operations require different neighbor access patterns?\nTeam Discussion Needed: Workgroup sizing based on V2's specific requirements.V1 Strategy: Heavy use of workgroup shared memory for cachingV2 Considerations:\nDoes V2's 4-layer system benefit from similar caching?\nShould V2 cache active region metadata in shared memory?\nHow do V2's bit-packed tiles affect cache efficiency?\nResearch Needed: Performance testing of V2 memory access patterns.V1 Evidence: Minimal synchronization (single barrier) provided good performanceV2 Questions:\nWill V2's physics integration require additional synchronization?\nDoes V2's active region updating need workgroup coordination?\nShould V2 pipeline different processing phases differently?\nPersonal Assessment: V2 may need more complex synchronization than V1.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These design recommendations need team review before consideration.\nWorkgroup shared memory caching for neighbor access optimization\nPhase-based processing with clear synchronization points Early exit optimizations where applicable\nTexture ping-ponging (already planned for V2) Scale caching strategy for V2's 4-layer tile system\nIntegrate active region optimization with V1's workgroup patterns\nConsider rule compilation targeting similar GPU optimization patterns Complexity vs Performance: V1 handled very complex rules - should V2 target similar capability?\nMemory vs Computation: V1 used memory to reduce computation - is this optimal for V2?\nSynchronization Overhead: Will V2's additional systems require more GPU barriers?\nStatus: All recommendations need team evaluation and design discussion.Personal Suggestions (not discussed with team):\nPrototype V2 compute shaders using V1 optimization patterns as starting point\nBenchmark memory access patterns for V2's bit-packed 4-layer system\nDesign active region processing to leverage V1's workgroup coordination strategies\nTest synchronization requirements for V2's multi-system integration\nStatus: All suggestions need team review and implementation planning.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"V1 GPU Optimization Patterns","level":1,"id":"V1_GPU_Optimization_Patterns_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Memory Architecture Patterns","level":2,"id":"👤_PERSONAL_V1_Memory_Architecture_Patterns_0"},{"heading":"Workgroup Shared Memory Strategy","level":3,"id":"Workgroup_Shared_Memory_Strategy_0"},{"heading":"Memory Access Optimization","level":3,"id":"Memory_Access_Optimization_0"},{"heading":"Texture Ping-Ponging Implementation","level":3,"id":"Texture_Ping-Ponging_Implementation_0"},{"heading":"👤 PERSONAL: V1 Data Pre-fetching Strategies","level":2,"id":"👤_PERSONAL_V1_Data_Pre-fetching_Strategies_0"},{"heading":"Rule Data Batching","level":3,"id":"Rule_Data_Batching_0"},{"heading":"Condition Tree Evaluation Optimization","level":3,"id":"Condition_Tree_Evaluation_Optimization_0"},{"heading":"Symmetry Evaluation Batching","level":3,"id":"Symmetry_Evaluation_Batching_0"},{"heading":"👤 PERSONAL: V1 Workgroup Coordination Patterns","level":2,"id":"👤_PERSONAL_V1_Workgroup_Coordination_Patterns_0"},{"heading":"Phase-Based Processing","level":3,"id":"Phase-Based_Processing_0"},{"heading":"Thread Work Distribution","level":3,"id":"Thread_Work_Distribution_0"},{"heading":"Memory Barrier Usage","level":3,"id":"Memory_Barrier_Usage_0"},{"heading":"👤 PERSONAL: V1 Performance Characteristics","level":2,"id":"👤_PERSONAL_V1_Performance_Characteristics_0"},{"heading":"Computational Complexity Patterns","level":3,"id":"Computational_Complexity_Patterns_0"},{"heading":"Memory Usage Patterns","level":3,"id":"Memory_Usage_Patterns_0"},{"heading":"Bandwidth Optimization Evidence","level":3,"id":"Bandwidth_Optimization_Evidence_0"},{"heading":"🟠 RESEARCH: V2 GPU Architecture Implications","level":2,"id":"🟠_RESEARCH_V2_GPU_Architecture_Implications_0"},{"heading":"Workgroup Size Decisions","level":3,"id":"Workgroup_Size_Decisions_0"},{"heading":"Memory Architecture Choices","level":3,"id":"Memory_Architecture_Choices_0"},{"heading":"Synchronization Requirements","level":3,"id":"Synchronization_Requirements_0"},{"heading":"👤 PERSONAL: Recommendations for V2 GPU Design","level":2,"id":"👤_PERSONAL_Recommendations_for_V2_GPU_Design_0"},{"heading":"Preserve Effective V1 Patterns","level":3,"id":"Preserve_Effective_V1_Patterns_0"},{"heading":"Adapt V1 Concepts for V2","level":3,"id":"Adapt_V1_Concepts_for_V2_0"},{"heading":"Research V1 vs V2 Trade-offs","level":3,"id":"Research_V1_vs_V2_Trade-offs_0"},{"heading":"Next Steps for V2 GPU Architecture","level":2,"id":"Next_Steps_for_V2_GPU_Architecture_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-gpu-patterns.html","pathToRoot":"..","attachments":[],"createdTime":1760380506343,"modifiedTime":1760380506343,"sourceSize":10531,"sourcePath":"legacy/v1-gpu-patterns.md","exportPath":"legacy/v1-gpu-patterns.html","showInTree":true,"treeOrder":68,"backlinks":["legacy/legacy.html"],"type":"markdown"},"legacy/v1-reference.html":{"title":"v1-reference","icon":"","description":"This document captures fundamental concepts and mathematical algorithms from the V1 rules engine to inform V2 development. V1 contained sophisticated rule evaluation systems that V2 developers should understand when designing the JSON compilation pipeline.Source: Analysis of V1 legacy codebase (archived)\nStatus: Reference material for V2 design considerationContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 code and hasn't been reviewed by the team.V1 Approach: Rules were evaluated across 8 geometric transformations (4 rotations × 2 reflections) to create symmetric environmental behaviors.Mathematical Pattern Observed:Rotation calculation: (symmetry &gt;&gt; 1u) &lt;&lt; 1u // Even number rotations\nReflection: select(1, -1, (symmetry &amp; 1u) != 0u) // Flip on odd symmetries\nFinal position: scale * flip * base_direction_vector\nMy Assessment: This created natural-looking environmental effects where fire spreading, water flow, etc. worked consistently in all directions.Personal Concern: V2's JSON compilation needs to handle similar geometric transformations or environmental effects may look artificial.V1 Pattern: Complex conditions organized as binary trees with packed evaluation:\n7 internal nodes (operators: AND, OR, NOR, NAND)\n8 leaf nodes (spatial conditions)\nBottom-up evaluation from leaves to root\nData Packing Observed:\nInternal node modes: 2 bits each, packed into 14 bits total\nLeaf conditions: 9 bits each (5-bit tile type, 3-bit direction, 1-bit distance)\nEvaluation results: Boolean array with indices mapping to tree structure\nMy Interpretation: This allowed arbitrarily complex logical conditions while maintaining GPU efficiency.Personal Question: How will V2's JSON compilation achieve similar complexity without runtime memory overhead?V1 Bias System:\nBase reaction bias: signed 5-bit value (-16 to +15)\nCondition contributions: signed values added when conditions met\nWinning rule: highest total score after all conditions evaluated\nPersonal Observation: This created emergent behaviors where multiple environmental effects competed naturally (e.g., fire spreading vs water extinguishing).What I Don't Know: Whether V2's competitive scoring will replicate this mathematical sophistication.Contributor: Claude Status: Individual analysis of compute shaderPersonal Addition: These observations from V1's GPU implementation haven't been discussed with the team.V1 Pattern: 12×12 shared memory cache for 8×8 workgroup with 2-tile border\nEach thread loads multiple cache pixels to fill neighborhood\nWorkgroup barrier synchronization before condition evaluation\nEliminates redundant texture reads for neighbor checks\nMy Assessment: This optimization was sophisticated and likely provided significant performance benefits.Personal Concern: V2 GPU shader design should consider similar caching strategies.V1 Approach: Pre-computed direction offset arrays with wrap-around handlingDirection offsets: 8 compass directions as vec2i\nWrap-around: (global_coord % tex_dims + tex_dims) % tex_dims\nCache position: local_coord + cache_offset + relative_position\nPersonal Note: This handled world boundaries elegantly while maintaining cache efficiency.V1 Pattern: Batch-loaded rule data chunks before evaluation\n3 texture reads for all 9 possible leaf conditions\nStored in array for indexed access during tree evaluation\nMinimized GPU texture bandwidth usage\nMy Interpretation: This was a carefully optimized memory access pattern.Contributor: Claude Status: Questions identified from V1 analysisPersonal Assessment: These issues need team discussion based on V1 complexity:Question: How will V2's JSON compilation handle the mathematical sophistication of V1's binary tree evaluation and 8-fold symmetry?V1 Evidence: Rules could express conditions like \"fire spreads if 2+ fire neighbors AND no water within 2 tiles AND not in NW/NE corners\"My Concern: V2 JSON format may need significant complexity to match V1 expressiveness.Question: Will V2 replicate V1's shared memory optimizations or use different strategies?V1 Evidence: Complex workgroup coordination and cache management in compute shaderPersonal Assessment: V2 might benefit from studying V1's memory access patterns before designing new shaders.Question: How will V2 ensure deterministic evaluation order that V1 achieved?V1 Evidence: Strict tile-by-tile processing with consistent neighbor checking orderWhat I Don't Know: Whether V2's approach will maintain this level of determinism.Identified by: Claude Status: Team input neededPersonal Assessment: V1 performance characteristics need measurement, but patterns suggest optimization priorities.\n128×128 texture for rules (16,384 × 32-bit values = 64KB rule storage)\nWorkgroup shared memory: 144 × 32-bit values per workgroup\nDual texture ping-ponging: 2× map memory usage\nMy Interpretation: V1 traded memory for computational efficiency.Research Needed: Actual performance measurements and comparison with V2 targets.\n8 symmetry evaluations per condition\nBinary tree evaluation with up to 7 internal nodes\n16 conditions maximum per reaction\n8 reactions maximum per tile type\nPersonal Note: This suggests V1 could handle very complex environmental behaviors.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations for simplicity.Personal Recommendations (not discussed with team):\nStudy V1's mathematical patterns before finalizing JSON compilation approach\nConsider V1's GPU optimization strategies for V2 shader architecture Evaluate whether V2 competitive scoring can achieve V1's sophistication\nPlan for complexity testing to ensure V2 can handle intricate environmental behaviors\nStatus: All recommendations need team review and discussion.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"V1 Rules Engine Reference","level":1,"id":"V1_Rules_Engine_Reference_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Mathematical Concepts Worth Preserving","level":2,"id":"👤_PERSONAL_V1_Mathematical_Concepts_Worth_Preserving_0"},{"heading":"8-Fold Symmetry Evaluation System","level":3,"id":"8-Fold_Symmetry_Evaluation_System_0"},{"heading":"Binary Tree Condition Evaluation","level":3,"id":"Binary_Tree_Condition_Evaluation_0"},{"heading":"Competitive Scoring Mathematics","level":3,"id":"Competitive_Scoring_Mathematics_0"},{"heading":"👤 PERSONAL: V1 GPU Optimization Patterns","level":2,"id":"👤_PERSONAL_V1_GPU_Optimization_Patterns_0"},{"heading":"Workgroup Shared Memory Caching","level":3,"id":"Workgroup_Shared_Memory_Caching_0"},{"heading":"Neighbor Access Optimization","level":3,"id":"Neighbor_Access_Optimization_0"},{"heading":"Data Pre-fetching Strategy","level":3,"id":"Data_Pre-fetching_Strategy_0"},{"heading":"👤 PERSONAL: Critical Implementation Unknowns for V2","level":2,"id":"👤_PERSONAL_Critical_Implementation_Unknowns_for_V2_0"},{"heading":"Rule Complexity Handling","level":3,"id":"Rule_Complexity_Handling_0"},{"heading":"GPU Memory Architecture","level":3,"id":"GPU_Memory_Architecture_0"},{"heading":"Determinism Guarantees","level":3,"id":"Determinism_Guarantees_0"},{"heading":"🟠 RESEARCH: Performance Characteristics","level":2,"id":"🟠_RESEARCH_Performance_Characteristics_0"},{"heading":"Memory Usage Patterns Observed","level":3,"id":"Memory_Usage_Patterns_Observed_0"},{"heading":"Computational Complexity Patterns","level":3,"id":"Computational_Complexity_Patterns_0"},{"heading":"Next Steps for V2 Design","level":2,"id":"Next_Steps_for_V2_Design_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-reference.html","pathToRoot":"..","attachments":[],"createdTime":1760380506343,"modifiedTime":1760380506343,"sourceSize":6838,"sourcePath":"legacy/v1-reference.md","exportPath":"legacy/v1-reference.html","showInTree":true,"treeOrder":69,"backlinks":["legacy/legacy.html"],"type":"markdown"},"legacy/v1-visual-effects.html":{"title":"v1-visual-effects","icon":"","description":"This document captures visual rendering techniques from V1 to inform V2 renderer design. V1's render shader contained sophisticated visual effects that created distinct, animated appearances for different tile types.Source: Analysis of V1 render shader (src/graphics/shaders/render.wgsl)\nStatus: Reference material for V2 visual design decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 rendering code and hasn't been reviewed by the team.V1 Water Effect: Complex wave system using multiple sine functionsWave components (observed):\n- Wave 1: sin(worldUV.x * 3.2 + time * 1.03) * 0.5 (primary horizontal)\n- Wave 2: sin(worldUV.y * 14.0 - time * 1.3) * 0.25 (vertical fine)\n- Wave 3: sin(worldUV.y * 8.3 + time * 1.5) * 0.25 (vertical medium)\n- Wave 4: sin((worldUV.x + worldUV.y) * 13.7 - time * 0.8) * 0.15 (diagonal)\n- Wave 5: sin((2.43 * worldUV.x + 3.0 * worldUV.y) * 15.5 - time * 1.2) * 0.12 (complex)\n- Wave 6: sin((worldUV.x - 1.3 * worldUV.y) * 16.7 - time * 0.7) * 0.1 (counter-diagonal)\nPersonal Assessment: This created realistic water movement with multiple overlapping wave patterns.Color Blending System:Base colors: Deep blue (#0099CC) to cyan (#33CCFF)\nHeight mapping: Wave height influences color interpolation\nHighlight system: White foam on wave peaks using smoothstep\nMy Interpretation: The multi-wave approach created natural-looking water with depth variation.Personal Note: V2 should consider similar layered animation techniques for environmental immersion.V1 Grass Blade Technique: Individual blade rendering within each tileBlade positioning: Offset by sine(time + worldUV.y * 2) for wind effect\nBlade dimensions: Triangle-based blade shapes with height variation\nDual blade system: Two offset blade patterns per tile for density\nBlade Generation Algorithm:Blade coordinate mapping: (worldUV * 10) % 1 for repeating pattern\nBlade shape: 1 - abs(bladepos.x - 0.5) * 2 (triangle profile)\nHeight variation: bladepos.y-based cutting for blade tips\nWind animation: X-offset by sine function creates swaying\nPersonal Assessment: This created convincing grass appearance at the tile level.Color System:Base colors: Dark green (#1A4D33) to bright green (#19FF19)\nHeight-based mixing: Taller blade portions lighter\nHighlight integration: White highlights on blade tips\nMy Interpretation: The procedural approach provided detailed grass without requiring texture assets.V1 Lava Effect: Similar wave system to water but with different parametersWave pattern: Subset of water waves (4 components instead of 6)\nColor palette: Orange-red (#FF3300) to yellow-orange (#FFCC80)\nHighlight system: Pink-magenta highlights (#FF80FF) on wave peaks\nPersonal Observation: Lava reused water's animation framework with different visual parameters.My Assessment: This suggests V2 could use unified animation systems with material-specific parameters.V1 Noise Functions: Multiple noise layers for various effectsBasic Perlin: Standard 2D Perlin noise with gradient interpolation\nFractal Brownian Motion (FBM): 4 octaves of layered noise\nHash function: Deterministic pseudo-random for gradient generation\nNoise Applications Observed:\nMountain height maps with contour effects\nTerrain distortion for organic tile boundaries\nTexture variation within tile types\nPersonal Note: V2 should consider noise as a fundamental rendering primitive.V1 Distortion System: World UV coordinates modified by noiseDistortion calculation: Perlin noise at multiple scales\nApplication: UV += distortion_vector before tile sampling\nEffect: Organic, non-grid-aligned visual boundaries\nPersonal Assessment: This helped disguise the underlying grid structure.Tile Edge Softening:Distance calculation: max(abs(tileUV.x-0.5), abs(tileUV.y-0.5)) * 2 - 0.2\nFalloff function: 1 - pow(square_dist, 6.0)\nApplication: Multiply final color by falloff\nMy Interpretation: This created soft tile boundaries and visual cohesion.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These material observations need team consideration for V2 visual design.V1 Material Definitions:\nWater: Blue spectrum with white foam highlights\nLava: Orange-red spectrum with magenta highlights\nMagic: Purple-green spectrum (similar animation to water)\nGrass: Green spectrum with procedural blade geometry\nVoid: Animated mountain texture with brown/purple palette\nPersonal Observation: Each material had distinct color relationships and animation characteristics.My Assessment: V2 should define similar material systems for consistent visual identity.V1 Color Blend Patterns:Height-based interpolation: mix(deepColor, lightColor, height_factor)\nHighlight overlays: mix(baseColor, highlightColor, highlight_strength)\nTime-based variation: Colors influenced by animation state\nPersonal Note: This created natural-looking material variation without texture sampling.Material Property System (inferred):\nBase color ranges per material type\nAnimation amplitude and frequency per material\nHighlight color and trigger thresholds per material\nMy Interpretation: V2 could benefit from similar parameterized material systems.V1 Shader Efficiency Patterns:\nSwitch statement for tile type selection (GPU-friendly branching)\nShared mathematical functions across material types\nSingle-pass rendering with material-specific logic branches\nPersonal Assessment: V1 balanced visual complexity with rendering performance.Mathematical Function Reuse:\nPerlin noise used across multiple material types\nWave functions shared between water, lava, and magic\nColor interpolation patterns repeated across materials\nMy Note: V2 should consider similar function reuse for consistency and performance.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Evidence: Complex mathematical calculations per pixel (6-wave water system, procedural grass, multi-octave noise)Personal Questions for V2:\nShould V2 target similar visual complexity?\nHow will V2's 4-layer system affect rendering performance?\nWill V2 support material-specific animation systems?\nResearch Needed: Performance testing of V1-style effects with V2's architecture.V1 Approach: Hardcoded material properties in shader switch statementsV2 Considerations:\nShould V2 use similar hardcoded materials or data-driven systems?\nHow do V2's layers interact visually (transparency, blending)?\nWill V2 support runtime material customization?\nPersonal Assessment: V2 might benefit from more flexible material systems than V1's hardcoded approach.V1 Time Usage: Global time parameter for synchronized animations across all tilesV2 Questions:\nHow will V2 handle time synchronization across distributed processing?\nShould V2 support per-tile animation offsets for variety?\nWill V2's physics system affect visual animation timing?\nTeam Discussion Needed: Integration between V2's physics timing and visual animation.Identified by: Claude Status: Team input neededPersonal Assessment: V1's visual complexity suggests performance considerations for V2.V1 Per-Pixel Calculations (observed):\nWater: 6 sine function evaluations + color interpolation\nGrass: Blade geometry generation + multiple conditional branches\nNoise: 4-octave fractal calculation + hash function evaluations\nPersonal Calculation: Potentially 10-20 mathematical operations per pixel for complex materialsResearch Questions:\nWhat are V2's target performance characteristics?\nShould V2 support multiple detail levels for different devices?\nHow does V1's performance compare to V2's goals?\nTeam Discussion Needed: Visual quality vs performance trade-offs for V2.V1 Approach: Procedural generation without texture assets\nNo texture memory usage for material appearance\nAll effects generated mathematically in shader\nTime and UV coordinates as only inputs\nV2 Implications:\nShould V2 continue the fully-procedural approach?\nHow do V2's bit-packed tiles affect rendering pipeline?\nWill V2's 4-layer system require additional rendering passes?\nPersonal Assessment: V1's procedural approach was memory-efficient but computationally intensive.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These visual design recommendations need team review before consideration.\nMulti-wave animation systems for natural-looking environmental movement\nProcedural material generation for memory efficiency\nPerlin noise integration for organic visual variation\nMaterial-specific color palettes for visual distinction Layer-aware rendering for V2's 4-layer tile system\nMaterial property systems for easier customization than V1's hardcoded approach\nPerformance scaling for different device capabilities\nAnimation synchronization with V2's physics and reaction systems Visual complexity scaling - V1 effects were computationally expensive\nMaterial variety - V1 had limited material types compared to V2's ambitions\nLayer interaction - V1 was single-layer, V2 needs multi-layer visual compositing\nStatus: All recommendations need team evaluation and visual design discussion.Personal Suggestions (not discussed with team):\nPrototype V2 materials using V1 techniques as starting point\nTest rendering performance with V2's 4-layer system and V1-style effects\nDesign material property systems that provide V1's visual quality with more flexibility\nPlan animation integration with V2's physics and reaction timing\nStatus: All suggestions need team review and renderer architecture planning.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"V1 Visual Effects Reference","level":1,"id":"V1_Visual_Effects_Reference_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Visual Effect Techniques","level":2,"id":"👤_PERSONAL_V1_Visual_Effect_Techniques_0"},{"heading":"Multi-Directional Water Animation","level":3,"id":"Multi-Directional_Water_Animation_0"},{"heading":"Procedural Grass Rendering","level":3,"id":"Procedural_Grass_Rendering_0"},{"heading":"Lava Flow Animation","level":3,"id":"Lava_Flow_Animation_0"},{"heading":"Perlin Noise Integration","level":3,"id":"Perlin_Noise_Integration_0"},{"heading":"Advanced Visual Techniques","level":3,"id":"Advanced_Visual_Techniques_0"},{"heading":"👤 PERSONAL: V1 Color and Material Systems","level":2,"id":"👤_PERSONAL_V1_Color_and_Material_Systems_0"},{"heading":"Material-Specific Color Palettes","level":3,"id":"Material-Specific_Color_Palettes_0"},{"heading":"Dynamic Color Mixing","level":3,"id":"Dynamic_Color_Mixing_0"},{"heading":"Performance-Optimized Rendering","level":3,"id":"Performance-Optimized_Rendering_0"},{"heading":"👤 PERSONAL: V2 Renderer Implications","level":2,"id":"👤_PERSONAL_V2_Renderer_Implications_0"},{"heading":"Visual Complexity vs Performance","level":3,"id":"Visual_Complexity_vs_Performance_0"},{"heading":"Material System Design","level":3,"id":"Material_System_Design_0"},{"heading":"Animation and Time Integration","level":3,"id":"Animation_and_Time_Integration_0"},{"heading":"🟠 RESEARCH: Visual Effect Performance","level":2,"id":"🟠_RESEARCH_Visual_Effect_Performance_0"},{"heading":"Computational Intensity Evidence","level":3,"id":"Computational_Intensity_Evidence_0"},{"heading":"Memory and Bandwidth Considerations","level":3,"id":"Memory_and_Bandwidth_Considerations_0"},{"heading":"👤 PERSONAL: Recommendations for V2 Visual Design","level":2,"id":"👤_PERSONAL_Recommendations_for_V2_Visual_Design_0"},{"heading":"Preserve Effective V1 Techniques","level":3,"id":"Preserve_Effective_V1_Techniques_0"},{"heading":"Enhance V1 Concepts for V2","level":3,"id":"Enhance_V1_Concepts_for_V2_0"},{"heading":"Consider V1 Limitations","level":3,"id":"Consider_V1_Limitations_0"},{"heading":"Next Steps for V2 Visual Design","level":2,"id":"Next_Steps_for_V2_Visual_Design_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-visual-effects.html","pathToRoot":"..","attachments":[],"createdTime":1760380506344,"modifiedTime":1760380506344,"sourceSize":11094,"sourcePath":"legacy/v1-visual-effects.md","exportPath":"legacy/v1-visual-effects.html","showInTree":true,"treeOrder":70,"backlinks":["legacy/legacy.html"],"type":"markdown"},"docs.html":{"title":"docs","icon":"","description":"Status: 🚧 Stub - This index file needs completionComplete documentation for the Reaction v2 real-time PvP grid-based spellcasting game engine.\n<a class=\"internal-link\" data-href=\"architecture/architecture.md\" href=\"architecture/architecture.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Architecture - System design and technical approach\n<br><a class=\"internal-link\" data-href=\"development/development.md\" href=\"development/development.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Development - Setup, workflow, and development processes <br><a class=\"internal-link\" data-href=\"gameplay/gameplay.md\" href=\"gameplay/gameplay.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Gameplay - Core game mechanics and design philosophy <br><a class=\"internal-link\" data-href=\"legacy/legacy.md\" href=\"legacy/legacy.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Legacy V1 Analysis - V1 system concepts for V2 development reference\nTODO: Add quick start section with:\nProject setup instructions\nFirst build steps\nDevelopment environment configuration\nTODO: Add project overview with:\nGame concept summary\nTechnical architecture highlights\nDevelopment status and roadmap\n🚧 This file is a stub and needs completion","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Reaction Documentation","level":1,"id":"Reaction_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Documentation","level":3,"id":"Core_Documentation_0"},{"heading":"Reference","level":3,"id":"Reference_0"},{"heading":"Quick Start","level":2,"id":"Quick_Start_0"},{"heading":"Project Overview","level":2,"id":"Project_Overview_0"}],"links":["architecture/architecture.html","development/development.html","gameplay/gameplay.html","legacy/legacy.html"],"author":"","coverImageURL":"","fullURL":"docs.html","pathToRoot":".","attachments":[],"createdTime":1760380506339,"modifiedTime":1760380506340,"sourceSize":1107,"sourcePath":"docs.md","exportPath":"docs.html","showInTree":true,"treeOrder":71,"backlinks":["index.html"],"type":"markdown"},"index.html":{"title":"index","icon":"","description":"Reaction v2 is a complete reimagining of the original Reaction game, featuring GPU-accelerated physics, deterministic gameplay, and a powerful spell crafting system where players cast spells that place magical runes, transforming terrain through physics-based rule systems.We're currently in the architecture design phase, focusing on creating robust system designs before moving to implementation.\nReal-time PvP Combat - Fast-paced multiplayer battles on grid-based terrain\nSpell Crafting System - Create custom spell combinations using magical runes\nRule-based Physics - Dynamic terrain transformation through deterministic physics\nGPU Acceleration - High-performance rendering and physics calculations\nDeterministic Gameplay - Consistent game state across all clients for competitive play <a data-tooltip-position=\"top\" aria-label=\"architecture/architecture\" data-href=\"architecture/architecture\" href=\"architecture/architecture.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Architecture</a> - System design and technical approach\n<br><a data-tooltip-position=\"top\" aria-label=\"development/development\" data-href=\"development/development\" href=\"development/development.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Development</a> - Setup, workflow, and development processes\n<br><a data-tooltip-position=\"top\" aria-label=\"gameplay/gameplay\" data-href=\"gameplay/gameplay\" href=\"gameplay/gameplay.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Gameplay</a> - Core game mechanics and design philosophy <br><a data-tooltip-position=\"top\" aria-label=\"legacy/legacy\" data-href=\"legacy/legacy\" href=\"legacy/legacy.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Legacy V1 Analysis</a> - V1 system concepts for V2 development reference <br>Development Setup: See <a data-tooltip-position=\"top\" aria-label=\"development/getting-started\" data-href=\"development/getting-started\" href=\"development/getting-started.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Getting Started Guide</a>\n<br>Architecture Overview: Read <a data-tooltip-position=\"top\" aria-label=\"architecture/general/overview\" data-href=\"architecture/general/overview\" href=\"architecture/general/overview.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">System Overview</a>\n<br>Development Principles: Review <a data-tooltip-position=\"top\" aria-label=\"development/DEVELOPMENT_PRINCIPLES\" data-href=\"development/DEVELOPMENT_PRINCIPLES\" href=\"development/development_principles.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Core Principles</a>\nnpm run dev # Start development server\nnpm run test # Run test suite npm run build # Create production build /docs - Documentation source (Markdown)\n/src - Source code\n/tests - Test suites\n/build - Build outputs (gitignored) <br><a data-tooltip-position=\"top\" aria-label=\"https://github.com/FireToDust/Reaction-Web\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/FireToDust/Reaction-Web\" target=\"_self\">GitHub Repository</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"development/building-documentation\" data-href=\"development/building-documentation\" href=\"development/building-documentation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Building Documentation</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"docs\" data-href=\"docs\" href=\"docs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Full Documentation Index</a>\nFor detailed documentation, explore the links above or browse the documentation tree.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Welcome to Reaction v2","level":1,"id":"Welcome_to_Reaction_v2_0"},{"heading":"A Real-Time PvP Grid-Based Spellcasting Game","level":2,"id":"A_Real-Time_PvP_Grid-Based_Spellcasting_Game_0"},{"heading":"=� Current Status: Architecture Phase","level":2,"id":"=�_Current_Status_Architecture_Phase_0"},{"heading":"&lt;� Key Features","level":2,"id":"<�_Key_Features_0"},{"heading":"=� Documentation","level":2,"id":"=�_Documentation_0"},{"heading":"Core Documentation","level":3,"id":"Core_Documentation_0"},{"heading":"Reference","level":3,"id":"Reference_0"},{"heading":"=� Getting Started","level":2,"id":"=�_Getting_Started_0"},{"heading":"=' Quick Commands","level":2,"id":"='_Quick_Commands_0"},{"heading":"=� Project Structure","level":2,"id":"=�_Project_Structure_0"},{"heading":"=\u0017 Links","level":2,"id":"=\u0017_Links_0"}],"links":["architecture/architecture.html","development/development.html","gameplay/gameplay.html","legacy/legacy.html","development/getting-started.html","architecture/general/overview.html","development/development_principles.html","development/building-documentation.html","docs.html"],"author":"","coverImageURL":"","fullURL":"index.html","pathToRoot":".","attachments":[],"createdTime":1760380506341,"modifiedTime":1760380506341,"sourceSize":2228,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown"}},"fileInfo":{"architecture/general/data-flow.html":{"createdTime":1760380506316,"modifiedTime":1760380506317,"sourceSize":5271,"sourcePath":"architecture/general/data-flow.md","exportPath":"architecture/general/data-flow.html","showInTree":true,"treeOrder":2,"backlinks":["architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/general/overview.html"],"type":"markdown","data":null},"architecture/general/deterministic-execution.html":{"createdTime":1760380506317,"modifiedTime":1760380506317,"sourceSize":6596,"sourcePath":"architecture/general/deterministic-execution.md","exportPath":"architecture/general/deterministic-execution.html","showInTree":true,"treeOrder":3,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html","architecture/general/implementation-guide.html","architecture/general/variable-timing.html"],"type":"markdown","data":null},"architecture/general/general.html":{"createdTime":1760380506318,"modifiedTime":1760380506318,"sourceSize":1651,"sourcePath":"architecture/general/general.md","exportPath":"architecture/general/general.html","showInTree":true,"treeOrder":4,"backlinks":["architecture/architecture.html"],"type":"markdown","data":null},"architecture/general/ghost-simulation.html":{"createdTime":1760380506318,"modifiedTime":1760380506318,"sourceSize":12880,"sourcePath":"architecture/general/ghost-simulation.md","exportPath":"architecture/general/ghost-simulation.html","showInTree":true,"treeOrder":5,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html"],"type":"markdown","data":null},"architecture/general/implementation-guide.html":{"createdTime":1760380506318,"modifiedTime":1760380506319,"sourceSize":6036,"sourcePath":"architecture/general/implementation-guide.md","exportPath":"architecture/general/implementation-guide.html","showInTree":true,"treeOrder":6,"backlinks":["architecture/general/general.html"],"type":"markdown","data":null},"architecture/general/overview.html":{"createdTime":1760380506319,"modifiedTime":1760380506319,"sourceSize":5705,"sourcePath":"architecture/general/overview.md","exportPath":"architecture/general/overview.html","showInTree":true,"treeOrder":7,"backlinks":["architecture/architecture.html","development/getting-started.html","architecture/general/general.html","index.html"],"type":"markdown","data":null},"architecture/general/performance.html":{"createdTime":1760380506319,"modifiedTime":1760380506320,"sourceSize":4083,"sourcePath":"architecture/general/performance.md","exportPath":"architecture/general/performance.html","showInTree":true,"treeOrder":8,"backlinks":["architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/overview.html"],"type":"markdown","data":null},"architecture/general/state-management.html":{"createdTime":1760380506320,"modifiedTime":1760380506320,"sourceSize":12367,"sourcePath":"architecture/general/state-management.md","exportPath":"architecture/general/state-management.html","showInTree":true,"treeOrder":9,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html","architecture/general/implementation-guide.html","architecture/general/variable-timing.html","architecture/systems/multiplayer/client-prediction.html"],"type":"markdown","data":null},"architecture/general/technical-decisions.html":{"createdTime":1760380506320,"modifiedTime":1760380506321,"sourceSize":5007,"sourcePath":"architecture/general/technical-decisions.md","exportPath":"architecture/general/technical-decisions.html","showInTree":true,"treeOrder":10,"backlinks":["architecture/general/general.html","architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/general/variable-timing.html":{"createdTime":1760380506321,"modifiedTime":1760380506321,"sourceSize":9400,"sourcePath":"architecture/general/variable-timing.md","exportPath":"architecture/general/variable-timing.html","showInTree":true,"treeOrder":11,"backlinks":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/state-management.html"],"type":"markdown","data":null},"architecture/systems/config/config.html":{"createdTime":1760380506322,"modifiedTime":1760380506322,"sourceSize":1478,"sourcePath":"architecture/systems/config/config.md","exportPath":"architecture/systems/config/config.html","showInTree":true,"treeOrder":14,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/core/active-regions.html":{"createdTime":1760380506322,"modifiedTime":1760380506322,"sourceSize":4003,"sourcePath":"architecture/systems/core/active-regions.md","exportPath":"architecture/systems/core/active-regions.html","showInTree":true,"treeOrder":16,"backlinks":["architecture/systems/core/core.html"],"type":"markdown","data":null},"architecture/systems/core/api-reference.html":{"createdTime":1760380506322,"modifiedTime":1760380506323,"sourceSize":4406,"sourcePath":"architecture/systems/core/api-reference.md","exportPath":"architecture/systems/core/api-reference.html","showInTree":true,"treeOrder":17,"backlinks":["architecture/systems/core/core.html"],"type":"markdown","data":null},"architecture/systems/core/core.html":{"createdTime":1760380506323,"modifiedTime":1760380506323,"sourceSize":2195,"sourcePath":"architecture/systems/core/core.md","exportPath":"architecture/systems/core/core.html","showInTree":true,"treeOrder":18,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/core/texture-management.html":{"createdTime":1760380506323,"modifiedTime":1760380506324,"sourceSize":2796,"sourcePath":"architecture/systems/core/texture-management.md","exportPath":"architecture/systems/core/texture-management.html","showInTree":true,"treeOrder":19,"backlinks":["architecture/systems/core/core.html"],"type":"markdown","data":null},"architecture/systems/core/tile-storage.html":{"createdTime":1760380506324,"modifiedTime":1760380506324,"sourceSize":2010,"sourcePath":"architecture/systems/core/tile-storage.md","exportPath":"architecture/systems/core/tile-storage.html","showInTree":true,"treeOrder":20,"backlinks":["architecture/general/overview.html","architecture/systems/core/core.html"],"type":"markdown","data":null},"architecture/systems/gpu/gpu.html":{"createdTime":1760380506324,"modifiedTime":1760380506324,"sourceSize":2656,"sourcePath":"architecture/systems/gpu/gpu.md","exportPath":"architecture/systems/gpu/gpu.html","showInTree":true,"treeOrder":22,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/client-prediction.html":{"createdTime":1760380506325,"modifiedTime":1760380506325,"sourceSize":5622,"sourcePath":"architecture/systems/multiplayer/client-prediction.md","exportPath":"architecture/systems/multiplayer/client-prediction.html","showInTree":true,"treeOrder":24,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/deployment.html":{"createdTime":1760380506325,"modifiedTime":1760380506325,"sourceSize":8009,"sourcePath":"architecture/systems/multiplayer/deployment.md","exportPath":"architecture/systems/multiplayer/deployment.html","showInTree":true,"treeOrder":25,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/multiplayer.html":{"createdTime":1760380506326,"modifiedTime":1760380506326,"sourceSize":2734,"sourcePath":"architecture/systems/multiplayer/multiplayer.md","exportPath":"architecture/systems/multiplayer/multiplayer.html","showInTree":true,"treeOrder":26,"backlinks":["architecture/general/state-management.html","architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/network-protocol.html":{"createdTime":1760380506326,"modifiedTime":1760380506326,"sourceSize":6107,"sourcePath":"architecture/systems/multiplayer/network-protocol.md","exportPath":"architecture/systems/multiplayer/network-protocol.html","showInTree":true,"treeOrder":27,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/performance.html":{"createdTime":1760380506327,"modifiedTime":1760380506327,"sourceSize":6185,"sourcePath":"architecture/systems/multiplayer/performance.md","exportPath":"architecture/systems/multiplayer/performance.html","showInTree":true,"treeOrder":28,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/security.html":{"createdTime":1760380506327,"modifiedTime":1760380506328,"sourceSize":7536,"sourcePath":"architecture/systems/multiplayer/security.md","exportPath":"architecture/systems/multiplayer/security.html","showInTree":true,"treeOrder":29,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/server-architecture.html":{"createdTime":1760380506328,"modifiedTime":1760380506329,"sourceSize":4288,"sourcePath":"architecture/systems/multiplayer/server-architecture.md","exportPath":"architecture/systems/multiplayer/server-architecture.html","showInTree":true,"treeOrder":30,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/physics/determinism.html":{"createdTime":1760380506329,"modifiedTime":1760380506329,"sourceSize":3480,"sourcePath":"architecture/systems/physics/determinism.md","exportPath":"architecture/systems/physics/determinism.html","showInTree":true,"treeOrder":32,"backlinks":["architecture/systems/physics/physics.html"],"type":"markdown","data":null},"architecture/systems/physics/forces.html":{"createdTime":1760380506329,"modifiedTime":1760380506330,"sourceSize":6138,"sourcePath":"architecture/systems/physics/forces.md","exportPath":"architecture/systems/physics/forces.html","showInTree":true,"treeOrder":33,"backlinks":["architecture/systems/physics/physics.html"],"type":"markdown","data":null},"architecture/systems/physics/gpu-shaders.html":{"createdTime":1760380506330,"modifiedTime":1760380506330,"sourceSize":8456,"sourcePath":"architecture/systems/physics/gpu-shaders.md","exportPath":"architecture/systems/physics/gpu-shaders.html","showInTree":true,"treeOrder":34,"backlinks":["architecture/systems/physics/physics.html"],"type":"markdown","data":null},"architecture/systems/physics/movement-system.html":{"createdTime":1760380506330,"modifiedTime":1760380506331,"sourceSize":7325,"sourcePath":"architecture/systems/physics/movement-system.md","exportPath":"architecture/systems/physics/movement-system.html","showInTree":true,"treeOrder":35,"backlinks":["architecture/systems/physics/physics.html"],"type":"markdown","data":null},"architecture/systems/physics/physics.html":{"createdTime":1760380506331,"modifiedTime":1760380506331,"sourceSize":3222,"sourcePath":"architecture/systems/physics/physics.md","exportPath":"architecture/systems/physics/physics.html","showInTree":true,"treeOrder":36,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/reactions/reactions.html":{"createdTime":1760380506331,"modifiedTime":1760380506332,"sourceSize":1952,"sourcePath":"architecture/systems/reactions/reactions.md","exportPath":"architecture/systems/reactions/reactions.html","showInTree":true,"treeOrder":38,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/reactions/rule-compilation.html":{"createdTime":1760380506332,"modifiedTime":1760380506332,"sourceSize":5254,"sourcePath":"architecture/systems/reactions/rule-compilation.md","exportPath":"architecture/systems/reactions/rule-compilation.html","showInTree":true,"treeOrder":39,"backlinks":["architecture/systems/reactions/reactions.html"],"type":"markdown","data":null},"architecture/systems/rendering/rendering.html":{"createdTime":1760380506332,"modifiedTime":1760380506333,"sourceSize":639,"sourcePath":"architecture/systems/rendering/rendering.md","exportPath":"architecture/systems/rendering/rendering.html","showInTree":true,"treeOrder":41,"backlinks":["architecture/general/ghost-simulation.html","architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/spells/cpu-architecture.html":{"createdTime":1760380506333,"modifiedTime":1760380506333,"sourceSize":5616,"sourcePath":"architecture/systems/spells/cpu-architecture.md","exportPath":"architecture/systems/spells/cpu-architecture.html","showInTree":true,"treeOrder":43,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/systems/spells/customization.html":{"createdTime":1760380506334,"modifiedTime":1760380506334,"sourceSize":4494,"sourcePath":"architecture/systems/spells/customization.md","exportPath":"architecture/systems/spells/customization.html","showInTree":true,"treeOrder":44,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/systems/spells/mana-system.html":{"createdTime":1760380506334,"modifiedTime":1760380506334,"sourceSize":2810,"sourcePath":"architecture/systems/spells/mana-system.md","exportPath":"architecture/systems/spells/mana-system.html","showInTree":true,"treeOrder":45,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/systems/spells/spells.html":{"createdTime":1760380506335,"modifiedTime":1760380506335,"sourceSize":2194,"sourcePath":"architecture/systems/spells/spells.md","exportPath":"architecture/systems/spells/spells.html","showInTree":true,"treeOrder":46,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/spells/spells-and-runes.html":{"createdTime":1760380506335,"modifiedTime":1760380506335,"sourceSize":4502,"sourcePath":"architecture/systems/spells/spells-and-runes.md","exportPath":"architecture/systems/spells/spells-and-runes.html","showInTree":true,"treeOrder":47,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/systems/tools/tools.html":{"createdTime":1760380506336,"modifiedTime":1760380506336,"sourceSize":688,"sourcePath":"architecture/systems/tools/tools.md","exportPath":"architecture/systems/tools/tools.html","showInTree":true,"treeOrder":49,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/ui/ui.html":{"createdTime":1760380506336,"modifiedTime":1760380506337,"sourceSize":2063,"sourcePath":"architecture/systems/ui/ui.md","exportPath":"architecture/systems/ui/ui.html","showInTree":true,"treeOrder":51,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/systems.html":{"createdTime":1760380506336,"modifiedTime":1760380506336,"sourceSize":1650,"sourcePath":"architecture/systems/systems.md","exportPath":"architecture/systems/systems.html","showInTree":true,"treeOrder":52,"backlinks":["architecture/architecture.html"],"type":"markdown","data":null},"architecture/architecture.html":{"createdTime":1760380506316,"modifiedTime":1760380506316,"sourceSize":1425,"sourcePath":"architecture/architecture.md","exportPath":"architecture/architecture.html","showInTree":true,"treeOrder":53,"backlinks":["docs.html","index.html"],"type":"markdown","data":null},"development/building-documentation.html":{"createdTime":1760380506338,"modifiedTime":1760380506338,"sourceSize":1084,"sourcePath":"development/building-documentation.md","exportPath":"development/building-documentation.html","showInTree":true,"treeOrder":55,"backlinks":["index.html"],"type":"markdown","data":null},"development/development.html":{"createdTime":1760380506338,"modifiedTime":1760380506338,"sourceSize":1203,"sourcePath":"development/development.md","exportPath":"development/development.html","showInTree":true,"treeOrder":56,"backlinks":["docs.html","architecture/systems/systems.html","index.html"],"type":"markdown","data":null},"development/development_principles.html":{"createdTime":1760380506337,"modifiedTime":1760380506337,"sourceSize":2569,"sourcePath":"development/DEVELOPMENT_PRINCIPLES.md","exportPath":"development/development_principles.html","showInTree":true,"treeOrder":57,"backlinks":["development/development.html","architecture/systems/systems.html","index.html"],"type":"markdown","data":null},"development/documentation_structure.html":{"createdTime":1760380506337,"modifiedTime":1760380506338,"sourceSize":2114,"sourcePath":"development/DOCUMENTATION_STRUCTURE.md","exportPath":"development/documentation_structure.html","showInTree":true,"treeOrder":58,"backlinks":["development/development.html"],"type":"markdown","data":null},"development/getting-started.html":{"createdTime":1760380506339,"modifiedTime":1760380506339,"sourceSize":2709,"sourcePath":"development/getting-started.md","exportPath":"development/getting-started.html","showInTree":true,"treeOrder":59,"backlinks":["development/development.html","architecture/systems/systems.html","index.html"],"type":"markdown","data":null},"development/tasklist.html":{"createdTime":1760380506339,"modifiedTime":1760380506339,"sourceSize":1233,"sourcePath":"development/tasklist.md","exportPath":"development/tasklist.html","showInTree":true,"treeOrder":60,"backlinks":["development/development.html"],"type":"markdown","data":null},"gameplay/core-mechanics.html":{"createdTime":1760380506340,"modifiedTime":1760380506340,"sourceSize":4350,"sourcePath":"gameplay/core-mechanics.md","exportPath":"gameplay/core-mechanics.html","showInTree":true,"treeOrder":62,"backlinks":["gameplay/gameplay.html"],"type":"markdown","data":null},"gameplay/gameplay.html":{"createdTime":1760380506340,"modifiedTime":1760380506341,"sourceSize":1221,"sourcePath":"gameplay/gameplay.md","exportPath":"gameplay/gameplay.html","showInTree":true,"treeOrder":63,"backlinks":["docs.html","architecture/systems/systems.html","architecture/general/overview.html","index.html"],"type":"markdown","data":null},"legacy/legacy.html":{"createdTime":1760380506341,"modifiedTime":1760380506342,"sourceSize":878,"sourcePath":"legacy/legacy.md","exportPath":"legacy/legacy.html","showInTree":true,"treeOrder":65,"backlinks":["docs.html","architecture/systems/systems.html","index.html"],"type":"markdown","data":null},"legacy/v1-data-strategies.html":{"createdTime":1760380506342,"modifiedTime":1760380506342,"sourceSize":11299,"sourcePath":"legacy/v1-data-strategies.md","exportPath":"legacy/v1-data-strategies.html","showInTree":true,"treeOrder":66,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"legacy/v1-environmental-examples.html":{"createdTime":1760380506342,"modifiedTime":1760380506342,"sourceSize":8492,"sourcePath":"legacy/v1-environmental-examples.md","exportPath":"legacy/v1-environmental-examples.html","showInTree":true,"treeOrder":67,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"legacy/v1-gpu-patterns.html":{"createdTime":1760380506343,"modifiedTime":1760380506343,"sourceSize":10531,"sourcePath":"legacy/v1-gpu-patterns.md","exportPath":"legacy/v1-gpu-patterns.html","showInTree":true,"treeOrder":68,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"legacy/v1-reference.html":{"createdTime":1760380506343,"modifiedTime":1760380506343,"sourceSize":6838,"sourcePath":"legacy/v1-reference.md","exportPath":"legacy/v1-reference.html","showInTree":true,"treeOrder":69,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"legacy/v1-visual-effects.html":{"createdTime":1760380506344,"modifiedTime":1760380506344,"sourceSize":11094,"sourcePath":"legacy/v1-visual-effects.md","exportPath":"legacy/v1-visual-effects.html","showInTree":true,"treeOrder":70,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"docs.html":{"createdTime":1760380506339,"modifiedTime":1760380506340,"sourceSize":1107,"sourcePath":"docs.md","exportPath":"docs.html","showInTree":true,"treeOrder":71,"backlinks":["index.html"],"type":"markdown","data":null},"index.html":{"createdTime":1760380506341,"modifiedTime":1760380506341,"sourceSize":2228,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown","data":null},"site-lib/scripts/graph-wasm.wasm":{"createdTime":1760313890008,"modifiedTime":1760294963031.9873,"sourceSize":23655,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.wasm","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1760382049657,"modifiedTime":1760382049657,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1760382049658,"modifiedTime":1760382049658,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1760382049658,"modifiedTime":1760382049658,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1760382049659,"modifiedTime":1760382049659,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1760382049663,"modifiedTime":1760382049663,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/293fd13dbca5a3e450ef.woff2":{"createdTime":1760382049659,"modifiedTime":1760382049659,"sourceSize":105924,"sourcePath":"","exportPath":"site-lib/fonts/293fd13dbca5a3e450ef.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/085cb93e613ba3d40d2b.woff2":{"createdTime":1760382049659,"modifiedTime":1760382049659,"sourceSize":112184,"sourcePath":"","exportPath":"site-lib/fonts/085cb93e613ba3d40d2b.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1760382049660,"modifiedTime":1760382049660,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1760382049660,"modifiedTime":1760382049660,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1760382049661,"modifiedTime":1760382049661,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1760382049661,"modifiedTime":1760382049661,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1760382049662,"modifiedTime":1760382049662,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1760382049662,"modifiedTime":1760382049662,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1760382049663,"modifiedTime":1760382049663,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1760382049612,"modifiedTime":1760382049612,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1760382049612,"modifiedTime":1760382049612,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1760382049618,"modifiedTime":1760382049618,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1760382050182,"modifiedTime":1760382050182,"sourceSize":31238,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1760313890957,"modifiedTime":1760313890957,"sourceSize":110729,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-wasm.js":{"createdTime":1760313890957,"modifiedTime":1760313890957,"sourceSize":12885,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-render-worker.js":{"createdTime":1760313890957,"modifiedTime":1760313890957,"sourceSize":5681,"sourcePath":"","exportPath":"site-lib/scripts/graph-render-worker.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1760382049518,"modifiedTime":1760382049518,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/snippets.css":{"createdTime":1760382049726,"modifiedTime":1760382049726,"sourceSize":797,"sourcePath":"","exportPath":"site-lib/styles/snippets.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/obsidian.css":{"createdTime":1760382049721,"modifiedTime":1760382049721,"sourceSize":198316,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1760382049590,"modifiedTime":1760382049590,"sourceSize":305,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1760313890992,"modifiedTime":1760313890992,"sourceSize":19521,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/rss.xml":{"createdTime":1760382050269,"modifiedTime":1760382050269,"sourceSize":246032,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null}},"sourceToTarget":{"architecture/general/data-flow.md":"architecture/general/data-flow.html","architecture/general/deterministic-execution.md":"architecture/general/deterministic-execution.html","architecture/general/general.md":"architecture/general/general.html","architecture/general/ghost-simulation.md":"architecture/general/ghost-simulation.html","architecture/general/implementation-guide.md":"architecture/general/implementation-guide.html","architecture/general/overview.md":"architecture/general/overview.html","architecture/general/performance.md":"architecture/general/performance.html","architecture/general/state-management.md":"architecture/general/state-management.html","architecture/general/technical-decisions.md":"architecture/general/technical-decisions.html","architecture/general/variable-timing.md":"architecture/general/variable-timing.html","architecture/systems/config/config.md":"architecture/systems/config/config.html","architecture/systems/core/active-regions.md":"architecture/systems/core/active-regions.html","architecture/systems/core/api-reference.md":"architecture/systems/core/api-reference.html","architecture/systems/core/core.md":"architecture/systems/core/core.html","architecture/systems/core/texture-management.md":"architecture/systems/core/texture-management.html","architecture/systems/core/tile-storage.md":"architecture/systems/core/tile-storage.html","architecture/systems/gpu/gpu.md":"architecture/systems/gpu/gpu.html","architecture/systems/multiplayer/client-prediction.md":"architecture/systems/multiplayer/client-prediction.html","architecture/systems/multiplayer/deployment.md":"architecture/systems/multiplayer/deployment.html","architecture/systems/multiplayer/multiplayer.md":"architecture/systems/multiplayer/multiplayer.html","architecture/systems/multiplayer/network-protocol.md":"architecture/systems/multiplayer/network-protocol.html","architecture/systems/multiplayer/performance.md":"architecture/systems/multiplayer/performance.html","architecture/systems/multiplayer/security.md":"architecture/systems/multiplayer/security.html","architecture/systems/multiplayer/server-architecture.md":"architecture/systems/multiplayer/server-architecture.html","architecture/systems/physics/determinism.md":"architecture/systems/physics/determinism.html","architecture/systems/physics/forces.md":"architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.md":"architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.md":"architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.md":"architecture/systems/physics/physics.html","architecture/systems/reactions/reactions.md":"architecture/systems/reactions/reactions.html","architecture/systems/reactions/rule-compilation.md":"architecture/systems/reactions/rule-compilation.html","architecture/systems/rendering/rendering.md":"architecture/systems/rendering/rendering.html","architecture/systems/spells/cpu-architecture.md":"architecture/systems/spells/cpu-architecture.html","architecture/systems/spells/customization.md":"architecture/systems/spells/customization.html","architecture/systems/spells/mana-system.md":"architecture/systems/spells/mana-system.html","architecture/systems/spells/spells.md":"architecture/systems/spells/spells.html","architecture/systems/spells/spells-and-runes.md":"architecture/systems/spells/spells-and-runes.html","architecture/systems/tools/tools.md":"architecture/systems/tools/tools.html","architecture/systems/ui/ui.md":"architecture/systems/ui/ui.html","architecture/systems/systems.md":"architecture/systems/systems.html","architecture/architecture.md":"architecture/architecture.html","development/building-documentation.md":"development/building-documentation.html","development/development.md":"development/development.html","development/DEVELOPMENT_PRINCIPLES.md":"development/development_principles.html","development/DOCUMENTATION_STRUCTURE.md":"development/documentation_structure.html","development/getting-started.md":"development/getting-started.html","development/tasklist.md":"development/tasklist.html","gameplay/core-mechanics.md":"gameplay/core-mechanics.html","gameplay/gameplay.md":"gameplay/gameplay.html","legacy/legacy.md":"legacy/legacy.html","legacy/v1-data-strategies.md":"legacy/v1-data-strategies.html","legacy/v1-environmental-examples.md":"legacy/v1-environmental-examples.html","legacy/v1-gpu-patterns.md":"legacy/v1-gpu-patterns.html","legacy/v1-reference.md":"legacy/v1-reference.html","legacy/v1-visual-effects.md":"legacy/v1-visual-effects.html","docs.md":"docs.html","index.md":"index.html","":"site-lib/rss.xml"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Backlinks","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Aliases","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Properties","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Search...","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Outline","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Graph View","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"hideSettingsButton":false,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"rss","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"siteUrl":"","authorName":"","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}},"linkPreview":{"featureId":"link-preview","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":true}},"modifiedTime":1760382049733,"siteName":"source_docs","vaultName":"docs","exportRoot":"","baseURL":"","pluginVersion":"1.9.2","themeName":"","bodyClasses":"publish css-settings-manager show-inline-title show-ribbon is-focused","hasFavicon":false}