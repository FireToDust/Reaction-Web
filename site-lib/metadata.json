{"createdTime":1760381438065,"shownInTree":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/overview.html","architecture/general/performance.html","architecture/general/shader-data-layout.html","architecture/general/state-management.html","architecture/general/technical-decisions.html","architecture/general/variable-timing.html","architecture/systems/config/config.html","architecture/systems/gpu/gpu.html","architecture/systems/multiplayer/deployment.html","architecture/systems/multiplayer/multiplayer.html","architecture/systems/multiplayer/network-protocol.html","architecture/systems/multiplayer/performance.html","architecture/systems/multiplayer/security.html","architecture/systems/multiplayer/server-architecture.html","architecture/systems/physics/determinism.html","architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.html","architecture/systems/physics/reactions.html","architecture/systems/rendering/rendering.html","architecture/systems/spells/cpu-architecture.html","architecture/systems/spells/customization.html","architecture/systems/spells/deck-building.html","architecture/systems/spells/element-system.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/ui/ui.html","architecture/systems/systems.html","architecture/architecture.html","development/building-documentation.html","development/development.html","development/development_principles.html","development/documentation_structure.html","development/getting-started.html","development/tasklist.html","gameplay/core-mechanics.html","gameplay/gameplay.html","legacy/legacy.html","legacy/v1-data-strategies.html","legacy/v1-environmental-examples.html","legacy/v1-gpu-patterns.html","legacy/v1-reference.html","legacy/v1-visual-effects.html","docs.html","index.html"],"attachments":["site-lib/scripts/graph-wasm.wasm","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/main-styles.css","site-lib/rss.xml"],"allFiles":["architecture/systems/physics/reactions.html","architecture/systems/physics/physics.html","architecture/systems/systems.html","architecture/general/shader-data-layout.html","architecture/systems/physics/determinism.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/forces.html","architecture/systems/physics/movement-system.html","architecture/systems/spells/element-system.html","architecture/systems/spells/cpu-architecture.html","architecture/systems/spells/customization.html","architecture/systems/spells/deck-building.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells.html","architecture/general/overview.html","architecture/general/technical-decisions.html","gameplay/core-mechanics.html","architecture/general/performance.html","architecture/systems/multiplayer/network-protocol.html","architecture/systems/multiplayer/multiplayer.html","architecture/general/general.html","architecture/architecture.html","architecture/general/deterministic-execution.html","architecture/general/implementation-guide.html","architecture/systems/gpu/gpu.html","legacy/v1-data-strategies.html","legacy/v1-gpu-patterns.html","legacy/v1-reference.html","legacy/v1-visual-effects.html","index.html","development/tasklist.html","development/documentation_structure.html","development/development.html","legacy/legacy.html","legacy/v1-environmental-examples.html","gameplay/gameplay.html","docs.html","development/getting-started.html","development/building-documentation.html","architecture/systems/ui/ui.html","development/development_principles.html","architecture/systems/rendering/rendering.html","architecture/systems/multiplayer/server-architecture.html","architecture/systems/multiplayer/security.html","architecture/systems/multiplayer/performance.html","architecture/systems/multiplayer/deployment.html","architecture/systems/config/config.html","architecture/general/variable-timing.html","architecture/general/state-management.html","architecture/general/ghost-simulation.html","architecture/general/data-flow.html","site-lib/scripts/graph-wasm.wasm","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/main-styles.css"],"webpages":{"architecture/general/data-flow.html":{"title":"data-flow","icon":"","description":"⚠️ OUTDATED DOCUMENT: This document describes a previously proposed Deterministic Time-Sliced Execution pipeline. The physics system has been updated and this document no longer reflects the current architectural direction. This document will be rebuilt to match the current physics system approach.The new pipeline subdivides each 60 FPS frame into 8 time slices, enabling variable player action timing while maintaining perfect determinism for multiplayer.\nFrame Duration: 16.67ms (60 FPS)\nTime Slices: 8 slices per frame (2.08ms each)\nVariable Timing: Different systems execute at different slice intervals\nDeterministic Order: All processing uses strict spatial/temporal ordering\nEach frame processes 8 time slices in deterministic order:\nScheduled Action Processing: Execute player actions based on individual timing\nMana Recharge Processing: Fixed 3-action interval regardless of player speed\nPhysics Processing: Every slice for 60 FPS smooth motion\nReaction Processing: Less frequent, deterministic intervals\nGhost Prediction Updates: Maintain 3-action lookahead for all players State Snapshot: Save complete game state for rollback/networking\nNetwork Delta Generation: Create compressed updates for multiplayer\nValidation: Verify deterministic execution consistency Base Interval: 8 time slices (normal speed)\nSpeed Multipliers: Status effects modify timing (0.5x = slowed, 2x = hasted)\nImmediate Application: Speed changes affect next scheduled action\nDeterministic Order: Players processed by ID for consistent results Fixed Schedule: 24 time slices (3 base actions) regardless of player speed\nStrategic Consistency: Mana timing remains constant tactical element\nIndependent Processing: Separate from player action timing 3-Action Lookahead: Players maintain queue of upcoming actions\nGhost Predictions: Visual preview of queued actions\nQueue Validation: Invalid actions automatically replaced Spatial Ordering: Process tiles in strict top-left to bottom-right order\nChunk Processing: Handle 32×32 chunks in deterministic sequence\nInteger Mathematics: Fixed-point arithmetic prevents floating-point drift\nSynchronization Barriers: GPU compute barriers ensure execution order Deterministic Math Library: Custom integer-only calculations\nHardware Independence: Identical results across GPU architectures\nValidation Testing: Automated cross-platform determinism verification Single Pipeline: Same engine for single-player and multiplayer modes\nState Snapshots: Automatic frame-based state saving\nRollback Capability: Support for multiplayer prediction correction\nNetwork Synchronization: Frame-based state delta compression Client Prediction: Local state prediction with server validation\nRollback Recovery: Automatic correction on server mismatch\nNetwork Protocol: Frame-synchronized state updates\nGhost Simulation: Predictive action visualization Selective Processing: Only active systems process each slice\nGPU Batching: Maintain efficient compute shader dispatches\nMemory Coherence: Optimize texture access patterns\nChunk Activation: Process only regions with activity Adaptive Frequencies: Reduce reaction frequency under load\nPrediction Caching: Cache ghost simulations for performance\nNetwork Efficiency: Delta compression minimizes bandwidth\nState Cleanup: Automatic old state garbage collection cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/deterministic-execution.html\" data-href=\"deterministic-execution\" aria-label=\"deterministic-execution\" data-tooltip-position=\"top\" target=\"_self\">Deterministic Execution</a> - GPU determinism and cross-platform consistency\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Time slice scheduling and player action management\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/state-management.html\" data-href=\"state-management\" aria-label=\"state-management\" data-tooltip-position=\"top\" target=\"_self\">State Management</a> - Snapshots, rollback, and multiplayer synchronization\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/ghost-simulation.html\" data-href=\"ghost-simulation\" aria-label=\"ghost-simulation\" data-tooltip-position=\"top\" target=\"_self\">Ghost Simulation</a> - Predictive action visualization system\n⚠️ NEEDS TEAM DISCUSSION: Optimal time slice count (8 vs 4 vs 16)\nPerformance impact of deterministic GPU ordering\nGhost simulation complexity vs performance trade-offs\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Data Flow Architecture","level":1,"id":"Data_Flow_Architecture_0"},{"heading":"Pipeline Overview: Deterministic Time-Sliced Execution","level":2,"id":"Pipeline_Overview_Deterministic_Time-Sliced_Execution_0"},{"heading":"Key Innovation","level":3,"id":"Key_Innovation_0"},{"heading":"Frame Execution Pipeline","level":2,"id":"Frame_Execution_Pipeline_0"},{"heading":"Time Slice Processing (Repeated 8x per frame)","level":3,"id":"Time_Slice_Processing_(Repeated_8x_per_frame)_0"},{"heading":"Frame Completion","level":3,"id":"Frame_Completion_0"},{"heading":"Variable Timing System","level":2,"id":"Variable_Timing_System_0"},{"heading":"Player Action Scheduling","level":3,"id":"Player_Action_Scheduling_0"},{"heading":"Mana Recharge Timing","level":3,"id":"Mana_Recharge_Timing_0"},{"heading":"Action Queue Management","level":3,"id":"Action_Queue_Management_0"},{"heading":"Deterministic Execution Framework","level":2,"id":"Deterministic_Execution_Framework_0"},{"heading":"GPU Determinism Strategy","level":3,"id":"GPU_Determinism_Strategy_0"},{"heading":"Cross-Platform Consistency","level":3,"id":"Cross-Platform_Consistency_0"},{"heading":"State Management Integration","level":2,"id":"State_Management_Integration_0"},{"heading":"Unified State System","level":3,"id":"Unified_State_System_0"},{"heading":"Multiplayer Integration","level":3,"id":"Multiplayer_Integration_0"},{"heading":"Performance Optimizations","level":2,"id":"Performance_Optimizations_0"},{"heading":"Time Slice Efficiency","level":3,"id":"Time_Slice_Efficiency_0"},{"heading":"Scalability Considerations","level":3,"id":"Scalability_Considerations_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Detailed Implementation","level":3,"id":"Detailed_Implementation_0"}],"links":["architecture/general/deterministic-execution.html","architecture/general/variable-timing.html","architecture/general/state-management.html","architecture/general/ghost-simulation.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/data-flow.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506316,"modifiedTime":1760380506317,"sourceSize":5271,"sourcePath":"architecture/general/data-flow.md","exportPath":"architecture/general/data-flow.html","showInTree":true,"treeOrder":2,"backlinks":["architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/general/overview.html"],"type":"markdown"},"architecture/general/deterministic-execution.html":{"title":"deterministic-execution","icon":"","description":"⚠️ PROPOSED SYSTEM: This document describes the proposed deterministic execution approach for GPU-accelerated physics and reactions. This system solves the fundamental challenge of achieving identical results across different hardware for competitive multiplayer.⚠️ CURRENT APPROACH: The actual determinism strategy being used is simultaneous single-read/single-write GPU passes with deterministic internal rules, NOT the spatial ordering strategy described below. The spatial ordering and active region approaches have been superseded.Core Issue: GPU thread execution order within workgroups is not inherently deterministic.Impact:\nNon-deterministic collision resolution between tiles\nInconsistent force application results\nDifferent outcomes on different hardware\nBreaks competitive multiplayer requirements\nCriticality: Essential for fair PvP gameplay and replay capability.⚠️ NOTE: The current architecture achieves determinism through simultaneous single-read and single-write GPU passes, with all operations happening at the same time using deterministic internal rules. This is NOT the spatial ordering strategy described in the following section.⚠️ OUTDATED: The following spatial ordering strategy is NOT being used in the current architecture.Chunk-Level Ordering: Process 32×32 chunks in strict spatial sequence (top-left to bottom-right).Tile-Level Ordering: Within each chunk, process tiles in deterministic spatial order.Player-Level Ordering: Process players in consistent ID-based sequence.// Deterministic tile processing within chunk\nlayout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in; void main() { // Map thread to deterministic tile position ivec2 chunkPos = getChunkPosition(); ivec2 localPos = ivec2(gl_LocalInvocationID.xy); ivec2 tilePos = chunkPos * 32 + localPos * 4; // Process 4 tiles per thread in spatial order for (int i = 0; i &lt; 4; i++) { ivec2 currentTile = tilePos + ivec2(i % 2, i / 2); processTileDeterministic(currentTile); }\n}\nPrecision: 16.16 fixed-point format (16 bits integer, 16 bits fractional).Operations: All calculations use integer arithmetic to prevent floating-point drift.Cross-Platform Consistency: Identical results regardless of GPU floating-point implementation.class DeterministicMath { static readonly FIXED_POINT_SCALE = 65536; // 2^16 // Deterministic multiplication static multiply(a: number, b: number): number { return Math.floor((a * b) / this.FIXED_POINT_SCALE); } // Deterministic collision detection static checkCollision(pos1: Point, pos2: Point, radius: number): boolean { const dx = pos1.x - pos2.x; const dy = pos1.y - pos2.y; const distanceSquared = dx * dx + dy * dy; const radiusSquared = radius * radius; return distanceSquared &lt;= radiusSquared; } // Deterministic force resolution static resolveCollision(tile1: TileState, tile2: TileState): CollisionResult { // Use consistent tie-breaking rules const primaryTile = tile1.id &lt; tile2.id ? tile1 : tile2; const secondaryTile = tile1.id &lt; tile2.id ? tile2 : tile1; return this.calculateForces(primaryTile, secondaryTile); }\n}\nExecution Phases: Use compute barriers to enforce processing order between dependent operations.Memory Barriers: Ensure texture writes complete before subsequent reads.Workgroup Synchronization: Coordinate processing within and between workgroups.Read-Write Separation: Maintain existing texture ping-ponging for race condition prevention.Deterministic Swapping: Ensure texture role swapping occurs at consistent points.State Consistency: Verify texture state consistency across deterministic processing.Replay Tests: Identical input sequences must produce identical outputs.Hardware Variation Testing: Validate consistency across different GPU architectures.Stress Testing: Verify determinism under high load and complex scenarios.class DeterminismValidator { private frameChecksums = new Map&lt;number, string&gt;(); validateFrame(frameNumber: number, gameState: GameState): boolean { const checksum = this.calculateStateChecksum(gameState); const expectedChecksum = this.frameChecksums.get(frameNumber); if (expectedChecksum &amp;&amp; expectedChecksum !== checksum) { console.error(`Determinism failure at frame ${frameNumber}`); return false; } this.frameChecksums.set(frameNumber, checksum); return true; } private calculateStateChecksum(state: GameState): string { // Create deterministic hash of all relevant game state const stateData = this.serializeGameState(state); return this.deterministicHash(stateData); }\n}\nDeterminism-First Design: Consider determinism impact of all changes.Validation Requirements: Test determinism before and after modifications.Code Review Focus: Explicit review of determinism implications.Documentation: Document assumptions about execution order and state dependencies.Overhead Analysis: Spatial ordering adds ~5-10% GPU processing overhead.Optimization Opportunities: Maintain determinism while optimizing memory access patterns.Fallback Strategies: ⚠️ NEEDS DISCUSSION - CPU fallback for determinism-critical operations if GPU determinism proves insufficient.Hardware Differences: Test across NVIDIA, AMD, and Intel GPU architectures.Driver Updates: Establish testing protocol for graphics driver changes.Compatibility Matrix: Maintain supported hardware and driver combinations.Optimization Constraints: Some GPU optimizations may break determinism.Testing Requirements: Extensive validation needed for any physics changes.Quality Assurance: Determinism testing integrated into CI/CD pipeline.\ncross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Parent pipeline architecture\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Time slice scheduling integration\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/performance.html\" data-href=\"performance\" aria-label=\"performance\" data-tooltip-position=\"top\" target=\"_self\">Performance Strategy</a> - Optimization approaches with determinism constraints\n⚠️ NEEDS IMPLEMENTATION: GPU compute shader templates for deterministic processing\nCross-platform validation test suite\nPerformance benchmarking of spatial ordering overhead\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Deterministic Execution Framework","level":1,"id":"Deterministic_Execution_Framework_0"},{"heading":"Problem Statement","level":2,"id":"Problem_Statement_0"},{"heading":"GPU Non-Determinism Challenge","level":3,"id":"GPU_Non-Determinism_Challenge_0"},{"heading":"Solution: Simultaneous Read/Write Passes (Current Approach)","level":2,"id":"Solution_Simultaneous_Read/Write_Passes_(Current_Approach)_0"},{"heading":"<del>Solution: Spatial Ordering Strategy</del> (Outdated Approach)","level":2,"id":"~~Solution_Spatial_Ordering_Strategy~~_(Outdated_Approach)_0"},{"heading":"<del>Deterministic Processing Order</del>","level":3,"id":"~~Deterministic_Processing_Order~~_0"},{"heading":"GPU Compute Implementation","level":3,"id":"GPU_Compute_Implementation_0"},{"heading":"Integer-Only Mathematics","level":2,"id":"Integer-Only_Mathematics_0"},{"heading":"Fixed-Point Arithmetic System","level":3,"id":"Fixed-Point_Arithmetic_System_0"},{"heading":"Deterministic Math Library","level":3,"id":"Deterministic_Math_Library_0"},{"heading":"Synchronization Strategy","level":2,"id":"Synchronization_Strategy_0"},{"heading":"GPU Compute Barriers","level":3,"id":"GPU_Compute_Barriers_0"},{"heading":"Texture Ping-Ponging Integration","level":3,"id":"Texture_Ping-Ponging_Integration_0"},{"heading":"Cross-Platform Validation","level":2,"id":"Cross-Platform_Validation_0"},{"heading":"Automated Testing Framework","level":3,"id":"Automated_Testing_Framework_0"},{"heading":"Validation Checkpoints","level":3,"id":"Validation_Checkpoints_0"},{"heading":"Implementation Guidelines","level":2,"id":"Implementation_Guidelines_0"},{"heading":"Development Practices","level":3,"id":"Development_Practices_0"},{"heading":"Performance Considerations","level":3,"id":"Performance_Considerations_0"},{"heading":"Risk Mitigation","level":2,"id":"Risk_Mitigation_0"},{"heading":"GPU Driver Variations","level":3,"id":"GPU_Driver_Variations_0"},{"heading":"Performance Vs Determinism Trade-offs","level":3,"id":"Performance_Vs_Determinism_Trade-offs_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/variable-timing.html","architecture/general/performance.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/deterministic-execution.html","pathToRoot":"../..","attachments":[],"createdTime":1760397027347,"modifiedTime":1760397027347,"sourceSize":7976,"sourcePath":"architecture/general/deterministic-execution.md","exportPath":"architecture/general/deterministic-execution.html","showInTree":true,"treeOrder":3,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html","architecture/general/implementation-guide.html","architecture/general/variable-timing.html"],"type":"markdown"},"architecture/general/general.html":{"title":"general","icon":"","description":"Core architectural concepts, design patterns, and system design documentation for Reaction v2.\n<a class=\"internal-link\" data-href=\"overview.md\" href=\"architecture/general/overview.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>System Overview - Complete architectural design and module relationships\n<br><a class=\"internal-link\" data-href=\"data-flow.md\" href=\"architecture/general/data-flow.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Data Flow - Frame execution pipeline and module communication ⚠️ OUTDATED\n<br><a class=\"internal-link\" data-href=\"performance.md\" href=\"architecture/general/performance.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Performance Strategy - Optimization approaches and technical constraints\n<br><a class=\"internal-link\" data-href=\"technical-decisions.md\" href=\"architecture/general/technical-decisions.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Technical Decisions - Design choices and rationale <br><a class=\"internal-link\" data-href=\"implementation-guide.md\" href=\"architecture/general/implementation-guide.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Implementation Guide - Step-by-step implementation approach ⚠️ OUTDATED\n<br><a class=\"internal-link\" data-href=\"deterministic-execution.md\" href=\"architecture/general/deterministic-execution.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Deterministic Execution - GPU determinism and cross-platform consistency ⚠️ PARTIALLY OUTDATED\n<br><a class=\"internal-link\" data-href=\"variable-timing.md\" href=\"architecture/general/variable-timing.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Variable Timing System - Time slice scheduling and player action management ⚠️ PROPOSED\n<br><a class=\"internal-link\" data-href=\"state-management.md\" href=\"architecture/general/state-management.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>State Management - Snapshots, rollback, and multiplayer synchronization ⚠️ PROPOSED\n<br><a class=\"internal-link\" data-href=\"ghost-simulation.md\" href=\"architecture/general/ghost-simulation.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Ghost Simulation - Predictive action visualization system ⚠️ PROPOSED\nModular Design: Modules with focused responsibilitiesWebGPU Processing: Physics, reactions, and rendering use GPU computeDeterministic Requirements: Identical inputs must produce identical outputs for PvP through simultaneous single-read/single-write GPU passesActive Region System: Process only chunks with changing tiles ⚠️ NOT IMPLEMENTED: Active region optimization was decided against⚠️ Unsolved Issues Requiring Design Work:\nFrame rate coordination between physics, reactions, and rendering systems\nGPU thread execution determinism guarantees (current approach: simultaneous read/write passes)\nSpecific rule compilation pipeline implementation\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"General Architecture Documentation","level":1,"id":"General_Architecture_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Architecture","level":3,"id":"Core_Architecture_0"},{"heading":"Implementation Guides","level":3,"id":"Implementation_Guides_0"},{"heading":"Architectural Approach","level":2,"id":"Architectural_Approach_0"},{"heading":"Major Technical Challenges","level":2,"id":"Major_Technical_Challenges_0"}],"links":["architecture/general/overview.html","architecture/general/data-flow.html","architecture/general/performance.html","architecture/general/technical-decisions.html","architecture/general/implementation-guide.html","architecture/general/deterministic-execution.html","architecture/general/variable-timing.html","architecture/general/state-management.html","architecture/general/ghost-simulation.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/general.html","pathToRoot":"../..","attachments":[],"createdTime":1760397071790,"modifiedTime":1760397071790,"sourceSize":2286,"sourcePath":"architecture/general/general.md","exportPath":"architecture/general/general.html","showInTree":true,"treeOrder":4,"backlinks":["architecture/architecture.html"],"type":"markdown"},"architecture/general/ghost-simulation.html":{"title":"ghost-simulation","icon":"","description":"⚠️ PROPOSED SYSTEM: This document describes the proposed predictive action visualization system that shows players their queued actions and their likely outcomes without affecting the main game simulation.Action Preview: Show visual representation of 3 queued player actions.Spell Effect Prediction: Display where runes will be placed and their likely effects.Movement Prediction: Show future player positions based on queued movement.Performance Constraint: Ghost simulation must not impact main game performance.Simplified Rules: Use fast approximations instead of full physics/reaction simulation.Position-Only Physics: Predict movement without complex collision interactions.Basic Spell Effects: Show rune placement without full environmental predictions.Selective Simulation: Only simulate aspects visible to players.interface GhostPrediction { actionIndex: number; // Which queued action (0, 1, 2) playerPosition: Position; // Predicted player position spellEffects: RunePlacement[]; // Predicted rune placements confidence: number; // Prediction confidence (0-1) timestamp: number; // When prediction was generated\n} class GhostSimulator { private predictionCache = new Map&lt;string, GhostPrediction[]&gt;(); private simulationComplexity: 'minimal' | 'basic' | 'detailed' = 'basic'; updatePlayerGhosts(playerId: string): GhostPrediction[] { const cacheKey = this.generateCacheKey(playerId); // Check cache validity if (this.isCacheValid(cacheKey)) { return this.predictionCache.get(cacheKey); } // Generate new predictions const predictions = this.simulatePlayerActions(playerId); this.predictionCache.set(cacheKey, predictions); return predictions; }\n}\nMinimal: Position-only prediction with no interaction simulation.\nMovement vectors applied directly\nSpell targeting shown without environmental effects\nFastest performance, lowest accuracy\nBasic: Position + simple spell effects prediction.\nBasic collision detection for movement\nRune placement validation\nSimple environmental effects (obvious barriers, holes)\nBalanced performance and accuracy\nDetailed: Full simulation using simplified rules.\nComplete physics simulation with reduced precision\nEnvironmental rule evaluation with fast heuristics\nComplex spell interactions predicted\nHigher accuracy, potential performance impact\nclass MovementPredictor { predictMovement(player: PlayerState, action: MovementAction): Position { let currentPos = player.position; const moveVector = this.calculateMoveVector(action); // Simple collision detection for ghost prediction const targetPos = { x: currentPos.x + moveVector.x, y: currentPos.y + moveVector.y }; // Check for obvious barriers if (this.isPositionBlocked(targetPos)) { return currentPos; // No movement if blocked } return targetPos; } private isPositionBlocked(position: Position): boolean { // Simplified collision detection for performance const tile = this.getTileAt(position); return tile?.type === TileType.SOLID || tile?.type === TileType.WALL; }\n}\nclass SpellEffectPredictor { predictSpellCast(player: PlayerState, spell: SpellAction): RunePlacement[] { const placements: RunePlacement[] = []; // Validate mana requirements if (!this.hasRequiredMana(player, spell)) { return []; // No effect if insufficient mana } // Calculate rune placements const pattern = this.getSpellPattern(spell.spellId); const targetPos = spell.targetPosition; for (const offset of pattern.runeOffsets) { const runePos = { x: targetPos.x + offset.x, y: targetPos.y + offset.y }; // Basic placement validation if (this.canPlaceRune(runePos)) { placements.push({ position: runePos, runeType: pattern.runeType, delay: pattern.delay, confidence: this.calculatePlacementConfidence(runePos) }); } } return placements; }\n}\nCache Keys: Based on player state hash and action queue hash.Invalidation: Cache invalidated when player state or world state changes significantly.Selective Updates: Only update ghosts for players whose state changed.class GhostCacheManager { private readonly CACHE_DURATION = 100; // ms generateCacheKey(playerId: string): string { const player = this.getPlayer(playerId); const actionQueueHash = this.hashActionQueue(player.actionQueue); const playerStateHash = this.hashPlayerState(player); const worldStateHash = this.getRelevantWorldStateHash(player.position); return `${playerId}-${actionQueueHash}-${playerStateHash}-${worldStateHash}`; } isCacheValid(cacheKey: string): boolean { const cached = this.predictionCache.get(cacheKey); if (!cached) return false; const age = performance.now() - cached.timestamp; return age &lt; this.CACHE_DURATION; } invalidatePlayerCache(playerId: string): void { // Remove all cache entries for this player for (const [key, _] of this.predictionCache) { if (key.startsWith(playerId)) { this.predictionCache.delete(key); } } }\n}\nPerformance Monitoring: Adjust simulation complexity based on frame rate.Player Count Scaling: Reduce complexity when many players are active.Network Condition Adaptation: Simplify predictions on slow connections.class AdaptiveGhostManager { private performanceMonitor = new PerformanceMonitor(); updateSimulationComplexity(): void { const currentFPS = this.performanceMonitor.getCurrentFPS(); const playerCount = this.getActivePlayerCount(); if (currentFPS &lt; 55 || playerCount &gt; 6) { this.ghostSimulator.setComplexity('minimal'); } else if (currentFPS &lt; 58 || playerCount &gt; 4) { this.ghostSimulator.setComplexity('basic'); } else { this.ghostSimulator.setComplexity('detailed'); } }\n}\nPlayer Ghosts: Translucent player sprites at predicted positions.Action Indicators: Visual cues showing queued action types.Spell Previews: Targeting lines and rune placement previews.Confidence Visualization: Alpha/color coding based on prediction confidence.interface GhostVisual { playerId: string; actionIndex: number; position: Position; alpha: number; // Transparency based on confidence actionIndicator: ActionType; spellPreview?: SpellPreview;\n} class GhostRenderer { renderPlayerGhosts(predictions: GhostPrediction[]): void { for (let i = 0; i &lt; predictions.length; i++) { const prediction = predictions[i]; const alpha = this.calculateAlpha(prediction.confidence, i); this.renderGhostPlayer({ playerId: prediction.playerId, actionIndex: i, position: prediction.playerPosition, alpha: alpha, actionIndicator: prediction.actionType, spellPreview: prediction.spellEffects }); } } private calculateAlpha(confidence: number, actionIndex: number): number { // Closer actions are more opaque, further actions more transparent const timeAlpha = 1.0 - (actionIndex * 0.2); const confidenceAlpha = 0.3 + (confidence * 0.7); return timeAlpha * confidenceAlpha; }\n}\nPrediction Timing: Account for variable action timing in predictions.Speed Effect Integration: Update predictions when player speed changes.Action Queue Synchronization: Maintain predictions synchronized with action queue.class GhostTimingIntegration { updateGhostTimingForSpeedChange(playerId: string, newSpeedMultiplier: number): void { // Recalculate prediction timing based on new speed const predictions = this.ghostSimulator.getPlayerPredictions(playerId); for (const prediction of predictions) { const newTiming = this.recalculateActionTiming( prediction.actionIndex, newSpeedMultiplier ); prediction.expectedExecutionSlice = newTiming; } // Invalidate cache to force regeneration this.ghostCacheManager.invalidatePlayerCache(playerId); } private recalculateActionTiming(actionIndex: number, speedMultiplier: number): number { const baseInterval = 8; // 8 time slices per action at normal speed const adjustedInterval = Math.ceil(baseInterval / speedMultiplier); return this.currentSlice + (adjustedInterval * (actionIndex + 1)); }\n}\nInvalid Actions: Show warning indicators for actions that can't be executed.Resource Conflicts: Display mana insufficiency or other blocking conditions.Simulation Errors: Graceful degradation to simpler prediction methods.class GhostErrorHandler { handlePredictionError(playerId: string, error: PredictionError): GhostPrediction { console.warn(`Ghost prediction error for ${playerId}:`, error); switch (error.type) { case 'insufficient-mana': return this.createManaWarningGhost(playerId, error.actionIndex); case 'invalid-target': return this.createTargetWarningGhost(playerId, error.actionIndex); case 'simulation-timeout': return this.fallbackToPositionOnlyPrediction(playerId, error.actionIndex); default: return this.createErrorGhost(playerId, error.actionIndex); } }\n}\nAccuracy Metrics: Track how often predictions match actual outcomes.Performance Benchmarks: Monitor ghost simulation performance impact.User Experience Testing: Validate that ghost feedback improves gameplay.Action Queue Edge Cases: Test ghost behavior with rapidly changing queues.Speed Effect Interactions: Verify ghost timing updates with status effects.Network Lag Simulation: Test ghost behavior under various network conditions.\ncross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Parent pipeline architecture\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Integration with action scheduling\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/rendering/rendering.html\" data-href=\"rendering\" aria-label=\"rendering\" data-tooltip-position=\"top\" target=\"_self\">Renderer System</a> - Visual rendering integration\n⚠️ NEEDS TEAM DISCUSSION:\nDefault simulation complexity level (minimal/basic/detailed)\nGhost prediction accuracy vs performance trade-offs\nVisual design for ghost representation (transparency, colors, indicators)\n⚠️ NEEDS IMPLEMENTATION:\nPerformance benchmarking of different complexity levels\nUser experience testing of ghost feedback effectiveness\nIntegration testing with action queue and timing systems\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Ghost Simulation System","level":1,"id":"Ghost_Simulation_System_0"},{"heading":"Design Goals","level":2,"id":"Design_Goals_0"},{"heading":"Player Feedback Requirements","level":3,"id":"Player_Feedback_Requirements_0"},{"heading":"Ghost Simulation Architecture","level":2,"id":"Ghost_Simulation_Architecture_0"},{"heading":"Lightweight Simulation Strategy","level":3,"id":"Lightweight_Simulation_Strategy_0"},{"heading":"Simulation Complexity Levels","level":3,"id":"Simulation_Complexity_Levels_0"},{"heading":"Prediction Algorithms","level":2,"id":"Prediction_Algorithms_0"},{"heading":"Movement Prediction","level":3,"id":"Movement_Prediction_0"},{"heading":"Spell Effect Prediction","level":3,"id":"Spell_Effect_Prediction_0"},{"heading":"Performance Optimization","level":2,"id":"Performance_Optimization_0"},{"heading":"Caching Strategy","level":3,"id":"Caching_Strategy_0"},{"heading":"Adaptive Complexity","level":3,"id":"Adaptive_Complexity_0"},{"heading":"Visual Representation","level":2,"id":"Visual_Representation_0"},{"heading":"Ghost Rendering","level":3,"id":"Ghost_Rendering_0"},{"heading":"Integration with Timing System","level":2,"id":"Integration_with_Timing_System_0"},{"heading":"Time Slice Synchronization","level":3,"id":"Time_Slice_Synchronization_0"},{"heading":"Error Handling and Fallbacks","level":2,"id":"Error_Handling_and_Fallbacks_0"},{"heading":"Prediction Failures","level":3,"id":"Prediction_Failures_0"},{"heading":"Testing and Validation","level":2,"id":"Testing_and_Validation_0"},{"heading":"Prediction Accuracy","level":3,"id":"Prediction_Accuracy_0"},{"heading":"Edge Case Coverage","level":3,"id":"Edge_Case_Coverage_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/variable-timing.html","architecture/systems/rendering/rendering.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/ghost-simulation.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506318,"modifiedTime":1760380506318,"sourceSize":12880,"sourcePath":"architecture/general/ghost-simulation.md","exportPath":"architecture/general/ghost-simulation.html","showInTree":true,"treeOrder":5,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html"],"type":"markdown"},"architecture/general/implementation-guide.html":{"title":"implementation-guide","icon":"","description":"⚠️ OUTDATED IMPLEMENTATION PLAN: This document describes the implementation approach for an outdated Deterministic Time-Sliced Execution pipeline that is no longer being pursued. The current architecture uses simultaneous single-read/single-write GPU passes for determinism, does not use spatial ordering, and has decided against the active region optimization system.⚠️ PROPOSED IMPLEMENTATION PLAN: This document outlines the suggested implementation approach for the Deterministic Time-Sliced Execution pipeline. All timelines and priorities should be validated with the team.Goal: Establish deterministic frame processing with time slicing.Components:\nDeterministicTimeSlicedPipeline - Main pipeline class\nTimeSliceScheduler - Variable timing management DeterministicMath - Integer-only math library\nStateSnapshotManager - Frame-based state capture\nSuccess Criteria: 60 FPS deterministic execution with variable player action timing.Estimated Complexity: High - foundational architecture changes required.Goal: Achieve consistent GPU processing across platforms.Components:\nSpatialOrderingStrategy - Deterministic tile processing order\nDeterministicGPUProcessor - GPU compute shader coordination\nFixedPointMath - GPU shader math library\nDeterminismValidator - Cross-platform testing framework\nSuccess Criteria: Identical results across different GPU hardware.Estimated Complexity: Very High - requires low-level GPU programming expertise.Goal: Unified state system for single-player and multiplayer.Components:\nUnifiedGameEngine - Mode-agnostic game engine\nRollbackManager - State restoration and replay\nDeltaCompressor - Network-efficient state compression\nClientPredictionManager - Multiplayer prediction integration\nSuccess Criteria: Seamless transition between single-player and multiplayer modes.Estimated Complexity: Medium - builds on established state management patterns.Goal: Predictive action visualization for player feedback.Components:\nGhostSimulator - Lightweight prediction engine\nGhostCacheManager - Performance optimization\nGhostRenderer - Visual representation system AdaptiveComplexityManager - Performance scaling\nSuccess Criteria: Clear action previews without performance impact.Estimated Complexity: Medium - primarily feature development on stable foundation.GPU Determinism: Cross-platform consistency may require extensive hardware testing.Performance Impact: Time slicing overhead needs careful optimization.Multiplayer Synchronization: Complex integration with existing network protocol.Incremental Development: Implement and validate each component independently.Performance Monitoring: Continuous benchmarking throughout development.Fallback Plans: CPU-based fallbacks for problematic GPU determinism cases.Texture Management: Adapt ping-ponging system for time-sliced execution.Active Regions: Integrate chunk processing with spatial ordering.API Changes: Update Core Engine API for new pipeline integration.Deterministic Processing: Replace existing physics with spatial ordering approach.Time Slice Integration: Adapt physics updates to variable frequency execution.Integer Mathematics: Convert physics calculations to fixed-point arithmetic.Action Scheduling: Replace immediate execution with time-slice scheduling.Mana Management: Implement separate timing system for mana recharge.Queue Management: Add 3-action lookahead system with ghost predictions.Automated Validation: CI/CD integration for determinism regression testing.Cross-Platform Testing: Validation across different GPU architectures.Performance Benchmarking: Continuous monitoring of pipeline overhead.Network Simulation: Test under various latency and packet loss conditions.Prediction Accuracy: Monitor client prediction success rates.Synchronization Validation: Ensure frame-perfect client-server alignment.Documentation: All new components require comprehensive documentation.Testing: Unit tests for deterministic components, integration tests for pipeline.Performance: Benchmark all changes against baseline performance metrics.Architecture Reviews: Major pipeline changes require team architectural review.Implementation Discussion: Technical details should be validated before implementation.Progress Tracking: Regular updates on implementation progress and blockers.\nFrame Rate: Maintain 60 FPS with up to 8 players\nDeterminism: 100% consistency across identical inputs Latency: &lt;50ms total input-to-response latency in multiplayer\nMemory: &lt;20% increase in memory usage for state management Cross-Platform: Identical results on all supported GPU architectures\nNetwork Efficiency: &lt;16MB bandwidth per player per minute\nUser Experience: Smooth ghost predictions for all player actions cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Complete pipeline specification\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/deterministic-execution.html\" data-href=\"deterministic-execution\" aria-label=\"deterministic-execution\" data-tooltip-position=\"top\" target=\"_self\">Deterministic Execution</a> - GPU determinism implementation\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Time slice scheduling details\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/state-management.html\" data-href=\"state-management\" aria-label=\"state-management\" data-tooltip-position=\"top\" target=\"_self\">State Management</a> - Unified state system architecture\n⚠️ NEEDS TEAM VALIDATION:\nImplementation timeline and resource allocation\nTechnical risk tolerance and fallback strategies Performance targets and quality requirements\nIntegration approach with existing codebase\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Implementation Guide","level":1,"id":"Implementation_Guide_0"},{"heading":"Implementation Priority Order","level":2,"id":"Implementation_Priority_Order_0"},{"heading":"Phase 1: Core Pipeline Foundation","level":3,"id":"Phase_1_Core_Pipeline_Foundation_0"},{"heading":"Phase 2: GPU Determinism Framework","level":3,"id":"Phase_2_GPU_Determinism_Framework_0"},{"heading":"Phase 3: State Management Integration","level":3,"id":"Phase_3_State_Management_Integration_0"},{"heading":"Phase 4: Ghost Simulation System","level":3,"id":"Phase_4_Ghost_Simulation_System_0"},{"heading":"Technical Risk Assessment","level":2,"id":"Technical_Risk_Assessment_0"},{"heading":"High-Risk Components","level":3,"id":"High-Risk_Components_0"},{"heading":"Mitigation Strategies","level":3,"id":"Mitigation_Strategies_0"},{"heading":"Integration with Existing Systems","level":2,"id":"Integration_with_Existing_Systems_0"},{"heading":"Core Engine Modifications","level":3,"id":"Core_Engine_Modifications_0"},{"heading":"Physics Engine Updates","level":3,"id":"Physics_Engine_Updates_0"},{"heading":"Spell System Integration","level":3,"id":"Spell_System_Integration_0"},{"heading":"Validation and Testing Strategy","level":2,"id":"Validation_and_Testing_Strategy_0"},{"heading":"Determinism Testing","level":3,"id":"Determinism_Testing_0"},{"heading":"Multiplayer Testing","level":3,"id":"Multiplayer_Testing_0"},{"heading":"Development Guidelines","level":2,"id":"Development_Guidelines_0"},{"heading":"Code Quality Standards","level":3,"id":"Code_Quality_Standards_0"},{"heading":"Team Coordination","level":3,"id":"Team_Coordination_0"},{"heading":"Success Metrics","level":2,"id":"Success_Metrics_0"},{"heading":"Performance Targets","level":3,"id":"Performance_Targets_0"},{"heading":"Quality Targets","level":3,"id":"Quality_Targets_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/variable-timing.html","architecture/general/state-management.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/implementation-guide.html","pathToRoot":"../..","attachments":[],"createdTime":1760397001332,"modifiedTime":1760397001333,"sourceSize":7058,"sourcePath":"architecture/general/implementation-guide.md","exportPath":"architecture/general/implementation-guide.html","showInTree":true,"treeOrder":6,"backlinks":["architecture/general/general.html"],"type":"markdown"},"architecture/general/overview.html":{"title":"overview","icon":"","description":"Reaction is a real-time PvP game where players cast spells that place magical runes on a grid. These runes transform the terrain according to rule-based systems.The core technical challenge: simulate thousands of interacting tiles at 60 FPS while allowing complex spell interactions that feel responsive and fair.Performance Goal: High performance with many active tilesDeterminism: Identical inputs produce identical outputs (essential for fair PvP)Responsiveness: Spell casting feels immediate despite complex backend processingExtensibility: New spells and tile interactions can be added without engine rewritesThe system separates concerns into focused, loosely-coupled modules:Purpose: Central coordination and tile data management.Responsibilities:\nBit-packed tile storage across 4 layers (Ground, Object, Air, Rune)\nGPU texture management with ping-ponging (enables GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards) for race-condition prevention\nActive region optimization (32×32 chunks - chosen to balance GPU workgroup efficiency with memory overhead) ⚠️ NOT IMPLEMENTED: Active region optimization was decided against\nFrame execution pipeline coordination\nDependencies: WebGPU APIPurpose: GPU-accelerated player-controlled spellcasting with geometric element system.Responsibilities:\n26-element system (cube/octahedron structure) with component-level cancellation\n6-flower mana economy (individual tracking, 3-turn recharge, 2:1 conversion)\nSlot/pool casting interface (cast/load/refresh actions with universal cooldown)\nAbstract spell shapes (geometric primitives evaluated in GPU shaders)\nRune lifecycle (GPU delay counters, triggering, combination, cleanup)\nDeck building (singleton format, infinite reshuffle, minimum size 6×pools)\nCurse system (TBD)\nDependencies: Core Engine (rune layer texture), Physics Engine (force application)Processing: GPU compute shaders for shape evaluation, element combination, and rune lifecyclePurpose: GPU-accelerated tile movement and collision simulation.Responsibilities:\nFree-form movement with fixed-precision Vector2 velocities\nMass-based collision physics with momentum transfer\nCohesion forces for natural tile clustering (1.5 block radius, 5×5 neighborhood)\nMulti-pass collision resolution for deterministic results\nSub-grid positioning with integer fixed-point arithmetic\nLayer interaction physics (falling, bouncing)\nDependencies: Core Engine (texture coordination)Processing: GPU compute shaders with hardcoded physics rulesNote: Frame rate coordination approach proposed in cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">data-flow.md</a> - implementation and effectiveness TBD ⚠️ data-flow.md is outdatedPurpose: Rule-based environmental transformations.Responsibilities:\nJSON rule compilation to optimized GPU shaders\nCompetitive rule scoring and execution\nEnvironmental pattern matching (fire spreading, etc.)\nOptimization pipeline (specific implementation TBD)\nDependencies: Core Engine (texture access), Build toolchainProcessing: GPU compute shaders with compiled rulesNote: The rule compilation pipeline allows simple code generation with sophisticated optimization. Alternative approaches welcome if simpler.Purpose: Visual display and user interface.Responsibilities:\nMulti-layer world rendering\nUI elements (mana flowers, spell hand)\nVisual effects and animations\nCamera and viewport management\nDependencies: Core Engine (tile data access)Processing: GPU rendering pipelinePurpose: Development and debugging utilities.Responsibilities:\nVisual rule editor with grid-based interface\nDebug overlays and tile inspection\nPerformance profiling and rule tracing\nAsset validation and testing tools\nDependencies: All modules (for debugging access)<br>⚠️ PROPOSED ARCHITECTURE: A Deterministic Time-Sliced Execution approach has been proposed for variable timing and multiplayer synchronization. See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">data-flow.md</a> for proposed pipeline details - implementation and validation TBD.<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\".html\" data-href=\"tile-storage\" aria-label=\"tile-storage\" data-tooltip-position=\"top\" target=\"_self\">tile-storage.md</a> for complete tile format and layer architecture details. Specific bit allocation TBD during implementation.<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/performance.html\" data-href=\"performance\" aria-label=\"performance\" data-tooltip-position=\"top\" target=\"_self\">performance.md</a> and individual system documentation for specific optimization strategies.<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"gameplay/gameplay.html\" data-href=\"gameplay\" aria-label=\"gameplay\" data-tooltip-position=\"top\" target=\"_self\">gameplay mechanics</a> for complete gameplay mechanics and customization systems.\nVisual Editor: Grid-based rule design interface\nJSON Export: Human-readable rule definitions\nCompilation: Automatic shader generation and optimization\nTesting: Live rule testing and validation\nIntegration: Hot-reload in development builds Tile Inspector: Real-time tile data examination\nRule Tracer: Understand why specific rules activated\nPerformance Overlay: Monitor frame timing and bottlenecks\nDeterminism Validation: Verify identical execution across runs\nTile Types: ~64 per layer (chosen to be comfortably under realistic limits)World Size: Fixed at initialization (no dynamic streaming)Flower Types: 6 (matching base elements)Casting Slots/Pools: Count TBD through playtesting (using 4 as example)Performance Degradation: Automated benchmarks prevent optimization regressionsRule Complexity: Visual editor prevents impossible shader compilationDeterminism: Strict execution ordering and integer-only mathematicsToolchain Stability: Containerized build environment for consistent results","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"System Architecture Overview","level":1,"id":"System_Architecture_Overview_0"},{"heading":"Purpose and Core Challenge","level":2,"id":"Purpose_and_Core_Challenge_0"},{"heading":"System Requirements","level":2,"id":"System_Requirements_0"},{"heading":"Module Architecture","level":2,"id":"Module_Architecture_0"},{"heading":"Core Engine Module","level":3,"id":"Core_Engine_Module_0"},{"heading":"Spell System Module","level":3,"id":"Spell_System_Module_0"},{"heading":"Physics Engine Module","level":3,"id":"Physics_Engine_Module_0"},{"heading":"Reaction Engine Module","level":3,"id":"Reaction_Engine_Module_0"},{"heading":"Renderer Module","level":3,"id":"Renderer_Module_0"},{"heading":"Tools Module","level":3,"id":"Tools_Module_0"},{"heading":"Data Flow Architecture","level":2,"id":"Data_Flow_Architecture_0"},{"heading":"Technical Implementation","level":2,"id":"Technical_Implementation_0"},{"heading":"Tile Storage Format","level":3,"id":"Tile_Storage_Format_0"},{"heading":"Performance Optimizations","level":3,"id":"Performance_Optimizations_0"},{"heading":"Player Customization","level":3,"id":"Player_Customization_0"},{"heading":"Development Workflow","level":2,"id":"Development_Workflow_0"},{"heading":"Rule Creation Pipeline","level":3,"id":"Rule_Creation_Pipeline_0"},{"heading":"Debugging and Analysis","level":3,"id":"Debugging_and_Analysis_0"},{"heading":"Risk Management and Constraints","level":2,"id":"Risk_Management_and_Constraints_0"},{"heading":"Technical Constraints","level":3,"id":"Technical_Constraints_0"},{"heading":"Risk Mitigation","level":3,"id":"Risk_Mitigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/data-flow.html",".html","architecture/general/performance.html","gameplay/gameplay.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/overview.html","pathToRoot":"../..","attachments":[],"createdTime":1760485950150,"modifiedTime":1760485950150,"sourceSize":6673,"sourcePath":"architecture/general/overview.md","exportPath":"architecture/general/overview.html","showInTree":true,"treeOrder":7,"backlinks":["architecture/architecture.html","architecture/general/general.html","development/getting-started.html","index.html"],"type":"markdown"},"architecture/general/performance.html":{"title":"performance","icon":"","description":"Optimization approaches and technical constraints for tile processing performance.⚠️ NEEDS DISCUSSION: Specific performance targets and constraints have not been established yet.General Goals:\nSupport many active tiles simultaneously\nPerformance should scale reasonably with world activity\n⚠️ NOT IMPLEMENTED: Active region optimization was decided against - implementation deemed too complex for expected benefit. Team is planning for relatively few dormant areas instead.Purpose: Avoid processing static regions to maintain performance.~~Implementation:\nDivide world into 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)\nTrack chunks with active tiles in GPU buffer\nShaders only process listed active chunks\nActivity propagates to neighboring chunks automatically\nDormant regions have minimal GPU cost~~\n~~Benefits:\nAutomatic scaling with activity level\nEfficient memory bandwidth usage\nReduced compute shader dispatches~~\nGPU Cache Optimization: Leverage 2D data access patterns for efficient memory readsBit-Packing: 32-bit tiles maximize cache line utilization\nTile Type (~6 bits): 64 possible types per layer\nVelocity (16 bits): Movement vector for physics\nCustom Data (10 bits): Health, timers, charges, etc.\nPing-Ponging: Dual texture approach prevents read-after-write hazardsGPU Workgroup Efficiency: 32×32 chunks align with GPU architectureMemory Layout: Textures use r32uint format for optimal GPU cache performanceParallel Processing: Each GPU thread handles one tile for maximum parallelization⚠️ POTENTIAL OPTIMIZATIONS: Additional GPU techniques\nMemory Coalescing: Threads in a warp access consecutive memory addresses simultaneously for maximum bandwidth\n⚠️ GUIDELINE: Minimize divergent branching\nStructure algorithms so threads in the same warp follow similar execution paths\nWhen early exits are necessary, group similar work patterns together to reduce warp divergence\nTile Types: ~64 per layer (chosen to be comfortably under realistic limits)\nWorld Size: Fixed at initialization (no dynamic streaming)\nMana Types: 8 maximum (player state buffer constraint)\nSpell Hand: Size TBD based on UI and gameplay needs⚠️ NEEDS DISCUSSION: Specific performance characteristics to be determined through testing\n32×32 chunks chosen to balance GPU workgroup efficiency with memory overhead\nGPU texture cache considerations\nParallel processing efficiency targets\n⚠️ SUGGESTION: Potential optimization techniques for rule compilation:\nCompile-time specialization for specific use cases\nDead code elimination for unused rule paths\nConstant folding for pre-computed values\nLoop unrolling for neighbor checks\nShader Generation: Move complex rule logic to build time\nAsset Optimization: Texture and mesh preprocessing\n⚠️ NEEDS DESIGN: Specific optimization pipeline implementation⚠️ SUGGESTION: Potential monitoring and validation approaches:\nAutomated benchmarks to prevent regressions\nFrame timing and bottleneck profiling\nDeterminism validation across runs\n⚠️ Major Unsolved Issues:\nFrame rate coordination between different systems\nGPU thread execution order determinism\nMemory bandwidth optimization across modules\n⚠️ SUGGESTION: Potential profiling capabilities to develop:\nFrame timing monitoring for pipeline stages\nGPU utilization tracking\nMemory bandwidth analysis\nActive region processing visualization\n⚠️ SUGGESTION: Potential debugging tools:\nTile inspector for real-time data examination\nRule tracer for activation analysis\nDeterminism validation tools\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Performance Strategy","level":1,"id":"Performance_Strategy_0"},{"heading":"Performance Requirements","level":2,"id":"Performance_Requirements_0"},{"heading":"Optimization Systems","level":2,"id":"Optimization_Systems_0"},{"heading":"<del>Active Region System</del> (NOT IMPLEMENTED)","level":3,"id":"~~Active_Region_System~~_(NOT_IMPLEMENTED)_0"},{"heading":"Texture-Based Storage","level":3,"id":"Texture-Based_Storage_0"},{"heading":"Chunk-Based Processing","level":3,"id":"Chunk-Based_Processing_0"},{"heading":"Shader Design Principles","level":3,"id":"Shader_Design_Principles_0"},{"heading":"Technical Constraints","level":2,"id":"Technical_Constraints_0"},{"heading":"Hard Limits","level":3,"id":"Hard_Limits_0"},{"heading":"Performance Scaling","level":3,"id":"Performance_Scaling_0"},{"heading":"Offline Optimizations","level":2,"id":"Offline_Optimizations_0"},{"heading":"Rule Compilation Approach","level":3,"id":"Rule_Compilation_Approach_0"},{"heading":"Build-Time Processing","level":3,"id":"Build-Time_Processing_0"},{"heading":"Risk Management","level":2,"id":"Risk_Management_0"},{"heading":"Performance Monitoring","level":3,"id":"Performance_Monitoring_0"},{"heading":"Bottleneck Identification","level":3,"id":"Bottleneck_Identification_0"},{"heading":"Monitoring and Debugging","level":2,"id":"Monitoring_and_Debugging_0"},{"heading":"Performance Profiling","level":3,"id":"Performance_Profiling_0"},{"heading":"Debug Capabilities","level":3,"id":"Debug_Capabilities_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/general/performance.html","pathToRoot":"../..","attachments":[],"createdTime":1760397321210,"modifiedTime":1760397321210,"sourceSize":4629,"sourcePath":"architecture/general/performance.md","exportPath":"architecture/general/performance.html","showInTree":true,"treeOrder":8,"backlinks":["architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/overview.html"],"type":"markdown"},"architecture/general/state-management.html":{"title":"state-management","icon":"","description":"⚠️ PROPOSED SYSTEM: This document describes the proposed unified state management approach that serves both single-player gameplay and multiplayer networking requirements through a single pipeline.Core Concept: Use identical state management for single-player, multiplayer client prediction, and multiplayer server authority.Benefits:\nConsistent behavior across all game modes\nSimplified testing and debugging\nReduced code duplication\nNatural multiplayer upgrade path Frame-based snapshots for rollback and networking\nDeterministic state serialization for cross-platform consistency Efficient delta compression for multiplayer bandwidth optimization\nRollback recovery for client prediction correction\nFrequency: Every frame (60 FPS) for complete state history.Retention: 300 snapshots (5 seconds) in circular buffer for rollback window.Compression: Incremental snapshots with delta compression for memory efficiency.interface GameStateSnapshot { frameNumber: number; timestamp: number; // Core game data tileData: CompressedTileData; playerStates: PlayerStateData[]; activeChunks: ChunkId[]; // Timing system state timeSliceState: TimeSliceSchedulerState; manaRechargeState: ManaSchedulerState; // Validation checksum: string; // Compression metadata deltaBaseFrame?: number; compressionLevel: 'full' | 'delta' | 'minimal';\n} class StateSnapshotManager { private snapshots = new CircularBuffer&lt;GameStateSnapshot&gt;(300); private deltaCompressor = new DeltaCompressor(); saveFrameState(frameNumber: number, gameState: GameState): void { const snapshot = this.createSnapshot(frameNumber, gameState); this.snapshots.push(snapshot); // Clean up old snapshots beyond retention window this.cleanupOldSnapshots(); } private createSnapshot(frameNumber: number, state: GameState): GameStateSnapshot { // Determine compression strategy const useFullSnapshot = frameNumber % 60 === 0; // Every second const compressionLevel = useFullSnapshot ? 'full' : 'delta'; return { frameNumber, timestamp: performance.now(), tileData: this.compressTileData(state.tiles, compressionLevel), playerStates: this.serializePlayerStates(state.players), activeChunks: Array.from(state.activeChunks), timeSliceState: state.scheduler.serialize(), manaRechargeState: state.manaScheduler.serialize(), checksum: this.calculateChecksum(state), deltaBaseFrame: useFullSnapshot ? undefined : frameNumber - 1, compressionLevel }; }\n}\nMultiplayer Misprediction: Server state differs from client prediction.Determinism Failure: Checksum mismatch in single-player determinism testing.Network Recovery: Client needs to resynchronize with server.class RollbackManager { async rollbackToFrame(targetFrame: number): Promise&lt;boolean&gt; { // Find target snapshot const snapshot = this.snapshotManager.getSnapshot(targetFrame); if (!snapshot) { console.error(`Cannot rollback: snapshot ${targetFrame} not found`); return false; } // Restore game state await this.restoreGameState(snapshot); // Re-execute frames from rollback point to current const currentFrame = this.gameEngine.getCurrentFrame(); for (let frame = targetFrame + 1; frame &lt;= currentFrame; frame++) { await this.replayFrame(frame); } return true; } private async restoreGameState(snapshot: GameStateSnapshot): Promise&lt;void&gt; { // Restore tile data await this.tileManager.restoreFromSnapshot(snapshot.tileData); // Restore player states this.playerManager.restoreFromSnapshot(snapshot.playerStates); // Restore timing system state this.scheduler.deserialize(snapshot.timeSliceState); this.manaScheduler.deserialize(snapshot.manaRechargeState); // Validate restoration const restoredChecksum = this.calculateChecksum(this.gameState); if (restoredChecksum !== snapshot.checksum) { throw new Error('State restoration checksum mismatch'); } }\n}\nLocal Simulation: Run complete game simulation locally for responsiveness.Server Validation: Compare local state with authoritative server updates.Automatic Correction: Rollback and re-execute when server state differs.class ClientPredictionManager { private pendingInputs = new Map&lt;number, PlayerInput[]&gt;(); private serverStates = new Map&lt;number, GameStateSnapshot&gt;(); processServerUpdate(serverSnapshot: GameStateSnapshot): void { const frameNumber = serverSnapshot.frameNumber; this.serverStates.set(frameNumber, serverSnapshot); // Compare with local prediction const localSnapshot = this.snapshotManager.getSnapshot(frameNumber); if (localSnapshot &amp;&amp; !this.statesMatch(localSnapshot, serverSnapshot)) { console.log(`Misprediction detected at frame ${frameNumber}, rolling back`); this.rollbackManager.rollbackToFrame(frameNumber); } // Confirm inputs up to this frame this.confirmInputsUpToFrame(frameNumber); } private statesMatch(local: GameStateSnapshot, server: GameStateSnapshot): boolean { // Compare essential game state (ignore client-only data) return ( local.checksum === server.checksum &amp;&amp; this.tileDataMatches(local.tileData, server.tileData) &amp;&amp; this.playerStatesMatch(local.playerStates, server.playerStates) ); }\n}\nAuthoritative Simulation: Server runs definitive game simulation.Input Validation: Validate all client inputs before application.State Broadcasting: Send compressed state updates to all clients.class ServerAuthorityManager { private connectedClients = new Set&lt;ClientConnection&gt;(); processFrame(): void { // Standard game processing this.gameEngine.processFrame(); // Generate state delta for clients const currentFrame = this.gameEngine.getCurrentFrame(); const stateDelta = this.generateStateDelta(currentFrame); // Broadcast to all clients this.broadcastStateDelta(stateDelta); } private generateStateDelta(frameNumber: number): StateDelta { const currentSnapshot = this.snapshotManager.getSnapshot(frameNumber); const previousSnapshot = this.snapshotManager.getSnapshot(frameNumber - 1); return this.deltaCompressor.createDelta(previousSnapshot, currentSnapshot); }\n}\nChange Detection: Only transmit modified tiles per frame.Run-Length Encoding: Compress sequences of similar changes.Spatial Compression: Group changes by active regions.class TileDeltaCompressor { compressTileChanges(oldTiles: TileData, newTiles: TileData): CompressedTileData { const changes: TileChange[] = []; // Detect changes for (let y = 0; y &lt; this.worldHeight; y++) { for (let x = 0; x &lt; this.worldWidth; x++) { const oldTile = oldTiles.getTile(x, y); const newTile = newTiles.getTile(x, y); if (oldTile !== newTile) { changes.push({ x, y, oldValue: oldTile, newValue: newTile }); } } } // Apply compression algorithms return this.compressChanges(changes); } private compressChanges(changes: TileChange[]): CompressedTileData { // Group by active chunks const chunkChanges = this.groupByChunk(changes); // Apply run-length encoding within chunks const compressed = chunkChanges.map(chunk =&gt; this.runLengthEncode(chunk.changes) ); return { changedChunks: compressed, compressionRatio: changes.length / compressed.length }; }\n}\nSnapshot Pooling: Reuse snapshot objects to reduce garbage collection.Lazy Compression: Compress snapshots in background thread when possible.Memory-Mapped Storage: Use efficient binary formats for large state data.Adaptive Compression: Adjust compression level based on network conditions.Priority Transmission: Send critical state changes immediately.Batch Optimization: Group small changes into larger network packets.Incremental Replay: Only re-execute affected systems during rollback.State Caching: Cache frequently accessed rollback points.Parallel Processing: Use worker threads for rollback computation when possible.Checksum Validation: Verify state integrity at snapshot creation and restoration.Cross-Reference Checking: Validate state consistency across different data structures.Automated Recovery: Attempt automatic recovery from last known good state.Connection Recovery: Seamless reconnection with state synchronization.Missing Data Recovery: Request missing snapshots from server.Graceful Degradation: Continue local simulation during temporary disconnections.class DeterminismValidator { validateStateConsistency(snapshot: GameStateSnapshot): ValidationResult { // Check internal consistency const tileConsistency = this.validateTileData(snapshot.tileData); const playerConsistency = this.validatePlayerStates(snapshot.playerStates); const timingConsistency = this.validateTimingState(snapshot.timeSliceState); // Verify checksum const calculatedChecksum = this.calculateChecksum(snapshot); const checksumValid = calculatedChecksum === snapshot.checksum; return { valid: tileConsistency &amp;&amp; playerConsistency &amp;&amp; timingConsistency &amp;&amp; checksumValid, errors: this.collectValidationErrors(), warnings: this.collectValidationWarnings() }; }\n} cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Parent pipeline architecture <br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/variable-timing.html\" data-href=\"variable-timing\" aria-label=\"variable-timing\" data-tooltip-position=\"top\" target=\"_self\">Variable Timing System</a> - Integration with time slice scheduling\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/multiplayer/multiplayer.html\" data-href=\"multiplayer\" aria-label=\"multiplayer\" data-tooltip-position=\"top\" target=\"_self\">Multiplayer System</a> - Network protocol and client prediction details\n⚠️ NEEDS TEAM DISCUSSION:\nSnapshot retention policy (current proposal: 5 seconds)\nDelta compression vs full snapshot frequency (current proposal: every 60 frames)\nRollback window limits for client prediction\n⚠️ NEEDS IMPLEMENTATION:\nPerformance benchmarking of snapshot creation overhead\nNetwork bandwidth testing with delta compression\nCross-platform determinism validation suite\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"State Management System","level":1,"id":"State_Management_System_0"},{"heading":"Unified Architecture Principle","level":2,"id":"Unified_Architecture_Principle_0"},{"heading":"Single Pipeline Design","level":3,"id":"Single_Pipeline_Design_0"},{"heading":"State Management Responsibilities","level":3,"id":"State_Management_Responsibilities_0"},{"heading":"State Snapshot System","level":2,"id":"State_Snapshot_System_0"},{"heading":"Snapshot Strategy","level":3,"id":"Snapshot_Strategy_0"},{"heading":"Rollback System","level":2,"id":"Rollback_System_0"},{"heading":"Rollback Triggers","level":3,"id":"Rollback_Triggers_0"},{"heading":"Rollback Process","level":3,"id":"Rollback_Process_0"},{"heading":"Multiplayer Integration","level":2,"id":"Multiplayer_Integration_0"},{"heading":"Client Prediction Mode","level":3,"id":"Client_Prediction_Mode_0"},{"heading":"Server Authority Mode","level":3,"id":"Server_Authority_Mode_0"},{"heading":"Delta Compression","level":2,"id":"Delta_Compression_0"},{"heading":"Tile Data Compression","level":3,"id":"Tile_Data_Compression_0"},{"heading":"Performance Optimizations","level":2,"id":"Performance_Optimizations_0"},{"heading":"Memory Management","level":3,"id":"Memory_Management_0"},{"heading":"Network Efficiency","level":3,"id":"Network_Efficiency_0"},{"heading":"Rollback Efficiency","level":3,"id":"Rollback_Efficiency_0"},{"heading":"Error Handling and Recovery","level":2,"id":"Error_Handling_and_Recovery_0"},{"heading":"State Corruption Detection","level":3,"id":"State_Corruption_Detection_0"},{"heading":"Network Failure Handling","level":3,"id":"Network_Failure_Handling_0"},{"heading":"Determinism Validation","level":3,"id":"Determinism_Validation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/variable-timing.html","architecture/systems/multiplayer/multiplayer.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/state-management.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506320,"modifiedTime":1760380506320,"sourceSize":12367,"sourcePath":"architecture/general/state-management.md","exportPath":"architecture/general/state-management.html","showInTree":true,"treeOrder":9,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html","architecture/general/implementation-guide.html","architecture/general/variable-timing.html"],"type":"markdown"},"architecture/general/technical-decisions.html":{"title":"technical-decisions","icon":"","description":"Design choices, rationale, and alternative approaches considered during Reaction v2 architecture.Decision: Separate concerns into focused, loosely-coupled modules\nRationale: Enables independent development and testing of complex systems\nAlternative Considered: Monolithic architecture - rejected for maintainability concernsDecision: WebGPU-based processing for physics, reactions, and rendering\nRationale: Required performance for thousands of interacting tiles at 60 FPS\nTrade-offs: Added complexity vs. performance requirementsSpell System: GPU compute shaders for shape evaluation, element combination, and rune lifecycle\nRationale: Consistency with physics/reaction systems, parallel evaluation, deterministic combination results\nAlternative Considered: CPU processing - rejected for performance at scale and system consistencyPhysics Engine: GPU compute shaders with hardcoded physics rules\nRationale: High parallelization needs for tile movement and collision detection\nUpdate: Physics now includes mass-based collisions with momentum transfer for realistic tile interactionsReaction Engine: GPU compute shaders with compiled rules\nRationale: Complex rule evaluation benefits from parallel processingDecision: Input → Physics → Runes → Reactions → Render\nRationale: Ensures deterministic execution and proper data dependencies\n⚠️ UNSOLVED: Timing coordination between systems at different frequenciesDecision: Simultaneous single-read/single-write GPU passes with deterministic internal rules\nRationale: Achieves determinism without complex spatial ordering or thread synchronization\nAlternatives Considered: Spatial ordering strategy - rejected for complexityDecision: 32-bit integers with packed tile data\nRationale: GPU cache efficiency and memory bandwidth optimization\n⚠️ NOTE: Specific bit allocation TBD during implementation. See <a class=\"internal-link\" data-href=\"../systems/core-engine/tile-storage.md\" href=\".html\" target=\"_self\" rel=\"noopener nofollow\">tile-storage.md</a> for current architectural approach.Decision: Ground, Object, Air, Rune layers\nRationale: Clean separation of different tile behaviors and interactions\nAlternative Considered: Single layer with type flags - rejected for complexityDecision: Dual texture approach for each layer\nRationale: Prevents GPU read-after-write hazards and race conditions\nTrade-off: Double memory usage for synchronization safetyDecision: NOT IMPLEMENTING active region optimization\nRationale: Implementation deemed too complex for expected benefit; planning for relatively few dormant areas in game design\nAlternative Sizes Considered: 32×32 tile chunks were originally proposed to balance GPU workgroup efficiency with memory overhead\nStatus: All 32×32 chunk references throughout documentation are now outdatedDecision: JSON rules → GPU shaders via offline compilation\nRationale: Move computational work to build time for runtime performance\n⚠️ NOTE: Alternative approaches may be considered during implementationDecision: 26 elements organized in cube/octahedron geometric structure\nRationale: Intuitive geometric opposition creates natural counter-play, component-level cancellation enables emergent combinations\nStructure: 6 base + 12 dual + 8 triple elements\nAlternative Considered: Smaller element set - rejected for strategic depthDecision: N slots + N pools system with three player actions (cast/load/refresh)\nRationale: Creates meaningful decisions between immediate casting and deck cycling\nTrade-offs: Refresh action uniquely prevents flower recharge (strategic cost)\nAlternative Considered: Traditional hand system - rejected for limited strategic depthDecision: Abstract geometric primitives evaluated at runtime in GPU shaders\nRationale: Perfect rotational symmetry, minimal memory, flexible design\nAlternative Considered: Pre-rendered texture system - rejected for memory cost and symmetry concernsDecision: Singleton format (no duplicates) with infinite reshuffle\nRationale: Encourages spell variety, prevents deck depletion strategies\nMinimum Size: 6 × number of pools ensures sufficient variety\nAlternative Considered: Duplicate limits with deck depletion - rejected for complexityDecision: 6 flower types matching base elements with 3-turn recharge cycle\nRationale: Direct correspondence with element system, individual tracking enables strategic timing\nDefault Allocation: 3 of each type (18 total), unlimited regeneration\nAlternative Considered: 4-element system (fire/water/earth/air) - rejected for misalignment with element structureDecision: 2:1 flower conversion ratio during deck building\nRationale: Enables element specialization at meaningful cost (total capacity reduction)\nAlternative Considered: No conversion - rejected for limited deck customizationDecision: ~64 tile types per layer\nRationale: Chosen to be comfortably under realistic GPU and memory limits\nConstraint: Leaves room for expansion without architectural changesDecision: Identical inputs must produce identical outputs\nRationale: Essential for fair PvP gameplay\nImplementation: Integer-only mathematics, simultaneous single-read/single-write GPU passes with deterministic internal rules\n⚠️ CHALLENGE: GPU thread execution order is not inherently deterministic - Addressed through simultaneous read/write pass architectureDecision: Fixed world size at initialization\nRationale: Avoids dynamic streaming complexity\nTrade-off: Limits map variety for implementation simplicityDecision: Grid-based rule design interface planned\nRationale: Simplifies rule creation and prevents impossible shader compilation\nStatus: Design planned, implementation TBDDecision: Use containerized build for consistent results\nRationale: Ensures deterministic shader compilation across development environments\n⚠️ STATUS: Implementation approach needs specification⚠️ Major Design Decisions Still Needed: Frame Rate Coordination: How to handle different update frequencies between physics (60 FPS) and reactions (potentially lower)? Rule Compilation Pipeline: Exact toolchain and optimization steps? World Size Limits: Performance testing needed to determine optimal map dimensions? Build System Integration: How rule compilation integrates with main build process? Spell System TBD: Number of Casting Slots/Pools: Using 4 as example, optimal count requires playtesting Spell Shape Primitives: Which geometric primitives to support for spell design Void Rune Effects: Powerful secret mechanic effects need design Single Element Rune Effects: Beyond mana recharge, additional effects TBD Curse System Implementation: Mechanics, stacking rules, balancing approach Spell Acquisition System: How players unlock/collect spells ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Technical Decisions","level":1,"id":"Technical_Decisions_0"},{"heading":"Core Architecture Decisions","level":2,"id":"Core_Architecture_Decisions_0"},{"heading":"Modular Design Choice","level":3,"id":"Modular_Design_Choice_0"},{"heading":"WebGPU Selection","level":3,"id":"WebGPU_Selection_0"},{"heading":"Processing Model Decisions","level":2,"id":"Processing_Model_Decisions_0"},{"heading":"CPU Vs GPU Assignment","level":3,"id":"CPU_Vs_GPU_Assignment_0"},{"heading":"Frame Pipeline Order","level":3,"id":"Frame_Pipeline_Order_0"},{"heading":"Determinism Approach","level":3,"id":"Determinism_Approach_0"},{"heading":"Data Storage Decisions","level":2,"id":"Data_Storage_Decisions_0"},{"heading":"Bit-Packed Tile Format","level":3,"id":"Bit-Packed_Tile_Format_0"},{"heading":"Four-Layer Architecture","level":3,"id":"Four-Layer_Architecture_0"},{"heading":"Texture Ping-Ponging","level":3,"id":"Texture_Ping-Ponging_0"},{"heading":"Optimization Decisions","level":2,"id":"Optimization_Decisions_0"},{"heading":"Active Region System","level":3,"id":"Active_Region_System_0"},{"heading":"Rule Compilation Strategy","level":3,"id":"Rule_Compilation_Strategy_0"},{"heading":"Spell System Decisions","level":2,"id":"Spell_System_Decisions_0"},{"heading":"Element System Design","level":3,"id":"Element_System_Design_0"},{"heading":"Slot/Pool Casting Interface","level":3,"id":"Slot/Pool_Casting_Interface_0"},{"heading":"Spell Shape Representation","level":3,"id":"Spell_Shape_Representation_0"},{"heading":"Deck Building Format","level":3,"id":"Deck_Building_Format_0"},{"heading":"Resource Management Decisions","level":2,"id":"Resource_Management_Decisions_0"},{"heading":"Mana Flower Economy","level":3,"id":"Mana_Flower_Economy_0"},{"heading":"Tile Type Limits","level":3,"id":"Tile_Type_Limits_0"},{"heading":"Performance Constraint Decisions","level":2,"id":"Performance_Constraint_Decisions_0"},{"heading":"Determinism Requirements","level":3,"id":"Determinism_Requirements_0"},{"heading":"World Size Constraints","level":3,"id":"World_Size_Constraints_0"},{"heading":"Development Workflow Decisions","level":2,"id":"Development_Workflow_Decisions_0"},{"heading":"Visual Rule Editor","level":3,"id":"Visual_Rule_Editor_0"},{"heading":"Containerized Build Environment","level":3,"id":"Containerized_Build_Environment_0"},{"heading":"Open Questions Requiring Further Decision","level":2,"id":"Open_Questions_Requiring_Further_Decision_0"}],"links":[".html"],"author":"","coverImageURL":"","fullURL":"architecture/general/technical-decisions.html","pathToRoot":"../..","attachments":[],"createdTime":1760485920351,"modifiedTime":1760485920351,"sourceSize":8100,"sourcePath":"architecture/general/technical-decisions.md","exportPath":"architecture/general/technical-decisions.html","showInTree":true,"treeOrder":11,"backlinks":["architecture/general/general.html"],"type":"markdown"},"architecture/general/variable-timing.html":{"title":"variable-timing","icon":"","description":"⚠️ PROPOSED SYSTEM: This document describes the proposed time slice scheduling system that enables variable player action timing while maintaining deterministic 60 FPS execution.Variable Player Speeds: Different players can have different action timing based on status effects.Fixed Mana Timing: Mana recharge remains strategically consistent regardless of player speed changes.Smooth Physics: Maintain 60 FPS physics simulation for fluid movement.Deterministic Execution: All timing decisions must be reproducible for multiplayer.Frame Duration: 16.67ms (60 FPS)\nTime Slices: 8 slices per frame\nSlice Duration: 2.08ms per sliceRationale: 8 slices provides sufficient granularity for speed effects (0.5x to 2x) while maintaining reasonable processing overhead.interface TimeSliceSchedule { // Base timing (normal speed) baseActionInterval: 8; // 8 slices = 1 action baseManaInterval: 24; // 24 slices = 3 actions // Physics runs every slice for smooth motion physicsInterval: 1; // Reactions run less frequently for performance reactionInterval: 4; // Every 4 slices\n}\nSpeed Effects: Status effects modify player action timing immediately.Calculation: newInterval = baseInterval / speedMultiplierSpeed Ranges: Slowed: 0.5x (16 slices per action)\nNormal: 1.0x (8 slices per action) Hasted: 2.0x (4 slices per action)\ninterface PlayerActionSchedule { playerId: string; currentInterval: number; // Current slices between actions nextActionSlice: number; // When next action executes queuedActions: PlayerAction[]; // 3 actions lookahead speedMultiplier: number; // Current speed effect\n} class TimeSliceScheduler { private playerSchedules = new Map&lt;string, PlayerActionSchedule&gt;(); private currentSlice = 0; // Process all scheduled actions for this slice processSlice(sliceIndex: number) { this.currentSlice = sliceIndex; // Process players in deterministic order (by ID) const sortedPlayerIds = Array.from(this.playerSchedules.keys()).sort(); for (const playerId of sortedPlayerIds) { this.processPlayerSchedule(playerId, sliceIndex); } } private processPlayerSchedule(playerId: string, slice: number) { const schedule = this.playerSchedules.get(playerId); if (schedule.nextActionSlice === slice) { // Execute queued action const action = schedule.queuedActions.shift(); this.executePlayerAction(playerId, action); // Schedule next action schedule.nextActionSlice = slice + schedule.currentInterval; // Request new action for queue this.requestNextAction(playerId); } }\n}\nIndependence: Mana timing unaffected by player speed changes.Strategic Consistency: Players can rely on consistent mana timing for tactical planning.Implementation: Separate timing system running parallel to player actions.class ManaRechargeScheduler { private readonly MANA_RECHARGE_INTERVAL = 24; // 3 base actions worth private nextRechargeSlice = 24; processSlice(sliceIndex: number) { if (sliceIndex === this.nextRechargeSlice) { this.rechargeManaFlowers(); this.nextRechargeSlice += this.MANA_RECHARGE_INTERVAL; } } private rechargeManaFlowers() { // Recharge all mana flowers regardless of player speeds for (const flower of this.getAllManaFlowers()) { flower.recharge(); } }\n}\nTiming Update: Speed effects immediately modify next action timing.Queue Preservation: Existing action queue remains valid but timing adjusts.Deterministic Application: Speed changes processed in consistent order.class StatusEffectManager { applySpeedEffect(playerId: string, newMultiplier: number) { const schedule = this.scheduler.getPlayerSchedule(playerId); const currentSlice = this.scheduler.getCurrentSlice(); // Calculate remaining time to next action const remainingSlices = schedule.nextActionSlice - currentSlice; // Apply speed change to remaining time const speedChange = newMultiplier / schedule.speedMultiplier; const newRemainingSlices = Math.ceil(remainingSlices / speedChange); // Update schedule schedule.speedMultiplier = newMultiplier; schedule.currentInterval = Math.ceil(8 / newMultiplier); // 8 = base interval schedule.nextActionSlice = currentSlice + newRemainingSlices; // Invalidate affected ghost predictions this.ghostSimulator.invalidatePlayerPredictions(playerId); }\n}\nSimultaneous Actions: When multiple players have actions scheduled for same slice, process in deterministic order (player ID).Queue Validation: Validate action legality when scheduled, not when executed.Timing Consistency: Ensure identical timing calculations across all clients and server.class SchedulingEdgeCases { // Handle sub-slice timing precision handleFractionalSlices(calculatedSlices: number): number { // Always round up to ensure actions don't execute too early return Math.ceil(calculatedSlices); } // Handle extreme speed changes clampSpeedMultiplier(multiplier: number): number { return Math.max(0.1, Math.min(10.0, multiplier)); } // Handle action queue overflow validateActionQueue(queue: PlayerAction[]): boolean { // Ensure queue never exceeds 3 actions return queue.length &lt;= 3; }\n}\nSparse Processing: Only process slices with scheduled events.Batch Operations: Group similar operations within same slice.Memory Efficiency: Use circular buffers for timing data.Consistent Frequency: Physics processes every slice for smooth motion.Interpolation: Visual interpolation between physics updates for display.State Synchronization: Ensure physics state consistency with action timing.Lookahead: Simulate 3 queued actions for each player.Timing Prediction: Account for current speed effects in predictions.Invalidation: Update predictions when speed effects change.class GhostTimingPredictor { predictActionTiming(playerId: string, actionCount: number): number[] { const schedule = this.scheduler.getPlayerSchedule(playerId); const predictions: number[] = []; let nextSlice = schedule.nextActionSlice; for (let i = 0; i &lt; actionCount; i++) { predictions.push(nextSlice); nextSlice += schedule.currentInterval; } return predictions; }\n}\nDeterminism Tests: Verify identical timing across multiple runs.Edge Case Coverage: Test extreme speed values and rapid changes.Synchronization Validation: Ensure client-server timing consistency.Slice Processing Overhead: Measure time slice processing cost.Memory Usage: Monitor scheduling data structure efficiency.Scalability: Test with varying player counts and speed effects.\ncross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/data-flow.html\" data-href=\"data-flow\" aria-label=\"data-flow\" data-tooltip-position=\"top\" target=\"_self\">Data Flow Architecture</a> - Parent pipeline architecture\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/deterministic-execution.html\" data-href=\"deterministic-execution\" aria-label=\"deterministic-execution\" data-tooltip-position=\"top\" target=\"_self\">Deterministic Execution</a> - Execution order and consistency\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/state-management.html\" data-href=\"state-management\" aria-label=\"state-management\" data-tooltip-position=\"top\" target=\"_self\">State Management</a> - Integration with state snapshots\n⚠️ NEEDS TEAM DISCUSSION:\nOptimal slice count (current proposal: 8 slices per frame)\nSpeed multiplier ranges (current proposal: 0.1x to 10x)\nGhost prediction complexity vs performance trade-offs\n⚠️ NEEDS IMPLEMENTATION:\nDetailed performance benchmarking of time slice overhead\nIntegration testing with existing Core Engine texture management\nMultiplayer synchronization validation\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Variable Timing System","level":1,"id":"Variable_Timing_System_0"},{"heading":"Design Goals","level":2,"id":"Design_Goals_0"},{"heading":"Core Requirements","level":3,"id":"Core_Requirements_0"},{"heading":"Time Slice Architecture","level":2,"id":"Time_Slice_Architecture_0"},{"heading":"Frame Subdivision","level":3,"id":"Frame_Subdivision_0"},{"heading":"Slice Allocation Strategy","level":3,"id":"Slice_Allocation_Strategy_0"},{"heading":"Player Action Scheduling","level":2,"id":"Player_Action_Scheduling_0"},{"heading":"Speed Multiplier System","level":3,"id":"Speed_Multiplier_System_0"},{"heading":"Action Queue Management","level":3,"id":"Action_Queue_Management_0"},{"heading":"Mana Recharge System","level":2,"id":"Mana_Recharge_System_0"},{"heading":"Fixed Timing Strategy","level":3,"id":"Fixed_Timing_Strategy_0"},{"heading":"Status Effect Integration","level":2,"id":"Status_Effect_Integration_0"},{"heading":"Immediate Speed Changes","level":3,"id":"Immediate_Speed_Changes_0"},{"heading":"Deterministic Scheduling","level":2,"id":"Deterministic_Scheduling_0"},{"heading":"Conflict Resolution","level":3,"id":"Conflict_Resolution_0"},{"heading":"Edge Case Handling","level":3,"id":"Edge_Case_Handling_0"},{"heading":"Performance Optimizations","level":2,"id":"Performance_Optimizations_0"},{"heading":"Scheduling Efficiency","level":3,"id":"Scheduling_Efficiency_0"},{"heading":"Integration with Physics","level":3,"id":"Integration_with_Physics_0"},{"heading":"Ghost Simulation Integration","level":2,"id":"Ghost_Simulation_Integration_0"},{"heading":"Prediction Timeline","level":3,"id":"Prediction_Timeline_0"},{"heading":"Testing and Validation","level":2,"id":"Testing_and_Validation_0"},{"heading":"Timing Accuracy","level":3,"id":"Timing_Accuracy_0"},{"heading":"Performance Benchmarks","level":3,"id":"Performance_Benchmarks_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"}],"links":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/state-management.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/variable-timing.html","pathToRoot":"../..","attachments":[],"createdTime":1760380506321,"modifiedTime":1760380506321,"sourceSize":9400,"sourcePath":"architecture/general/variable-timing.md","exportPath":"architecture/general/variable-timing.html","showInTree":true,"treeOrder":11,"backlinks":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/state-management.html"],"type":"markdown"},"architecture/systems/config/config.html":{"title":"config","icon":"","description":"Status: 🚧 Stub - This system documentation needs completionSystem for managing game configuration, settings, and runtime parameters.TODO: Add links to configuration components when implemented:\nConfiguration file formats and schemas\nRuntime configuration management\nEnvironment-specific settings\nValidation and error handling\nTODO: Document configuration system responsibilities:\nGame settings and parameters\nEnvironment configuration (dev/test/prod)\nRuntime parameter management\nConfiguration validation and defaults\nTODO: Define configuration categories:\nGame Settings: Tile limits, world parameters, gameplay constants\nPerformance Settings: GPU options, rendering quality, frame rate targets\nNetwork Settings: Server endpoints, timeout values, retry policies\nDevelopment Settings: Debug flags, logging levels, profiling options\nTODO: Add implementation details:\nConfiguration file loading and parsing\nHot-reloading of configuration changes\nConfiguration override hierarchy\nValidation and schema enforcement\n🚧 This file is a stub and needs completion","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Configuration System","level":1,"id":"Configuration_System_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Configuration Categories","level":2,"id":"Configuration_Categories_0"},{"heading":"Implementation Notes","level":2,"id":"Implementation_Notes_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/config/config.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506322,"modifiedTime":1760380506322,"sourceSize":1478,"sourcePath":"architecture/systems/config/config.md","exportPath":"architecture/systems/config/config.html","showInTree":true,"treeOrder":14,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/gpu/gpu.html":{"title":"gpu","icon":"","description":"Shared WebGPU resource management and coordination for all GPU-accelerated systems.The GPU Manager System manages the WebGPU instance, device initialization, and resource sharing across all systems that require GPU computation or rendering.Key Challenge: Coordinate GPU resource usage across multiple systems (Physics, Reactions, Renderer) while maintaining performance and preventing resource conflicts.\nWebGPU device initialization and capability detection\nGPU resource allocation and memory management\nCompute pipeline coordination between systems\nError handling and recovery for GPU operations\nPerformance monitoring and resource utilization tracking WebGPU Device: Single device instance shared across all systems\nBuffer Pools: Reusable buffer allocation for different data types\nTexture Management: Coordinate texture creation and lifecycle\nCompute Queue: Prioritized command queue for GPU operations Physics System: Provides compute shaders for collision and movement\nReactions System: Manages rule compilation and execution shaders Renderer: Coordinates rendering pipeline and display\nCore System: Integrates with texture ping-ponging and memory management Automatic Fallback: Handle WebGPU unavailability gracefully\nCapability Detection: Query and adapt to GPU limitations\nError Recovery: Robust handling of GPU context loss\nPerformance Profiling: Built-in GPU timing and resource monitoring Allocation Tracking: Monitor buffer and texture usage across systems\nMemory Optimization: Efficient sharing and reuse of GPU resources\nPriority Management: Coordinate competing GPU workloads\nSynchronization: Ensure proper ordering of GPU operations Device Setup: Initialize WebGPU device with required features\nSystem Registration: Allow systems to register their GPU requirements\nResource Allocation: Provide standardized buffer/texture allocation Command Submission: Centralized GPU command queue management\nResource Sharing: Safe sharing of buffers and textures between systems\nPerformance Monitoring: Real-time GPU utilization reporting WebGPU API: Required for all GPU operations\nBrowser/Platform: WebGPU support and capabilities\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"GPU Manager System","level":1,"id":"GPU_Manager_System_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Core Responsibilities","level":2,"id":"Core_Responsibilities_0"},{"heading":"Resource Management","level":2,"id":"Resource_Management_0"},{"heading":"Shared Resources","level":3,"id":"Shared_Resources_0"},{"heading":"System Integration","level":3,"id":"System_Integration_0"},{"heading":"Technical Features","level":2,"id":"Technical_Features_0"},{"heading":"Device Management","level":3,"id":"Device_Management_0"},{"heading":"Resource Coordination","level":3,"id":"Resource_Coordination_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Initialization Interface","level":3,"id":"Initialization_Interface_0"},{"heading":"Runtime Interface","level":3,"id":"Runtime_Interface_0"},{"heading":"Dependencies","level":2,"id":"Dependencies_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/gpu/gpu.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506324,"modifiedTime":1760389062751,"sourceSize":2654,"sourcePath":"architecture/systems/gpu/gpu.md","exportPath":"architecture/systems/gpu/gpu.html","showInTree":true,"treeOrder":22,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/multiplayer/deployment.html":{"title":"deployment","icon":"","description":"Container orchestration, regional deployment, and horizontal scaling infrastructure for multiplayer servers.Docker Configuration:\nNVIDIA Docker runtime for GPU support\nUbuntu base image with WebGPU drivers\nNode.js runtime with GPU-accelerated libraries\nMinimal attack surface with only required packages\nContainer Specifications:FROM nvidia/ubuntu:22.04\nRUN apt-get update &amp;&amp; apt-get install -y \\ nodejs npm \\ nvidia-driver-525 \\ vulkan-utils\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY dist/ ./dist/\nEXPOSE 8080\nCMD [\"node\", \"dist/server.js\"]\nResource Requirements:\n4 vCPU cores per game server instance\n16GB RAM per server (supports 8-12 concurrent games)\nNVIDIA T4 or equivalent GPU (4GB VRAM minimum)\n1Gbps network interface\nKubernetes Deployment:\nPod scheduling with GPU node affinity\nHorizontal Pod Autoscaler based on CPU/GPU utilization\nService mesh for inter-service communication\nConfigMap and Secret management for configuration\nAlternative: Docker Swarm:\nSimpler orchestration for smaller deployments\nBuilt-in load balancing and service discovery\nGPU resource constraints and placement\nRolling updates with zero-downtime deployment\nPrimary Regions:\nNorth America (East/West Coast)\nEurope (Frankfurt, London)\nAsia-Pacific (Singapore, Tokyo)\nOptional: South America, Australia\nRegion Selection Criteria:\nPlayer population density\nNetwork infrastructure quality\nData sovereignty requirements\nCost optimization opportunities\nMatchmaking Service:\nGlobal player queue management\nRegion assignment based on latency\nCross-region backup for peak times\nLoad balancing across regional clusters\nData Synchronization:\nPlayer profiles and statistics\nMatch history and replay data\nConfiguration and rule updates\nSecurity blacklists and ban information\nAuto-Scaling Configuration:apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata: name: game-server-hpa\nspec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: game-server minReplicas: 3 maxReplicas: 50 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 - type: Resource resource: name: nvidia.com/gpu target: type: Utilization averageUtilization: 80\nScaling Triggers:\nCPU utilization &gt;70%\nGPU utilization &gt;80%\nMemory usage &gt;85%\nQueue length &gt;100 waiting players\nAverage response time &gt;100ms\nResource Optimization:\nGPU memory pooling across game instances\nCPU allocation based on actual usage patterns\nMemory tuning for garbage collection optimization\nNetwork bandwidth allocation per game\nPerformance Monitoring:\nReal-time resource utilization tracking\nApplication performance monitoring (APM)\nCustom metrics for game-specific performance\nAlerting for performance degradation\nCore Services:interface ServiceArchitecture { gameServer: GameServerService; // Game simulation and state matchmaker: MatchmakingService; // Player matching and queuing authentication: AuthService; // Player authentication statistics: StatsService; // Match history and analytics configuration: ConfigService; // Game rules and settings\n}\nService Communication:\ngRPC for internal service communication\nRedis for shared state and caching\nMessage queues for asynchronous processing\nService mesh for secure inter-service communication\nApplication Load Balancer:\nSession affinity for WebSocket connections\nHealth check integration with Kubernetes\nGeographic routing for optimal latency\nSSL termination and certificate management\nGame Server Load Balancing:\nConsistent hashing for player assignment\nCapacity-based routing\nFailover to backup servers\nGraceful shutdown with player migration\nGame State: Redis cluster for real-time state\nPlayer Data: PostgreSQL for persistent player information\nAnalytics: ClickHouse for match statistics and telemetry\nConfiguration: etcd for distributed configuration managementMatch Replays:\nCompressed binary format for efficiency\nObject storage (S3/GCS) for long-term archival\nCDN distribution for replay downloads\nRetention policy with automatic cleanup\nPlayer Profiles:\nDistributed across regions for performance\nEventual consistency for non-critical data\nBackup and disaster recovery procedures\nGDPR compliance for data deletion\nBuild Pipeline:\nSource code compilation and TypeScript checking\nUnit and integration test execution\nDocker image building with security scanning\nImage tagging and registry push\nDeployment manifest generation\nDeployment Strategy:\nBlue-green deployment for zero-downtime updates\nCanary releases for gradual rollout\nFeature flags for controlled feature releases\nAutomated rollback on deployment failures\nDevelopment Environment:\nSingle-region deployment with minimal resources\nMock services for external dependencies\nDebug logging and development tools\nRapid iteration and testing capabilities\nStaging Environment:\nProduction-like configuration with reduced scale\nFull integration testing\nPerformance and load testing\nSecurity vulnerability scanning\nProduction Environment:\nMulti-region deployment with full redundancy\nComprehensive monitoring and alerting\nSecurity hardening and compliance\nDisaster recovery procedures\nSystem Metrics:\nCPU, memory, GPU utilization per node\nNetwork throughput and latency\nDisk I/O and storage utilization\nContainer resource consumption\nApplication Metrics:\nGame server response times\nPlayer connection counts\nMatch completion rates\nError rates and exceptions\nCritical Alerts:\nService downtime or unreachability\nHigh error rates (&gt;5% of requests)\nResource exhaustion warnings\nSecurity incident detection\nPerformance Alerts:\nLatency degradation (&gt;100ms p95)\nGPU utilization spikes (&gt;90%)\nMemory pressure warnings\nNetwork congestion detection\nCentralized Logging:\nELK Stack (Elasticsearch, Logstash, Kibana) or equivalent\nStructured logging with correlation IDs\nLog aggregation from all services\nLong-term log retention for compliance\nSecurity Logging:\nAuthentication and authorization events\nSuspicious activity detection\nSecurity incident correlation\nAudit trail for compliance requirements\nData Backup:\nAutomated database backups with point-in-time recovery\nGame state snapshots for active matches\nConfiguration backup and version control\nCross-region replication for critical data\nRecovery Procedures:\nRecovery Time Objective (RTO): 15 minutes\nRecovery Point Objective (RPO): 5 minutes\nAutomated failover for database services\nManual intervention procedures for complex failures\nService Redundancy:\nMulti-region deployment with active-active configuration\nAutomatic traffic rerouting during outages\nGraceful degradation during partial failures\nCommunication plan for extended outages\nThis deployment architecture provides scalable, reliable multiplayer infrastructure capable of supporting global competitive gameplay with minimal latency and maximum uptime.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Deployment Architecture","level":1,"id":"Deployment_Architecture_0"},{"heading":"Infrastructure Overview","level":2,"id":"Infrastructure_Overview_0"},{"heading":"Container Strategy","level":3,"id":"Container_Strategy_0"},{"heading":"Orchestration Platform","level":3,"id":"Orchestration_Platform_0"},{"heading":"Regional Architecture","level":2,"id":"Regional_Architecture_0"},{"heading":"Global Distribution","level":3,"id":"Global_Distribution_0"},{"heading":"Cross-Region Coordination","level":3,"id":"Cross-Region_Coordination_0"},{"heading":"Scaling Strategy","level":2,"id":"Scaling_Strategy_0"},{"heading":"Horizontal Scaling","level":3,"id":"Horizontal_Scaling_0"},{"heading":"Vertical Scaling","level":3,"id":"Vertical_Scaling_0"},{"heading":"Service Architecture","level":2,"id":"Service_Architecture_0"},{"heading":"Microservices Design","level":3,"id":"Microservices_Design_0"},{"heading":"Load Balancing","level":3,"id":"Load_Balancing_0"},{"heading":"Database Architecture","level":2,"id":"Database_Architecture_0"},{"heading":"Data Storage Strategy","level":3,"id":"Data_Storage_Strategy_0"},{"heading":"Data Persistence","level":3,"id":"Data_Persistence_0"},{"heading":"Deployment Pipeline","level":2,"id":"Deployment_Pipeline_0"},{"heading":"CI/CD Strategy","level":3,"id":"CI/CD_Strategy_0"},{"heading":"Environment Management","level":3,"id":"Environment_Management_0"},{"heading":"Monitoring and Alerting","level":2,"id":"Monitoring_and_Alerting_0"},{"heading":"Infrastructure Monitoring","level":3,"id":"Infrastructure_Monitoring_0"},{"heading":"Alerting Strategy","level":3,"id":"Alerting_Strategy_0"},{"heading":"Log Management","level":3,"id":"Log_Management_0"},{"heading":"Disaster Recovery","level":2,"id":"Disaster_Recovery_0"},{"heading":"Backup Strategy","level":3,"id":"Backup_Strategy_0"},{"heading":"Business Continuity","level":3,"id":"Business_Continuity_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/deployment.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506325,"modifiedTime":1760380506325,"sourceSize":8009,"sourcePath":"architecture/systems/multiplayer/deployment.md","exportPath":"architecture/systems/multiplayer/deployment.html","showInTree":true,"treeOrder":25,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/multiplayer/multiplayer.html":{"title":"multiplayer","icon":"","description":"Real-time PvP multiplayer architecture using authoritative servers with client-side prediction.The multiplayer system leverages Reaction's deterministic engine design to enable competitive real-time gameplay. An authoritative server runs the identical simulation while clients predict local actions to maintain responsive gameplay.Authoritative game simulation with GPU-accelerated processing identical to client engine.Local state prediction with rollback mechanisms for responsive gameplay despite network latency.WebSocket-based communication with optimized state synchronization and delta compression.Bandwidth optimization, server scaling, and latency management strategies.Input validation, state integrity, and cheat detection systems.Container orchestration, regional deployment, and horizontal scaling infrastructure.Core Engine Integration\nServer runs headless version of identical simulation\nLeverages existing GPU compute shaders for physics and reactions\nUses bit-packed tile format for efficient network transmission\nDeterministic Design Benefits\nInteger-only mathematics ensures identical client/server results\nSimultaneous read/write GPU passes enable reliable rollback mechanisms\nActive region system scales network bandwidth with activity level ⚠️ Active regions not implemented: Network optimization uses other strategies\nWebGPU Compatibility\nServer requires GPU-capable infrastructure\nCompute shaders run identically on both client and server\nTexture ping-ponging system adapted for network synchronization Core Networking: WebSocket protocol and basic state synchronization\nServer Engine: Headless game engine with GPU compute capabilities\nClient Prediction: Local state management with rollback\nPerformance: Bandwidth compression and server scaling\nSecurity: Anti-cheat and input validation systems\nServer Infrastructure\nGPU-capable servers (NVIDIA T4 or equivalent)\nWebGPU-compatible Node.js environment\n16GB RAM per game instance (4-8 players)\nPerformance Targets\n60 FPS authoritative simulation\n&lt;50ms input processing latency\n&lt;16MB bandwidth per player per minute\nSupport 100+ concurrent matches per server\nThis architecture provides competitive multiplayer performance while building on Reaction's existing deterministic engine design.","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Multiplayer System","level":1,"id":"Multiplayer_System_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Architecture Components","level":2,"id":"Architecture_Components_0"},{"heading":"<a class=\"internal-link\" data-href=\"server-architecture.md\" href=\"server-architecture.md\" target=\"_blank\" rel=\"noopener nofollow\">Server Architecture</a>","level":3,"id":"[Server_Architecture](server-architecture.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"client-prediction.md\" href=\"client-prediction.md\" target=\"_blank\" rel=\"noopener nofollow\">Client Prediction</a>","level":3,"id":"[Client_Prediction](client-prediction.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"network-protocol.md\" href=\"network-protocol.md\" target=\"_blank\" rel=\"noopener nofollow\">Network Protocol</a>","level":3,"id":"[Network_Protocol](network-protocol.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"performance.md\" href=\"performance.md\" target=\"_blank\" rel=\"noopener nofollow\">Performance Optimization</a>","level":3,"id":"[Performance_Optimization](performance.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"security.md\" href=\"security.md\" target=\"_blank\" rel=\"noopener nofollow\">Security &amp; Anti-Cheat</a>","level":3,"id":"[Security_&_Anti-Cheat](security.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"deployment.md\" href=\"deployment.md\" target=\"_blank\" rel=\"noopener nofollow\">Deployment Architecture</a>","level":3,"id":"[Deployment_Architecture](deployment.md)_0"},{"heading":"Integration with Core Systems","level":2,"id":"Integration_with_Core_Systems_0"},{"heading":"Development Priority","level":2,"id":"Development_Priority_0"},{"heading":"Technical Requirements","level":2,"id":"Technical_Requirements_0"}],"links":["architecture/systems/multiplayer/server-architecture.html",".html","architecture/systems/multiplayer/network-protocol.html","architecture/systems/multiplayer/performance.html","architecture/systems/multiplayer/security.html","architecture/systems/multiplayer/deployment.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/multiplayer.html","pathToRoot":"../../..","attachments":[],"createdTime":1760397290336,"modifiedTime":1760397290336,"sourceSize":3014,"sourcePath":"architecture/systems/multiplayer/multiplayer.md","exportPath":"architecture/systems/multiplayer/multiplayer.html","showInTree":true,"treeOrder":20,"backlinks":["architecture/general/state-management.html","architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/multiplayer/network-protocol.html":{"title":"network-protocol","icon":"","description":"WebSocket-based communication protocol with optimized state synchronization and delta compression.WebSocket Connection: Persistent bidirectional communication\nMessage Format: Binary protocol with structured headers\nCompression: LZ4 compression for large state updates\nReliability: Application-level acknowledgments and retransmission\nInput Messages: Client actions (spell casts, movement)\nState Updates: Server game state changes\nControl Messages: Connection management and metadata\nHeartbeat Messages: Connection health monitoring\ninterface NetworkMessage { type: MessageType; frameNumber: number; playerId: string; sequence: number; timestamp: number; checksum: number; payload: MessagePayload;\n}\ninterface SpellCastInput { spellId: number; targetX: number; targetY: number; manaType: ManaType;\n} interface MovementInput { direction: number; // 8-directional movement intensity: number; // 0-255 for analog input\n} interface SpellSelectInput { spellIndex: number; handPosition: number;\n}\ninterface TileDelta { x: number; y: number; layer: Layer; oldTile: number; // bit-packed tile data newTile: number; // bit-packed tile data\n} interface PlayerUpdate { playerId: string; positionX: number; positionY: number; health: number; manaLevels: number[]; // array of mana amounts\n} interface FullStateSnapshot { frameNumber: number; tileData: Uint32Array; // complete world state playerStates: PlayerUpdate[]; activeChunks: ChunkCoord[];\n}\nChange Detection: Only transmit modified tiles per frame\nRun-Length Encoding: Compress sequences of identical tiles\nBit-Packing Efficiency: Leverage existing 32-bit tile format\nEstimated Savings: 90% bandwidth reduction vs full state⚠️ NOT IMPLEMENTED: Active region system was decided against. Network optimization uses alternative strategies:\nSpatial Compression: Group changes by geographic proximity\nChange Detection: Only transmit modified tiles\nBandwidth Scaling: Optimized through efficient delta compression\nLZ4 Algorithm: Fast compression/decompression for real-time use\nAdaptive Compression: Skip compression for small messages\nDictionary Building: Maintain compression context across framesInput Messages: Send immediately on player action\nState Deltas: Every frame (16.67ms at 60 FPS)\nFull Snapshots: Every 60 frames (1 second) for recovery\nHeartbeat: Every 5 seconds for connection monitoringSequence Numbers: Detect missing or duplicate messages\nAcknowledgment System: Confirm receipt of critical updates\nRetransmission: Resend lost messages with exponential backoff\nRecovery Mode: Request full state snapshot on desyncCritical Updates: Player health, elimination, match state\nHigh Priority: Direct player actions and immediate consequences\nMedium Priority: Environmental changes and rule effects\nLow Priority: Cosmetic updates and distant tile changes\nClient Connection: WebSocket establishment\nAuthentication: Player credentials and session validation\nGame Joining: Match assignment and initial state transfer\nSynchronization: Frame alignment and latency measurement\nLatency Measurement: Round-trip time calculation\nBandwidth Detection: Adaptive compression and update frequency\nConnection Quality: Network stability monitoring\nFallback Modes: Reduced fidelity on poor connectionsGraceful Disconnect: Planned disconnection with state preservation\nTimeout Detection: Automatic disconnection after communication failure\nReconnection: Resume gameplay with state synchronization\nGhost Mode: Temporary AI control during brief disconnectionsTarget Bandwidth: &lt;16MB per player per minute\nPeak Optimization: Burst protection during high-activity periods\nRegional Scaling: Reduced updates for distant regions\nPredictive Filtering: Skip redundant state updatesMessage Batching: Combine multiple updates per frame\nPredictive Transmission: Send likely state changes early\nCompression Caching: Reuse compression dictionaries\nPriority Queuing: Critical messages bypass normal queue// Efficient tile delta encoding\ninterface CompressedTileDelta { chunkId: number; // 16 bits - chunk identifier relativeTiles: number; // 10 bits - tiles changed in chunk deltaData: Uint8Array; // variable length - compressed changes\n}\nInput Sanitization: Validate all client inputs against game rules\nRange Checking: Ensure coordinates and values within bounds\nRate Limiting: Prevent input flooding and spam\nChecksum Verification: Detect message corruption or tamperingMessage Signing: Cryptographic signatures for critical messages\nSequence Validation: Detect replay attacks and message injection\nTiming Verification: Validate message timestamps against server time\nState Integrity: Server-side validation of all game state changesTLS Encryption: Secure WebSocket connections (WSS)\nSession Management: Secure token-based authentication\nDoS Protection: Rate limiting and connection throttling\nIP Filtering: Geographic and reputation-based access controlThis protocol provides efficient, reliable communication optimized for Reaction's real-time gameplay requirements while maintaining competitive integrity.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Network Protocol","level":1,"id":"Network_Protocol_0"},{"heading":"Protocol Overview","level":2,"id":"Protocol_Overview_0"},{"heading":"Transport Layer","level":3,"id":"Transport_Layer_0"},{"heading":"Message Types","level":3,"id":"Message_Types_0"},{"heading":"Message Structure","level":2,"id":"Message_Structure_0"},{"heading":"Base Message Format","level":3,"id":"Base_Message_Format_0"},{"heading":"Input Message Types","level":3,"id":"Input_Message_Types_0"},{"heading":"State Update Types","level":3,"id":"State_Update_Types_0"},{"heading":"Compression Strategy","level":2,"id":"Compression_Strategy_0"},{"heading":"Tile Delta Compression","level":3,"id":"Tile_Delta_Compression_0"},{"heading":"<del>Active Region Optimization</del> (System Not Implemented)","level":3,"id":"~~Active_Region_Optimization~~_(System_Not_Implemented)_0"},{"heading":"Payload Compression","level":3,"id":"Payload_Compression_0"},{"heading":"State Synchronization","level":2,"id":"State_Synchronization_0"},{"heading":"Update Frequency","level":3,"id":"Update_Frequency_0"},{"heading":"Reliability Mechanism","level":3,"id":"Reliability_Mechanism_0"},{"heading":"Priority System","level":3,"id":"Priority_System_0"},{"heading":"Connection Management","level":2,"id":"Connection_Management_0"},{"heading":"Handshake Protocol","level":3,"id":"Handshake_Protocol_0"},{"heading":"Quality Adaptation","level":3,"id":"Quality_Adaptation_0"},{"heading":"Disconnection Handling","level":3,"id":"Disconnection_Handling_0"},{"heading":"Performance Optimization","level":2,"id":"Performance_Optimization_0"},{"heading":"Bandwidth Management","level":3,"id":"Bandwidth_Management_0"},{"heading":"Latency Optimization","level":3,"id":"Latency_Optimization_0"},{"heading":"Network Efficiency","level":3,"id":"Network_Efficiency_0"},{"heading":"Security Considerations","level":2,"id":"Security_Considerations_0"},{"heading":"Message Validation","level":3,"id":"Message_Validation_0"},{"heading":"Anti-Tampering","level":3,"id":"Anti-Tampering_0"},{"heading":"Connection Security","level":3,"id":"Connection_Security_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/network-protocol.html","pathToRoot":"../../..","attachments":[],"createdTime":1760397305658,"modifiedTime":1760397305658,"sourceSize":6298,"sourcePath":"architecture/systems/multiplayer/network-protocol.md","exportPath":"architecture/systems/multiplayer/network-protocol.html","showInTree":true,"treeOrder":21,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/multiplayer/performance.html":{"title":"performance","icon":"","description":"Bandwidth optimization, server scaling, and latency management strategies for multiplayer infrastructure.Simulation Requirements:\n60 FPS authoritative simulation per game instance\nReal-time response to player input\nSupport multiple players per game instance\nMaintain responsive gameplay experience\nScaling Goals:\nSupport multiple concurrent matches per server\nEfficient bandwidth utilization\nMinimize network latency\nHigh availability for players\nPrediction Requirements:\nMaintain smooth 60 FPS gameplay\nMinimize rollback disruptions\nLow prediction processing overhead\nSeamless visual experience during corrections\nHeadless Rendering Optimization:\nSkip visual pipeline entirely\nRetain compute shaders for physics and reactions\nOptimize GPU memory allocation for multiple instances\nImplement texture pooling across game instances\nMemory Optimization:\nPool GPU textures and buffers across instances\nShare compute pipelines between games\nOptimize memory allocation for multiple instances\nMinimize GPU memory fragmentation\nBatch Processing:\nProcess multiple game instances on single GPU context\nOptimize GPU command buffer submissions\nMinimize GPU state changes between instances\nImplement efficient GPU-CPU synchronization\nInput Processing:\nBatch input validation across multiple players\nOptimize network message deserialization\nImplement efficient player state updates\nMinimize context switching between game instances\nMemory Management:\nOptimize memory allocation patterns\nReduce garbage collection overhead\nEfficient state history management\nPool frequently used objects\nBandwidth Reduction:\nActive region delta compression (90% reduction)\nPredictive state filtering\nSpatial proximity optimization\nTemporal coherence exploitation\nLatency Reduction:\nRegional server deployment\nCDN integration for initial state\nPredictive message transmission\nConnection pooling and reuse\nInstance Management:\nStateless game servers for easy scaling\nLoad balancing based on server utilization\nDynamic instance spawning during peak hours\nGraceful shutdown and player migration\nResource Management:\nMonitor server capacity and utilization\nBalance load across available resources\nTrack GPU, memory, and network usage\nScale instances based on demand\nResource Monitoring:\nReal-time GPU utilization tracking\nMemory pressure detection and management\nCPU bottleneck identification\nNetwork bandwidth monitoring\nAdaptive Quality:\nReduce simulation fidelity under load\nDynamic update frequency adjustment\nSelective feature disabling during peaks\nGraceful degradation strategies\nRegional Deployment:\nMultiple data centers for global coverage\nPlayer assignment based on latency testing\nCross-region backup for failover\nEdge computing for input processing\nProtocol Optimization:\nUDP consideration for non-critical updates\nMessage priority queuing\nBatch transmission optimization\nConnection quality adaptation\nClient-Side Optimization:\nMinimize prediction processing overhead\nEfficient rollback state management\nOptimized visual interpolation\nPredictive input handling\nNetwork Adaptation:\nMonitor connection quality metrics\nAdjust prediction windows based on latency\nAdapt update frequencies to network conditions\nHandle packet loss gracefully\nTile Delta Compression:\nRun-length encoding for similar tiles\nBit-field optimization for tile changes\nSpatial compression for clustered updates\nTemporal compression for predictable patterns\nState Synchronization:\nDifferential state encoding\nChunk-based update grouping\nPriority-based transmission\nRedundancy elimination\nConnection Quality Detection:\nBandwidth measurement and adaptation\nQuality of service monitoring\nCongestion avoidance algorithms\nFallback mode implementation\nTraffic Shaping:\nRate limiting per connection\nBurst protection mechanisms\nPriority queuing for critical updates\nLoad balancing across connections\nServer Monitoring:\nTrack frame processing performance\nMonitor GPU and memory utilization\nMeasure network throughput and connections\nCount active game instances\nClient Monitoring:\nMeasure prediction accuracy and rollbacks\nTrack network latency and frame drops\nMonitor bandwidth consumption\nAssess user experience quality\nAutomated Analysis:\nPerformance regression detection\nCapacity planning based on usage patterns\nPredictive scaling triggers\nAnomaly detection for performance issues\nOptimization Feedback:\nA/B testing for optimization strategies\nPerformance impact measurement\nUser experience correlation\nContinuous improvement cycles\nContainer Optimization:\nMinimal Docker images for game servers\nGPU-optimized container runtime\nEfficient resource allocation\nFast startup and shutdown times\nResource Utilization:\nPack multiple game instances per server\nOptimize GPU memory sharing\nMinimize idle resource consumption\nDynamic resource allocation\nPerformance Alerts:\nLatency threshold violations\nResource utilization warnings\nCapacity planning notifications\nService degradation detection\nAutomated Responses:\nAuto-scaling based on demand\nFailover to backup servers\nLoad rebalancing during issues\nPerformance optimization triggers\nThis comprehensive performance strategy ensures smooth multiplayer gameplay while maintaining cost-effective server operations.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Performance Optimization","level":1,"id":"Performance_Optimization_0"},{"heading":"Performance Goals","level":2,"id":"Performance_Goals_0"},{"heading":"Server Performance Goals","level":3,"id":"Server_Performance_Goals_0"},{"heading":"Client Performance Goals","level":3,"id":"Client_Performance_Goals_0"},{"heading":"Server Optimization Strategies","level":2,"id":"Server_Optimization_Strategies_0"},{"heading":"GPU Resource Management","level":3,"id":"GPU_Resource_Management_0"},{"heading":"CPU Optimization","level":3,"id":"CPU_Optimization_0"},{"heading":"Network Optimization","level":3,"id":"Network_Optimization_0"},{"heading":"Scaling Architecture","level":2,"id":"Scaling_Architecture_0"},{"heading":"Horizontal Scaling","level":3,"id":"Horizontal_Scaling_0"},{"heading":"Vertical Scaling","level":3,"id":"Vertical_Scaling_0"},{"heading":"Latency Management","level":2,"id":"Latency_Management_0"},{"heading":"Network Latency Optimization","level":3,"id":"Network_Latency_Optimization_0"},{"heading":"Prediction Latency","level":3,"id":"Prediction_Latency_0"},{"heading":"Bandwidth Optimization","level":2,"id":"Bandwidth_Optimization_0"},{"heading":"Compression Strategies","level":3,"id":"Compression_Strategies_0"},{"heading":"Adaptive Bandwidth","level":3,"id":"Adaptive_Bandwidth_0"},{"heading":"Performance Monitoring","level":2,"id":"Performance_Monitoring_0"},{"heading":"Real-Time Metrics","level":3,"id":"Real-Time_Metrics_0"},{"heading":"Bottleneck Detection","level":3,"id":"Bottleneck_Detection_0"},{"heading":"Deployment Optimization","level":2,"id":"Deployment_Optimization_0"},{"heading":"Infrastructure Efficiency","level":3,"id":"Infrastructure_Efficiency_0"},{"heading":"Monitoring and Alerting","level":3,"id":"Monitoring_and_Alerting_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/performance.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506327,"modifiedTime":1760380506327,"sourceSize":6185,"sourcePath":"architecture/systems/multiplayer/performance.md","exportPath":"architecture/systems/multiplayer/performance.html","showInTree":true,"treeOrder":28,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/multiplayer/security.html":{"title":"security","icon":"","description":"Input validation, state integrity, and cheat detection systems for competitive multiplayer security.Authoritative Validation: All game-affecting decisions made on server\nInput Processing: Client inputs validated against current game state\nState Enforcement: Server never trusts client-reported game state\nDamage Calculation: All combat calculations performed server-sideAuthority Boundaries:\nServer: Health, mana, spell effects, tile transformations\nClient: UI interactions, prediction, visual effects\nValidated: Movement inputs, spell targeting, timing\nZero-Trust Client Model: Assume all client data is potentially malicious\nValidation Layers: Multiple verification stages for critical operations\nState Reconciliation: Continuous comparison of client predictions with server realityinterface InputValidation { syntaxCheck: boolean; // Message format validity rangeCheck: boolean; // Coordinate and value bounds gameRuleCheck: boolean; // Legal according to current state timingCheck: boolean; // Within expected timing windows rateCheck: boolean; // Not exceeding rate limits\n}\nMana Verification: Server tracks actual mana levels independently\nTargeting Validation: Ensure spell targets are within range and line-of-sight\nCooldown Enforcement: Server-side spell cooldown tracking\nRule Compliance: Validate spell effects against current game rulesExample Validation:function validateSpellCast(input: SpellCastInput, gameState: GameState): ValidationResult { // Check mana availability if (gameState.playerMana[input.playerId] &lt; spell.manaCost) { return { valid: false, reason: \"Insufficient mana\" }; } // Validate targeting if (!isValidTarget(input.target, gameState.playerPosition[input.playerId])) { return { valid: false, reason: \"Invalid target\" }; } // Check cooldowns if (gameState.spellCooldowns[input.playerId][input.spellId] &gt; 0) { return { valid: false, reason: \"Spell on cooldown\" }; } return { valid: true };\n}\nPosition Bounds: Ensure movement stays within world boundaries\nPhysics Constraints: Validate movement against physics simulation\nSpeed Limits: Enforce maximum movement speeds\nCollision Detection: Prevent movement through solid tilesInput Frequency: Maximum inputs per second per player\nSpell Casting Rate: Prevent rapid-fire spell casting\nConnection Limits: Maximum connections per IP address\nBandwidth Throttling: Prevent network floodingChecksum Verification: Regular state checksums between server instances\nReplay Validation: Ability to replay matches for verification\nCross-Instance Checking: Multiple servers validate critical calculations\nInteger-Only Mathematics: Prevent floating-point determinism issuesinterface StateIntegrityCheck { playerHealthSum: number; totalManaInWorld: number; tileTypeDistribution: Map&lt;TileType, number&gt;; activeRuneCount: number; frameChecksum: number;\n}\nImpossible State Detection: Identify states that violate game physics\nStatistical Analysis: Detect patterns that suggest cheating\nPerformance Anomalies: Identify suspiciously perfect play patterns\nNetwork Timing Analysis: Detect inhuman reaction timesInput Analysis:\nTiming analysis for inhuman precision\nPattern recognition for bot behavior\nStatistical analysis of success rates\nConsistency checking across sessions\nState Validation:\nImpossible game state detection\nResource tracking (mana, health)\nPosition validation and teleport detection\nDamage calculation verification\nPerformance Fingerprinting:\nHardware capability profiling\nRender timing analysis\nInput device characteristics\nSystem performance patterns\nBehavior Analysis:\nMouse movement patterns\nReaction time distributions\nDecision-making patterns\nPlay style consistency\nSpeed Hacking: Movement faster than physics allows\nTeleportation: Position changes without valid movement\nResource Manipulation: Invalid mana or health values\nInformation Cheating: Actions suggesting knowledge of hidden information\nAutomation: Bot-like behavior patterns\nNetwork Manipulation: Lag switching or packet manipulationTLS Encryption: All WebSocket connections use WSS protocol\nCertificate Validation: Proper SSL certificate verification\nSession Management: Secure token-based authentication\nIP Reputation: Block known malicious IP addressesRate Limiting: Connection and message rate limits\nGeographic Filtering: Restrict connections by region if needed\nTraffic Analysis: Detect and mitigate attack patterns\nLoad Balancing: Distribute traffic across multiple serversMessage Authentication: Cryptographic signatures for critical messages\nReplay Attack Prevention: Timestamp and sequence number validation\nMan-in-the-Middle Protection: Certificate pinning where appropriate\nSession Hijacking Prevention: Secure session token managementImmediate Actions:\nFlag suspicious activity for review\nIncrease monitoring for flagged players\nCollect evidence for manual review\nApply temporary restrictions if necessary\nInvestigation Process:\nAutomated evidence collection\nManual review by security team\nPlayer interview if needed\nFinal determination and action\nEnforcement Actions:\nWarning for minor violations\nTemporary suspension for moderate violations\nPermanent ban for severe violations\nHardware ID banning for repeat offenders\nBreach Detection: Automated monitoring for security compromises\nResponse Team: Dedicated security incident response team\nCommunication Plan: Player notification for security issues\nRecovery Procedures: Service restoration after security incidentsReplay System: Complete match recordings for investigation\nLog Aggregation: Centralized logging for security analysis\nPlayer Behavior History: Long-term behavioral pattern tracking\nSystem State Snapshots: Capture game state during suspicious eventsMinimal Data Collection: Only collect data necessary for security\nData Retention: Automatic deletion of old security logs\nPlayer Privacy: Protect personal information during investigations\nConsent Management: Clear privacy policy for security monitoringAppeals Process: Fair system for contested security actions\nEvidence Disclosure: Provide evidence for security decisions where appropriate\nPolicy Communication: Clear communication of security policies\nRegular Auditing: Third-party security audits of anti-cheat systemsThis comprehensive security framework ensures competitive integrity while maintaining player privacy and providing fair enforcement mechanisms.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Security &amp; Anti-Cheat Systems","level":1,"id":"Security_&_Anti-Cheat_Systems_0"},{"heading":"Authority Model","level":2,"id":"Authority_Model_0"},{"heading":"Server-Side Authority","level":3,"id":"Server-Side_Authority_0"},{"heading":"Trust Boundaries","level":3,"id":"Trust_Boundaries_0"},{"heading":"Input Security","level":2,"id":"Input_Security_0"},{"heading":"Input Validation Pipeline","level":3,"id":"Input_Validation_Pipeline_0"},{"heading":"Spell Cast Validation","level":3,"id":"Spell_Cast_Validation_0"},{"heading":"Movement Validation","level":3,"id":"Movement_Validation_0"},{"heading":"Rate Limiting","level":3,"id":"Rate_Limiting_0"},{"heading":"State Integrity","level":2,"id":"State_Integrity_0"},{"heading":"Determinism Validation","level":3,"id":"Determinism_Validation_0"},{"heading":"State Monitoring","level":3,"id":"State_Monitoring_0"},{"heading":"Anomaly Detection","level":3,"id":"Anomaly_Detection_0"},{"heading":"Anti-Cheat Systems","level":2,"id":"Anti-Cheat_Systems_0"},{"heading":"Server-Side Detection","level":3,"id":"Server-Side_Detection_0"},{"heading":"Client-Side Monitoring","level":3,"id":"Client-Side_Monitoring_0"},{"heading":"Cheat Detection Categories","level":3,"id":"Cheat_Detection_Categories_0"},{"heading":"Network Security","level":2,"id":"Network_Security_0"},{"heading":"Connection Security","level":3,"id":"Connection_Security_0"},{"heading":"DDoS Protection","level":3,"id":"DDoS_Protection_0"},{"heading":"Protocol Security","level":3,"id":"Protocol_Security_0"},{"heading":"Incident Response","level":2,"id":"Incident_Response_0"},{"heading":"Cheat Detection Response","level":3,"id":"Cheat_Detection_Response_0"},{"heading":"Security Incident Handling","level":3,"id":"Security_Incident_Handling_0"},{"heading":"Evidence Collection","level":3,"id":"Evidence_Collection_0"},{"heading":"Privacy and Compliance","level":2,"id":"Privacy_and_Compliance_0"},{"heading":"Data Protection","level":3,"id":"Data_Protection_0"},{"heading":"Transparency","level":3,"id":"Transparency_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/security.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506327,"modifiedTime":1760380506328,"sourceSize":7536,"sourcePath":"architecture/systems/multiplayer/security.md","exportPath":"architecture/systems/multiplayer/security.html","showInTree":true,"treeOrder":29,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/multiplayer/server-architecture.html":{"title":"server-architecture","icon":"","description":"Authoritative game server design with GPU-accelerated simulation identical to client engine.Purpose: Central coordinator for multiplayer matches.Responsibilities:\nWebSocket connection management per match\nPlayer authentication and session management\nFrame timing coordination at 60 FPS\nMatch lifecycle (creation, joining, termination)\nDependencies: NetworkManager, ServerGameEnginePurpose: Authoritative game simulation without rendering.Responsibilities:\nIdentical deterministic simulation to client engine\nGPU compute shader execution for physics and reactions\nTile storage and active region management\nState validation and integrity checking\nKey Differences from Client:\nNo rendering pipeline (headless)\nAdditional input validation layers\nState snapshot creation for rollback\nNetwork delta generation\nPurpose: Real-time communication with game clients.Responsibilities:\nWebSocket server lifecycle management\nInput message validation and deserialization\nState update broadcasting with compression\nConnection quality monitoring and adaptation Client Input Reception: WebSocket message containing player actions\nInput Validation: Verify action legality (mana costs, targeting, timing)\nState Application: Apply validated inputs to authoritative game state\nSimulation Step: Execute physics, reactions, and rule processing\nDelta Generation: Create compressed state updates for clients\n60 FPS Target: 16.67ms frame budget\nInput processing: 2ms\nSimulation execution: 12ms\nNetwork transmission: 2ms\nBuffer time: 0.67ms\nFull State Snapshots: Every 60 frames (1 second) as fallback recovery\nDelta Updates: Every frame with active region optimization\nPriority System: Critical updates (player health) sent immediately\nAcknowledgment Tracking: Ensure reliable delivery with retransmissionServer Environment: Node.js with WebGPU adapter\nGPU Requirements: NVIDIA T4 or equivalent with compute capability\nMemory Management: Shared texture pools across game instancesIdentical Logic: Same shaders as client for deterministic results\nTexture Management: Ping-pong system adapted for server environment\nActive Region Processing: Leverage existing chunk optimizationInstance Batching: Multiple games on single GPU context\nMemory Pooling: Reuse GPU resources between matches\nAdaptive Quality: Reduce simulation fidelity under high loadRoom Creation: Dynamic game instance spawning\nPlayer Assignment: Region-based server selection\nCapacity Management: Load balancing across server instances\nInitialization: GPU resource allocation and world setup\nPlayer Joining: Connection establishment and state synchronization\nActive Gameplay: 60 FPS simulation with network updates\nMatch Conclusion: Resource cleanup and statistics recording\nGPU Failures: Automatic instance migration to backup servers\nNetwork Issues: Client reconnection with state recovery\nCrash Recovery: Persistent state snapshots for match restoration\nFrame timing consistency (target: &lt;16.67ms)\nGPU utilization per instance\nMemory bandwidth consumption\nNetwork throughput per match\nCPU Bound: Input processing and network I/O optimization\nGPU Bound: Shader optimization and batch processing\nMemory Bound: Texture management and garbage collection\nNetwork Bound: Compression and prioritization improvements\nPlayer queue length\nAverage frame processing time\nGPU memory utilization\nNetwork bandwidth per server\nThis architecture provides the authoritative foundation for competitive multiplayer while leveraging Reaction's existing deterministic engine design.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Server Architecture","level":1,"id":"Server_Architecture_0"},{"heading":"Core Components","level":2,"id":"Core_Components_0"},{"heading":"GameServer Class","level":3,"id":"GameServer_Class_0"},{"heading":"ServerGameEngine","level":3,"id":"ServerGameEngine_0"},{"heading":"NetworkManager","level":3,"id":"NetworkManager_0"},{"heading":"Data Flow Architecture","level":2,"id":"Data_Flow_Architecture_0"},{"heading":"Input Processing Pipeline","level":3,"id":"Input_Processing_Pipeline_0"},{"heading":"Frame Execution Timing","level":3,"id":"Frame_Execution_Timing_0"},{"heading":"State Synchronization Strategy","level":3,"id":"State_Synchronization_Strategy_0"},{"heading":"GPU Integration","level":2,"id":"GPU_Integration_0"},{"heading":"Headless WebGPU Setup","level":3,"id":"Headless_WebGPU_Setup_0"},{"heading":"Compute Shader Execution","level":3,"id":"Compute_Shader_Execution_0"},{"heading":"Performance Scaling","level":3,"id":"Performance_Scaling_0"},{"heading":"Match Management","level":2,"id":"Match_Management_0"},{"heading":"Matchmaking Integration","level":3,"id":"Matchmaking_Integration_0"},{"heading":"Game Instance Lifecycle","level":3,"id":"Game_Instance_Lifecycle_0"},{"heading":"Error Handling","level":3,"id":"Error_Handling_0"},{"heading":"Performance Monitoring","level":2,"id":"Performance_Monitoring_0"},{"heading":"Server Metrics","level":3,"id":"Server_Metrics_0"},{"heading":"Bottleneck Detection","level":3,"id":"Bottleneck_Detection_0"},{"heading":"Scaling Indicators","level":3,"id":"Scaling_Indicators_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/multiplayer/server-architecture.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506328,"modifiedTime":1760380506329,"sourceSize":4288,"sourcePath":"architecture/systems/multiplayer/server-architecture.md","exportPath":"architecture/systems/multiplayer/server-architecture.html","showInTree":true,"treeOrder":30,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown"},"architecture/systems/physics/determinism.html":{"title":"determinism","icon":"","description":"Ensuring reproducible physics simulation for fair PvP gameplay.Identical Inputs → Identical Outputs: Essential for fair PvP gameplay\nCross-Platform Consistency: Same results across different hardware and drivers\nReplay Capability: Matches should be perfectly reproducible\nSpatial Ordering: Process tiles in strict top-left to bottom-right order\nInteger Mathematics: Fixed-point arithmetic prevents floating-point drift Cross-Platform Consistency: Identical results across GPU architectures\nValidation Framework: Automated testing for deterministic execution\nNo Floating-Point Drift: Use integer-only calculations to prevent precision accumulation\nFixed-Point Arithmetic: ⚠️ NEEDS SPECIFICATION - Specific fixed-point formats for velocity and position\nRounding Consistency: Deterministic rounding rules across all calculationsNo Shared State: Tiles don't share mutable state during processing\nAtomic Operations: Critical for marking active chunks and activity propagation\nData Races: Prevent concurrent read/write conflicts","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Determinism and Precision","level":1,"id":"Determinism_and_Precision_0"},{"heading":"Determinism Requirements","level":2,"id":"Determinism_Requirements_0"},{"heading":"Core Requirement","level":3,"id":"Core_Requirement_0"},{"heading":"Deterministic Processing Strategy","level":3,"id":"Deterministic_Processing_Strategy_0"},{"heading":"Precision Control","level":2,"id":"Precision_Control_0"},{"heading":"Integer Mathematics","level":3,"id":"Integer_Mathematics_0"},{"heading":"State Isolation","level":3,"id":"State_Isolation_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/determinism.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506329,"modifiedTime":1762477101929,"sourceSize":1285,"sourcePath":"architecture/systems/physics/determinism.md","exportPath":"architecture/systems/physics/determinism.html","showInTree":true,"treeOrder":26,"backlinks":["architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/physics.html"],"type":"markdown"},"architecture/systems/physics/forces.html":{"title":"forces","icon":"","description":"Force mechanics for collision repulsion, cohesion attraction, and spell-driven movement.Forces modify object velocities each frame, creating realistic physics interactions. All forces operate within the two-layer hexagonal neighborhood range, ensuring objects can respond before collisions become problematic.Coverage: Objects check two layers of surrounding hexagons for force interactions.Maximum Range: All forces operate within sqrt(7)d/2 - d distance limit, where d is the hex cell size.Range Guarantee: Two hex layers provide sufficient coverage for all force interactions given speed limits (~9.69 cells/second max).Efficiency: Neighbor checking limited to necessary range reduces computation.Polar Coordinates: Use polar/cube coordinate system for efficient neighbor queries.Wrapped Boundaries: Handle world wrapping when checking neighbors near edges.Layer Order: Process neighbors in consistent order for deterministic results.Overlap Resolution: Push objects apart when they overlap to prevent interpenetration.Continuous Application: Forces applied every frame while objects remain overlapping.Mass-Based Response: Force produces different accelerations based on object mass.Repulsion: Objects push apart when overlapping, with force directed away from collision point.Overlap-Based Magnitude: Force magnitude increases with overlap amount.Mass Influence: Force applied to both objects, with acceleration inversely proportional to mass (F = ma).Breaking Threshold: High overlap triggers combination mechanic instead of force (when distance &lt; d).⚠️ NEEDS SPECIFICATION: Exact collision force formula TBD through playtesting.Considerations:\nLinear vs non-linear force scaling with overlap distance\nForce strength calibration for gameplay feel\nBalance between collision response and combination trigger\nInteraction with cohesion forces\nGap Closure: Automatically close gaps between objects for natural density management.Clustering: Maintain dense object coverage without rigid grid constraints.Breaking Force: Allow high-velocity impacts to overcome cohesion and create temporary gaps.Attraction: Objects within cohesion radius pull toward each other.Density Management: Prevents permanent gaps in object field while allowing dynamic separation.Gameplay Interaction: Creates emergent behavior where objects naturally cluster unless disrupted.⚠️ NEEDS SPECIFICATION: Exact cohesion force formula and radius TBD through playtesting.Considerations:\nCohesion radius (likely smaller than two-layer range)\nForce strength relative to collision forces\nLinear vs clamped force falloff with distance\nCentroid vs pairwise attraction\nImpulse Elements: Some spell elements apply instantaneous velocity changes (impulses).Velocity-Setting Elements: Other spell elements directly set object velocities to specific values.Element Determination: Spell element type determines force application method.⚠️ NEEDS SPECIFICATION: Mapping of spell elements to force types TBD through spell system design.Buffer Lookup: Objects check spell buffer for active spell shapes.Overlap Detection: Determine which spell shapes overlap the object's center point.Multiple Spells: Objects can be affected by multiple overlapping spell shapes.Combination Order: When multiple spells overlap, combine elements by cast time order (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/spells.html\" data-href=\"spells\" aria-label=\"spells\" data-tooltip-position=\"top\" target=\"_self\">Spell System</a>).Impulse Method: Add velocity delta to current velocity (Δv applied once per spell contact).Velocity-Set Method: Directly replace velocity with spell-specified value.Mass Independence: Spell forces may ignore mass (TBD through spell design).<br>Details: See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/spells.html\" data-href=\"spells\" aria-label=\"spells\" data-tooltip-position=\"top\" target=\"_self\">Spell System</a> for spell shape mechanics and element combination rules.Force Sources: Each frame, objects accumulate forces from:\nCollision forces (from overlapping objects)\nCohesion forces (from nearby objects within radius)\nSpell forces (from overlapping spell shapes)\nSummation: Forces summed using vector addition.Velocity Update: Net force applied to update velocity: v_new = v_old + (F_total / mass) * dtPosition Update: Updated velocity used to modify sub-grid offset.Determinism: All force calculations use fixed-point arithmetic for platform-independent results.Precision: Bit precision chosen to balance accuracy and GPU texture storage.Overflow Prevention: Force magnitudes clamped to prevent fixed-point overflow.<br>Details: See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/determinism.html\" data-href=\"determinism\" aria-label=\"determinism\" data-tooltip-position=\"top\" target=\"_self\">Determinism</a> for fixed-point implementation.\nForces modify object velocities each frame\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/movement-system.html\" data-href=\"movement-system\" aria-label=\"movement-system\" data-tooltip-position=\"top\" target=\"_self\">Movement System</a> for velocity and mass details Force calculations performed in \"Apply Forces + Move\" pass\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/gpu-shaders.html\" data-href=\"gpu-shaders\" aria-label=\"gpu-shaders\" data-tooltip-position=\"top\" target=\"_self\">GPU Shaders</a> for pipeline details Spell shapes provide force input from buffer\nElement types determine force application method\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/spells.html\" data-href=\"spells\" aria-label=\"spells\" data-tooltip-position=\"top\" target=\"_self\">Spell System</a> for spell mechanics\nCollision vs Cohesion: Collision forces must overcome cohesion to allow object separation.Spell Dominance: Spell forces should be noticeable over ambient collision/cohesion forces.Combination Threshold: Objects approaching distance d should combine rather than bounce indefinitely.Playtesting Required: Force formulas will be refined through gameplay iteration.Adjustable Parameters: Force strengths and radii exposed as configuration values.Element Variation: Different spell elements may use different force strengths/types.Neighbor Limits: Two-layer range constraint keeps force calculations bounded.Parallel Computation: Force calculations fully parallelizable across objects in GPU.Early Termination: Skip force calculations for stationary objects with no nearby activity.","aliases":[],"inlineTags":[],"frontmatterTags":["#Architecture","#Implementation"],"headers":[{"heading":"Forces","level":1,"id":"Forces_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Force Range","level":2,"id":"Force_Range_0"},{"heading":"Two-Layer Hex Neighborhood","level":3,"id":"Two-Layer_Hex_Neighborhood_0"},{"heading":"Hexagonal Neighbor Lookup","level":3,"id":"Hexagonal_Neighbor_Lookup_0"},{"heading":"Collision Forces","level":2,"id":"Collision_Forces_0"},{"heading":"Purpose","level":3,"id":"Purpose_0"},{"heading":"Force Characteristics","level":3,"id":"Force_Characteristics_0"},{"heading":"Formula","level":3,"id":"Formula_0"},{"heading":"Cohesion Forces","level":2,"id":"Cohesion_Forces_0"},{"heading":"Purpose","level":3,"id":"Purpose_1"},{"heading":"Force Characteristics","level":3,"id":"Force_Characteristics_1"},{"heading":"Formula","level":3,"id":"Formula_1"},{"heading":"Spell Forces","level":2,"id":"Spell_Forces_0"},{"heading":"Element-Based Application","level":3,"id":"Element-Based_Application_0"},{"heading":"Spell Shape Overlap","level":3,"id":"Spell_Shape_Overlap_0"},{"heading":"Force Application","level":3,"id":"Force_Application_0"},{"heading":"Force Accumulation","level":2,"id":"Force_Accumulation_0"},{"heading":"Per-Frame Process","level":3,"id":"Per-Frame_Process_0"},{"heading":"Fixed-Point Arithmetic","level":3,"id":"Fixed-Point_Arithmetic_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Movement System","level":3,"id":"Movement_System_0"},{"heading":"GPU Implementation","level":3,"id":"GPU_Implementation_0"},{"heading":"Spell System","level":3,"id":"Spell_System_0"},{"heading":"Design Considerations","level":2,"id":"Design_Considerations_0"},{"heading":"Force Balance","level":3,"id":"Force_Balance_0"},{"heading":"Gameplay Tuning","level":3,"id":"Gameplay_Tuning_0"},{"heading":"Performance","level":3,"id":"Performance_0"}],"links":["architecture/systems/spells/spells.html","architecture/systems/spells/spells.html","architecture/systems/physics/determinism.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/spells/spells.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/forces.html","pathToRoot":"../../..","attachments":[],"createdTime":1762476762550,"modifiedTime":1762476762551,"sourceSize":6935,"sourcePath":"architecture/systems/physics/forces.md","exportPath":"architecture/systems/physics/forces.html","showInTree":true,"treeOrder":27,"backlinks":["architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.html"],"type":"markdown"},"architecture/systems/physics/gpu-shaders.html":{"title":"gpu-shaders","icon":"","description":"Multi-pass GPU compute pipeline for force-based physics with combination mechanics on a hexagonal grid.The physics system uses a sequence of GPU compute passes to update object positions and handle combinations:\nApply Forces + Move: Calculate and apply all forces, update velocities and sub-grid offsets\nOverlap Passes (2-N): Detect and merge objects that are too close\nSet Grid Position: Update hex cell assignments based on final offsets\nPurpose: Apply collision, cohesion, and spell forces; update velocity and sub-grid offset.Grid Position Preserved: Objects remain in their current hex cell until final pass.Neighbor Range: Check two-layer hexagonal neighborhood for force interactions.@compute @workgroup_size(8, 8)\nfn apply_forces_and_move( @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;, @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;\n) { let hex_coord = calculate_hex_coord(global_id); let object = read_object(hex_coord); if (!object.exists) { return; } // Load two-layer hex neighborhood into shared memory load_hex_neighborhood_to_cache(hex_coord, local_id); workgroupBarrier(); // Accumulate forces from neighbors var total_force = vec2&lt;i32&gt;(0, 0); // Fixed-point // Collision forces (from overlapping objects) total_force += calculate_collision_forces(object, neighborhood_cache); // Cohesion forces (from nearby objects within radius) total_force += calculate_cohesion_forces(object, neighborhood_cache); // Spell forces (from overlapping spell shapes) total_force += calculate_spell_forces(object, spell_buffer); // Update velocity (F = ma, so a = F/m) let acceleration = fixed_point_divide(total_force, object.mass); object.velocity = fixed_point_add(object.velocity, acceleration); // Clamp velocity to maximum object.velocity = clamp_velocity(object.velocity, MAX_VELOCITY); // Update sub-grid offset (don't change hex cell assignment yet) object.offset = fixed_point_add(object.offset, object.velocity); write_object(hex_coord, object);\n}\nCollision Forces: For each overlapping neighbor, calculate repulsion force based on overlap distance and mass.Cohesion Forces: For neighbors within cohesion radius, calculate attraction force toward group centroid.Spell Forces: Check spell buffer for overlapping spell shapes; apply impulses or set velocities based on element type.Details: See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/forces.html\" data-href=\"forces\" aria-label=\"forces\" data-tooltip-position=\"top\" target=\"_self\">Forces</a> for force formulas and mechanics.Purpose: Detect objects closer than combination distance d; merge them into single objects.Scatter-Gather: Complex algorithm to identify and merge groups of nearby objects.Multiple Passes: May require several passes to fully resolve cascading combinations.⚠️ NEEDS SPECIFICATION: Exact scatter-gather implementation approach TBD.@compute @workgroup_size(8, 8)\nfn overlap_detection_pass( @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;, @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;\n) { let hex_coord = calculate_hex_coord(global_id); let object = read_object(hex_coord); if (!object.exists) { return; } // Load two-layer hex neighborhood load_hex_neighborhood_to_cache(hex_coord, local_id); workgroupBarrier(); // Find all objects within combination distance d var nearby_objects = find_objects_within_distance(object, neighborhood_cache, COMBINATION_DISTANCE); if (nearby_objects.count &gt; 0) { // Mark for combination // TODO: Implement scatter-gather algorithm // - Assign combination group ID // - Calculate combined properties (mass-averaged velocity, centroid position) // - Apply reaction rules for type transformation // - Write combined object, mark merged objects for deletion }\n}\nDistance Check: Calculate distance between object centers; trigger if &lt; d.Group Formation: All objects within d of combined center merge together.Property Calculation:\nVelocity: Mass-weighted average of all merged objects\nPosition: Mass-weighted centroid\n<br>Type: Determined by reaction rules (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/reactions.html\" data-href=\"reactions\" aria-label=\"reactions\" data-tooltip-position=\"top\" target=\"_self\">Reaction System</a>)\nMass: Based on new type\nAtomic Operations: Use atomics to prevent race conditions when multiple groups overlap.Purpose: Update which hex cell each object occupies based on its final sub-grid offset.Boundary Wrapping: Handle objects that have moved across world edges.Spatial Indexing: Ensure objects are correctly indexed for next frame's neighbor queries.@compute @workgroup_size(8, 8)\nfn set_grid_position( @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;\n) { let hex_coord = calculate_hex_coord(global_id); let object = read_object(hex_coord); if (!object.exists) { return; } // Calculate new hex cell based on offset let new_hex_coord = calculate_hex_from_offset(hex_coord, object.offset); // Normalize offset relative to new cell center let normalized_offset = normalize_offset_to_cell(object.offset, new_hex_coord); // Handle world wrapping let wrapped_coord = wrap_hex_coordinate(new_hex_coord); if (wrapped_coord != hex_coord) { // Object moved to new cell - relocate it object.offset = normalized_offset; atomic_write_object(wrapped_coord, object); delete_object(hex_coord); } else { // Object stayed in same cell - just update offset object.offset = normalized_offset; write_object(hex_coord, object); }\n}\nCoordinate System: Use cube coordinates (q, r, s) where q + r + s = 0.Neighbor Lookup: Efficient neighbor calculation using coordinate offsets.Point-to-Hex: Convert Cartesian (x, y) position to hex coordinates using cube algorithm.GPU Layout: Grid stored as skewed parallelogram in texture memory.Rectangular Indexing: Standard 2D texture coordinates map to hex cells.Wrapped Boundaries: World edges wrap seamlessly for continuous circular world.Layer Definition: Objects check 19 hex cells (center + 6 immediate + 12 second-layer).Shared Memory Size: 19 objects fit efficiently in workgroup shared memory.Coordinate Calculation: Precompute neighbor offsets for each hex layer.Purpose: Load neighborhood data once per workgroup to minimize texture reads.Cache Size: 19 hex cells × object data size (position, velocity, type, mass).Synchronization: Workgroup barriers ensure all threads see cached data.// Workgroup shared memory for hex neighborhood\nvar&lt;workgroup&gt; neighborhood_cache: array&lt;ObjectData, 19&gt;;\nvar&lt;workgroup&gt; cache_loaded: bool; fn load_hex_neighborhood_to_cache( center_hex: vec2&lt;i32&gt;, local_id: vec3&lt;u32&gt;\n) { // First thread loads all 19 neighbors if (local_id.x == 0 &amp;&amp; local_id.y == 0) { for (var i = 0; i &lt; 19; i++) { let neighbor_hex = center_hex + HEX_NEIGHBOR_OFFSETS[i]; neighborhood_cache[i] = read_object(neighbor_hex); } cache_loaded = true; }\n}\nCurrent Choice: 8×8 workgroups (64 threads).Rationale: Balance between GPU occupancy and shared memory usage.⚠️ NEEDS TUNING: Optimal workgroup size TBD through GPU profiling.GPU Texture Layout:struct ObjectData { // Position (12 bytes) hex_coord: vec2&lt;i32&gt;, // 8 bytes - hex cell coordinates offset: vec2&lt;i32&gt;, // 8 bytes - fixed-point offset from cell center // Velocity (8 bytes) velocity: vec2&lt;i32&gt;, // 8 bytes - fixed-point velocity vector // Properties (8 bytes) type_id: u32, // 4 bytes - object type mass: u32, // 4 bytes - mass (or could be computed from type) // Flags (4 bytes) layer: u32, // 4 bytes - Ground/Object/Air (could be packed) exists: bool, // 1 byte - object exists flag // ... potential padding or additional flags\n}\n// Total: ~32 bytes per object (may be optimized with bit-packing)\nMemory Packing: Consider bit-packing to reduce texture memory and bandwidth.Structure: Array of active spell shapes in GPU buffer.Data Per Spell:\nShape geometry (circle, rectangle, etc.)\nPosition and radius\nElement type(s)\nCast time (for element combination ordering)\nForce magnitude/velocity value\nSpatial Partitioning: Future optimization to limit spell checks per object.Integer-Only Operations: All physics calculations use fixed-point (scaled integers).Platform Independence: Avoids floating-point precision differences across GPUs.Bit Precision: Balance accuracy vs overflow risk (e.g., 16.16 fixed-point).<br>Details: See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/determinism.html\" data-href=\"determinism\" aria-label=\"determinism\" data-tooltip-position=\"top\" target=\"_self\">Determinism</a> for implementation.// Fixed-point addition (trivial)\nfn fixed_point_add(a: vec2&lt;i32&gt;, b: vec2&lt;i32&gt;) -&gt; vec2&lt;i32&gt; { return a + b;\n} // Fixed-point multiplication (scale factor = 2^16)\nfn fixed_point_multiply(a: i32, b: i32) -&gt; i32 { return (i64(a) * i64(b)) &gt;&gt; 16;\n} // Fixed-point division\nfn fixed_point_divide(numerator: i32, denominator: i32) -&gt; i32 { return (i64(numerator) &lt;&lt; 16) / i64(denominator);\n}\nStationary Objects: Skip force calculations for objects with zero velocity and no nearby activity.Convergence Detection: In overlap passes, terminate early if no combinations triggered.Pass Skipping: Skip remaining overlap passes once no objects need merging.Coalesced Access: Threads in workgroup access contiguous memory locations.Texture Cache: Structure data layout for optimal GPU cache utilization.Bit-Packing: Compress object data to minimize texture memory bandwidth.Combination Conflicts: Use atomic operations when multiple objects try to merge.Cell Relocation: Atomic writes when moving objects to new hex cells.Flag Updates: Atomic flags for convergence detection across workgroups.\nPipeline implements movement, velocity, and combination mechanics\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/movement-system.html\" data-href=\"movement-system\" aria-label=\"movement-system\" data-tooltip-position=\"top\" target=\"_self\">Movement System</a> for conceptual details Force calculation details and formulas\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/forces.html\" data-href=\"forces\" aria-label=\"forces\" data-tooltip-position=\"top\" target=\"_self\">Forces</a> for force types and equations Spell buffer provides force input\nObjects check for overlapping spell shapes\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/spells.html\" data-href=\"spells\" aria-label=\"spells\" data-tooltip-position=\"top\" target=\"_self\">Spell System</a> for spell mechanics Combination type transformations use reaction rules\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/reactions.html\" data-href=\"reactions\" aria-label=\"reactions\" data-tooltip-position=\"top\" target=\"_self\">Reaction System</a> for transformation rules\nLanguage: WebGPU Shading Language (WGSL).Compilation: Shaders compiled at runtime by WebGPU driver.Validation: Browser provides shader compilation errors during development.Development Mode: Support shader hot-reloading for rapid iteration.Error Handling: Graceful fallback when shader compilation fails.Debugging: Use browser GPU debugging tools for shader profiling.GPU Timers: Measure individual pass execution times.Bandwidth Monitoring: Track texture read/write operations.Workgroup Tuning: Profile different workgroup sizes for optimal performance.","aliases":[],"inlineTags":[],"frontmatterTags":["#Implementation"],"headers":[{"heading":"GPU Shader Architecture","level":1,"id":"GPU_Shader_Architecture_0"},{"heading":"Pipeline Overview","level":2,"id":"Pipeline_Overview_0"},{"heading":"Pass 1: Apply Forces + Move","level":2,"id":"Pass_1_Apply_Forces_+_Move_0"},{"heading":"Overview","level":3,"id":"Overview_0"},{"heading":"Shader Structure","level":3,"id":"Shader_Structure_0"},{"heading":"Force Calculations","level":3,"id":"Force_Calculations_0"},{"heading":"Pass 2-N: Overlap Passes","level":2,"id":"Pass_2-N_Overlap_Passes_0"},{"heading":"Overview","level":3,"id":"Overview_1"},{"heading":"Shader Structure","level":3,"id":"Shader_Structure_1"},{"heading":"Combination Process","level":3,"id":"Combination_Process_0"},{"heading":"Final Pass: Set Grid Position","level":2,"id":"Final_Pass_Set_Grid_Position_0"},{"heading":"Overview","level":3,"id":"Overview_2"},{"heading":"Shader Structure","level":3,"id":"Shader_Structure_2"},{"heading":"Hexagonal Grid Algorithms","level":2,"id":"Hexagonal_Grid_Algorithms_0"},{"heading":"Polar/Cube Coordinates","level":3,"id":"Polar/Cube_Coordinates_0"},{"heading":"Skewed Parallelogram Storage","level":3,"id":"Skewed_Parallelogram_Storage_0"},{"heading":"Two-Layer Neighborhood","level":3,"id":"Two-Layer_Neighborhood_0"},{"heading":"Workgroup Architecture","level":2,"id":"Workgroup_Architecture_0"},{"heading":"Shared Memory Caching","level":3,"id":"Shared_Memory_Caching_0"},{"heading":"Workgroup Size","level":3,"id":"Workgroup_Size_0"},{"heading":"Data Structures","level":2,"id":"Data_Structures_0"},{"heading":"Object Physics Data","level":3,"id":"Object_Physics_Data_0"},{"heading":"Spell Buffer","level":3,"id":"Spell_Buffer_0"},{"heading":"Fixed-Point Arithmetic","level":2,"id":"Fixed-Point_Arithmetic_0"},{"heading":"Determinism Guarantee","level":3,"id":"Determinism_Guarantee_0"},{"heading":"Example Operations","level":3,"id":"Example_Operations_0"},{"heading":"Performance Optimizations","level":2,"id":"Performance_Optimizations_0"},{"heading":"Early Termination","level":3,"id":"Early_Termination_0"},{"heading":"Memory Bandwidth","level":3,"id":"Memory_Bandwidth_0"},{"heading":"Atomic Operations","level":3,"id":"Atomic_Operations_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Movement System","level":3,"id":"Movement_System_0"},{"heading":"Forces","level":3,"id":"Forces_0"},{"heading":"Spell System","level":3,"id":"Spell_System_0"},{"heading":"Reaction System","level":3,"id":"Reaction_System_0"},{"heading":"Shader Development","level":2,"id":"Shader_Development_0"},{"heading":"WGSL Implementation","level":3,"id":"WGSL_Implementation_0"},{"heading":"Hot Reloading","level":3,"id":"Hot_Reloading_0"},{"heading":"Performance Profiling","level":3,"id":"Performance_Profiling_0"}],"links":["architecture/systems/physics/forces.html","architecture/systems/physics/reactions.html","architecture/systems/physics/determinism.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/forces.html","architecture/systems/spells/spells.html","architecture/systems/physics/reactions.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/gpu-shaders.html","pathToRoot":"../../..","attachments":[],"createdTime":1762476838960,"modifiedTime":1762476838961,"sourceSize":12480,"sourcePath":"architecture/systems/physics/gpu-shaders.md","exportPath":"architecture/systems/physics/gpu-shaders.html","showInTree":true,"treeOrder":28,"backlinks":["architecture/systems/physics/forces.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.html","architecture/systems/physics/reactions.html"],"type":"markdown"},"architecture/systems/physics/movement-system.html":{"title":"movement-system","icon":"","description":"Hexagonal grid with sub-grid positioning, velocity management, mass-based interactions, and combination mechanics.Objects move freely on a hexagonal grid using sub-grid offsets and persistent velocities. The combination mechanic merges objects that get too close, maintaining the one-object-per-cell guarantee while enabling dynamic physics interactions.Hex Cell Size: Corner-to-corner distance d chosen to equal the minimum combination distance.One-Per-Cell Guarantee: Cell size ensures no two objects can occupy the same cell, even during mid-movement.Polar Coordinates: Grid uses polar/cube coordinate system for neighbor lookup and point-to-hex conversion.GPU Storage: Grid stored as skewed parallelogram with wrapped boundaries, enabling rectangular indexing.World Wrapping: Objects at world edges wrap to opposite side for continuous circular world.Offset Storage: Each object stores precise x,y offsets from its hex cell center using fixed-point arithmetic.Unconstrained Movement: Objects can move freely in any direction based on applied forces.Precision: Fixed-point representation ensures deterministic positioning across platforms.Cell Assignment: Objects remain assigned to their current hex cell until the final \"set grid position\" pass.Vector Representation: Two-component velocity (x,y) stored with fixed-point precision.Texture Storage: Velocities stored in GPU textures alongside position data.Deterministic Updates: All velocity changes use fixed-point arithmetic.Frame Persistence: Velocity persists frame-to-frame unless modified by forces.Applied Forces: Collision, cohesion, and spell forces modify velocity each frame (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/forces.html\" data-href=\"forces\" aria-label=\"forces\" data-tooltip-position=\"top\" target=\"_self\">Forces</a>).Spell Inputs: Spell elements can apply impulses or directly set velocities.Combinations: Merged objects receive mass-averaged velocity.Damping: Optional velocity damping to prevent perpetual motion (TBD through playtesting).Maximum Velocity: ~9.69 hex cells/second at 60fps based on two-layer force range guarantee.Gameplay Range: Typical gameplay velocities 2-6 cells/second, providing margin for force application.Range Guarantee: Two hex layers sufficient for all force interactions within speed limits.Type-Based: Each object type has an associated mass value.Layer Variation: Different layers may have different mass ranges (e.g., ground heavier than air).Gameplay Impact: Mass affects force response and combination outcomes.⚠️ NEEDS SPECIFICATION: Specific mass values for object types TBD through gameplay balancing.Force Response: Heavier objects accelerate less from the same applied force (F = ma).Collision Interaction: Mass ratio between colliding objects affects their relative force responses.Combination Averaging: When objects combine, velocities are mass-averaged to conserve momentum.Conservation: Total momentum preserved during combinations: m1*v1 + m2*v2 = m_combined * v_combinedOne-Per-Cell Guarantee: Ensures no hex cell ever contains more than one object.Gameplay Feature: Creates dynamic object fusion and reaction chains.Physics Stability: Prevents infinite force application from perpetually overlapping objects.Distance Threshold: Combination triggered when two objects approach closer than distance d.Merge Radius: All objects with centers within d of the combined center are included in the merge.Multi-Object Merges: Single combination can merge 3+ objects if they're all within radius.Velocity Averaging: Combined velocity is mass-weighted average of all merged objects.<br>Type Transformation: New object type determined by reaction rules applied to merged objects (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/reactions.html\" data-href=\"reactions\" aria-label=\"reactions\" data-tooltip-position=\"top\" target=\"_self\">Reaction System</a>).Mass Assignment: New object mass based on its transformed type.Position: Combined object placed at mass-weighted centroid of merged objects.Position:\nHex cell coordinates (using polar/cube system)\nFixed-point offset (x,y) from cell center\nVelocity:\nFixed-point vector (x,y)\nStored in GPU texture alongside position\nProperties:\nObject type ID (for mass lookup and reactions)\nMass value (may be stored or computed from type)\nLayer assignment (Ground/Object/Air)\nTexture Layout: Data packed efficiently for GPU texture storage and access patterns.\nVelocity modified by forces each frame\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/forces.html\" data-href=\"forces\" aria-label=\"forces\" data-tooltip-position=\"top\" target=\"_self\">Forces</a> for force types and calculations Movement calculations performed in GPU compute shaders\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/gpu-shaders.html\" data-href=\"gpu-shaders\" aria-label=\"gpu-shaders\" data-tooltip-position=\"top\" target=\"_self\">GPU Shaders</a> for pipeline details Objects check spell buffer for overlapping spell shapes\nSpell elements determine force application method\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/spells.html\" data-href=\"spells\" aria-label=\"spells\" data-tooltip-position=\"top\" target=\"_self\">Spell System</a> for spell mechanics Combination types determined by reaction rules\nNew object mass based on reaction-determined type\n<br>See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/reactions.html\" data-href=\"reactions\" aria-label=\"reactions\" data-tooltip-position=\"top\" target=\"_self\">Reaction System</a> for transformation rules Sub-grid offsets provide precise visual positioning\nVelocities available for motion blur and particle effects Ground Layer: Terrain foundation (dirt, stone, water)\nObject Layer: Interactive entities (rocks, trees, creatures, players)\nAir Layer: Gases and effects (fire, smoke, magic)\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Architecture","#Implementation"],"headers":[{"heading":"Movement System","level":1,"id":"Movement_System_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Hexagonal Grid Positioning","level":2,"id":"Hexagonal_Grid_Positioning_0"},{"heading":"Grid Structure","level":3,"id":"Grid_Structure_0"},{"heading":"Sub-Grid Positioning","level":3,"id":"Sub-Grid_Positioning_0"},{"heading":"Velocity Management","level":2,"id":"Velocity_Management_0"},{"heading":"Velocity Storage","level":3,"id":"Velocity_Storage_0"},{"heading":"Velocity Sources","level":3,"id":"Velocity_Sources_0"},{"heading":"Speed Limits","level":3,"id":"Speed_Limits_0"},{"heading":"Mass System","level":2,"id":"Mass_System_0"},{"heading":"Object Mass","level":3,"id":"Object_Mass_0"},{"heading":"Mass in Physics","level":3,"id":"Mass_in_Physics_0"},{"heading":"Combination Mechanic","level":2,"id":"Combination_Mechanic_0"},{"heading":"Purpose","level":3,"id":"Purpose_0"},{"heading":"Trigger Conditions","level":3,"id":"Trigger_Conditions_0"},{"heading":"Combination Process","level":3,"id":"Combination_Process_0"},{"heading":"Data Structures","level":2,"id":"Data_Structures_0"},{"heading":"Object Physics Data","level":3,"id":"Object_Physics_Data_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Forces System","level":3,"id":"Forces_System_0"},{"heading":"GPU Implementation","level":3,"id":"GPU_Implementation_0"},{"heading":"Spell System","level":3,"id":"Spell_System_0"},{"heading":"Reaction System","level":3,"id":"Reaction_System_0"},{"heading":"Renderer","level":3,"id":"Renderer_0"},{"heading":"Three-Layer Architecture","level":2,"id":"Three-Layer_Architecture_0"}],"links":["architecture/systems/physics/forces.html","architecture/systems/physics/reactions.html","architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/spells/spells.html","architecture/systems/physics/reactions.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/movement-system.html","pathToRoot":"../../..","attachments":[],"createdTime":1762476711145,"modifiedTime":1762476711145,"sourceSize":6058,"sourcePath":"architecture/systems/physics/movement-system.md","exportPath":"architecture/systems/physics/movement-system.html","showInTree":true,"treeOrder":29,"backlinks":["architecture/general/shader-data-layout.html","architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/physics.html"],"type":"markdown"},"architecture/systems/physics/physics.html":{"title":"physics","icon":"","description":"GPU-accelerated physics simulation on a hexagonal grid with sub-grid positioning, force-based interactions, and combination mechanics.The physics engine provides realistic object movement, interactions, and transformations using:\nHexagonal grid with polar coordinates for efficient circular world representation\nSub-grid positioning with fixed-point arithmetic for smooth, deterministic movement\nForce-based physics including collision repulsion, cohesion attraction, and spell forces\nCombination mechanic that merges nearby objects to maintain one object per hex cell\nReaction system for object transformations from combinations, environmental interactions, and timers\nMulti-pass GPU pipeline for parallel force application, reactions, and collision resolution <a class=\"internal-link\" data-href=\"movement-system.md\" href=\"architecture/systems/physics/movement-system.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Movement System - Hexagonal grid, sub-grid positioning, velocity, mass, and combinations\n<br><a class=\"internal-link\" data-href=\"forces.md\" href=\"architecture/systems/physics/forces.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Forces - Collision, cohesion, and spell force mechanics\n<br><a class=\"internal-link\" data-href=\"reactions.md\" href=\"architecture/systems/physics/reactions.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Reactions - Object transformations from combinations, environmental interactions, and timers\n<br><a class=\"internal-link\" data-href=\"gpu-shaders.md\" href=\"architecture/systems/physics/gpu-shaders.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>GPU Shaders - Multi-pass compute pipeline and implementation\n<br><a class=\"internal-link\" data-href=\"determinism.md\" href=\"architecture/systems/physics/determinism.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Determinism - Fixed-point arithmetic and reproducibility guarantees\nHexagonal Grid: Corner-to-corner cell size d ensures no two objects occupy the same cell, even during movement.Direct Force Resolution: Forces applied continuously while objects overlap - no iterative convergence.Speed Limits: Maximum ~9.69 cells/second at 60fps, with typical gameplay 2-6 cells/second.Three Layers: Ground, Object, and Air layers for different entity types.\nSpell System: Objects check overlapping spell shapes for force application; element combination rules determine reaction outcomes\nRenderer: Provides sub-grid positions, velocities, and timer states for smooth visuals\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Physics Engine","level":1,"id":"Physics_Engine_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Core Components","level":2,"id":"Core_Components_0"},{"heading":"Key Features","level":2,"id":"Key_Features_0"},{"heading":"Integration","level":2,"id":"Integration_0"}],"links":["architecture/systems/physics/movement-system.html","architecture/systems/physics/forces.html","architecture/systems/physics/reactions.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/determinism.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/physics.html","pathToRoot":"../../..","attachments":[],"createdTime":1762579364528,"modifiedTime":1762579364528,"sourceSize":2045,"sourcePath":"architecture/systems/physics/physics.md","exportPath":"architecture/systems/physics/physics.html","showInTree":true,"treeOrder":30,"backlinks":["architecture/systems/spells/spells.html","architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/rendering/rendering.html":{"title":"rendering","icon":"","description":"Status: Incomplete documentationThe Renderer system handles visual display and UI rendering for Reaction v2.The renderer is responsible for:\nGPU-based visual display of the game grid\nUI rendering and interface elements\nFrame coordination with other systems\nVisual effects and animations\nDocumentation incomplete - details to be added during implementationDocumentation incomplete - optimization details to be addedDocumentation incomplete - WebGPU implementation details to be added","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Renderer System","level":1,"id":"Renderer_System_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Architecture","level":2,"id":"Architecture_0"},{"heading":"Performance Considerations","level":2,"id":"Performance_Considerations_0"},{"heading":"GPU Integration","level":2,"id":"GPU_Integration_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/rendering/rendering.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506332,"modifiedTime":1760380506333,"sourceSize":639,"sourcePath":"architecture/systems/rendering/rendering.md","exportPath":"architecture/systems/rendering/rendering.html","showInTree":true,"treeOrder":41,"backlinks":["architecture/general/ghost-simulation.html","architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/spells/cpu-architecture.html":{"title":"cpu-architecture","icon":"","description":"⚠️ DEPRECATED: This document describes a CPU-based spell system that was not implemented.The spell system is now fully GPU-accelerated. See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/spells-and-runes.html\" data-href=\"spells-and-runes\" aria-label=\"spells-and-runes\" data-tooltip-position=\"top\" target=\"_self\">Spells and Runes</a> for current architecture.GPU Processing:\nShape evaluation (compute shaders)\nElement combination (shader computation)\nRune delay countdown (GPU texture counters)\nRune triggering and cleanup (multi-pass shaders)\nThis document originally explored CPU-based spell processing for flexibility and ease of debugging. The decision was later revised to use GPU processing for consistency with physics and reaction systems, better performance at scale, and deterministic parallel evaluation.","aliases":[],"inlineTags":[],"frontmatterTags":["#Architecture"],"headers":[{"heading":"CPU Architecture","level":1,"id":"CPU_Architecture_0"},{"heading":"Current Architecture","level":2,"id":"Current_Architecture_0"},{"heading":"Historical Context","level":2,"id":"Historical_Context_0"}],"links":["architecture/systems/spells/spells-and-runes.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/cpu-architecture.html","pathToRoot":"../../..","attachments":[],"createdTime":1760486638438,"modifiedTime":1760486638438,"sourceSize":923,"sourcePath":"architecture/systems/spells/cpu-architecture.md","exportPath":"architecture/systems/spells/cpu-architecture.html","showInTree":true,"treeOrder":35,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/systems/spells/customization.html":{"title":"customization","icon":"","description":"Player customization through deck building and optional curse mechanics.Deck building is the primary customization system. See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/deck-building.html\" data-href=\"deck-building\" aria-label=\"deck-building\" data-tooltip-position=\"top\" target=\"_self\">Deck Building</a> for complete rules.Key Decisions:\nSpell selection from collection\n<br>Mana flower conversion to match deck composition (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/mana-system.html\" data-href=\"mana-system\" aria-label=\"mana-system\" data-tooltip-position=\"top\" target=\"_self\">Mana System</a>)\nElement focus vs diverse coverage\n⚠️ NEEDS DESIGN: Curse system implementation details TBD.Risk/Reward: Cursed builds offer advantages with meaningful drawbacksOptional: Curses are optional - pure builds remain viableBuild Diversity: Support multiple viable build approaches⚠️ NEEDS SPECIFICATION:\nCurse selection mechanics\nStacking rules (can multiple curses be combined?)\nActivation conditions and triggers\nBalancing approach between pure and cursed builds\nIntegration with deck building and flower conversion\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Architecture"],"headers":[{"heading":"Customization Systems","level":1,"id":"Customization_Systems_0"},{"heading":"Deck Building","level":2,"id":"Deck_Building_0"},{"heading":"Curse System","level":2,"id":"Curse_System_0"},{"heading":"Design Philosophy","level":3,"id":"Design_Philosophy_0"},{"heading":"Implementation Questions","level":3,"id":"Implementation_Questions_0"}],"links":["architecture/systems/spells/deck-building.html","architecture/systems/spells/mana-system.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/customization.html","pathToRoot":"../../..","attachments":[],"createdTime":1760486633200,"modifiedTime":1760486633200,"sourceSize":1195,"sourcePath":"architecture/systems/spells/customization.md","exportPath":"architecture/systems/spells/customization.html","showInTree":true,"treeOrder":36,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/systems/spells/mana-system.html":{"title":"mana-system","icon":"","description":"Resource economy based on 6 elemental flower types with individual flower tracking and strategic conversion mechanics.6 Base Element Flowers: Each flower type corresponds to a base element from cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/element-system.html\" data-href=\"element-system\" aria-label=\"element-system\" data-tooltip-position=\"top\" target=\"_self\">Element System</a>:\nOrder Flowers\nChaos Flowers\nCreation Flowers\nDestruction Flowers\nSpirit Flowers\nForm Flowers\nDefault Allocation: 3 of each type (18 total)Individual Tracking: Each flower has independent recharge state and cooldown.Duration: 3 turns per flowerIndividual Cooldowns: Each flower tracks its own timer independently.Recharge Behavior:\n✅ Cast spell: Flowers recharge normally\n✅ Load spell: Flowers recharge normally\n✅ Movement: Flowers recharge normally\n❌ Refresh pools: Flowers do NOT recharge (strategic penalty)\nUnlimited Regeneration: Flowers always regenerate. Never permanently lost during match.Flexible Costs: Spells require specific combinations and quantities of flower types.Examples:\nBasic Fire spell: 1 Chaos + 1 Creation\nPowerful Fire spell: 3 Chaos + 2 Creation\nLife spell: 1 Order + 1 Creation + 1 Spirit\nValidation: All required flowers must be available (not recharging) to cast spell.Cost-Power Relationship: Higher costs = more powerful spells. Specific costs TBD through playtesting.When: During deck building phase (before match starts)Operation: Lose 2 flowers → gain 1 flower of chosen typeIrreversible: Conversion affects starting flower configuration for that match.Purpose: Specialize flower distribution to match deck element composition.Trade-off: Increased element focus at cost of total capacity and flexibility.<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/element-system.html\" data-href=\"element-system\" aria-label=\"element-system\" data-tooltip-position=\"top\" target=\"_self\">Element System</a> - Spell costs require combinations matching element structure (dual elements = 2 flower types, triple elements = 3 flower types)<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/spells-and-runes.html\" data-href=\"spells-and-runes\" aria-label=\"spells-and-runes\" data-tooltip-position=\"top\" target=\"_self\">Spells and Runes</a> - Refresh action uniquely prevents flower recharge during cooldown<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/deck-building.html\" data-href=\"deck-building\" aria-label=\"deck-building\" data-tooltip-position=\"top\" target=\"_self\">Deck Building</a> - Flower conversion configured during deck construction","aliases":[],"inlineTags":[],"frontmatterTags":["#Architecture"],"headers":[{"heading":"Mana System","level":1,"id":"Mana_System_0"},{"heading":"Flower Types","level":2,"id":"Flower_Types_0"},{"heading":"Recharge Mechanics","level":2,"id":"Recharge_Mechanics_0"},{"heading":"Spell Costs","level":2,"id":"Spell_Costs_0"},{"heading":"Flower Conversion","level":2,"id":"Flower_Conversion_0"},{"heading":"Related Systems","level":2,"id":"Related_Systems_0"}],"links":["architecture/systems/spells/element-system.html","architecture/systems/spells/element-system.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/deck-building.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/mana-system.html","pathToRoot":"../../..","attachments":[],"createdTime":1760486230290,"modifiedTime":1760486230290,"sourceSize":2531,"sourcePath":"architecture/systems/spells/mana-system.md","exportPath":"architecture/systems/spells/mana-system.html","showInTree":true,"treeOrder":39,"backlinks":["architecture/systems/spells/customization.html","architecture/systems/spells/deck-building.html","architecture/systems/spells/element-system.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/systems/spells/spells.html":{"title":"spells","icon":"","description":"GPU-accelerated spellcasting with 26-element magic system, mana flower economy, slot/pool casting interface, and deck customization.Player-controlled spellcasting creates runes on the game world through geometric element combinations, resource management, and strategic deck building.Processing: Fully GPU-accelerated (shape evaluation, element combination, rune lifecycle)Core Systems: Elements (26), Mana (6 flowers), Casting (slot/pool), Runes (lifecycle), Deck Building (singleton)\n<a data-tooltip-position=\"top\" aria-label=\"element-system\" data-href=\"element-system\" href=\"architecture/systems/spells/element-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Element System</a> - 26 elements in cube/octahedron structure\n<br><a data-tooltip-position=\"top\" aria-label=\"mana-system\" data-href=\"mana-system\" href=\"architecture/systems/spells/mana-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Mana System</a> - 6 flower types with recharge and conversion\n<br><a data-tooltip-position=\"top\" aria-label=\"spells-and-runes\" data-href=\"spells-and-runes\" href=\"architecture/systems/spells/spells-and-runes.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Spells and Runes</a> - Casting interface and rune lifecycle\n<br><a data-tooltip-position=\"top\" aria-label=\"deck-building\" data-href=\"deck-building\" href=\"architecture/systems/spells/deck-building.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Deck Building</a> - Deck rules and pre-match construction\n<br><a data-tooltip-position=\"top\" aria-label=\"customization\" data-href=\"customization\" href=\"architecture/systems/spells/customization.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Customization</a> - Curse system and build options\n<br><a data-tooltip-position=\"top\" aria-label=\"cpu-architecture\" data-href=\"cpu-architecture\" href=\"architecture/systems/spells/cpu-architecture.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">CPU Architecture</a> - Outdated, system now GPU-accelerated <br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/physics.html\" data-href=\"../physics/physics\" aria-label=\"../physics/physics\" data-tooltip-position=\"top\" target=\"_self\">Physics System</a> - Force application from triggered runes\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\".html\" data-href=\"../core/core\" aria-label=\"../core/core\" data-tooltip-position=\"top\" target=\"_self\">Core Engine</a> - Texture management and layer coordination\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\".html\" data-href=\"../reactions/reactions\" aria-label=\"../reactions/reactions\" data-tooltip-position=\"top\" target=\"_self\">Reaction System</a> - Environmental interactions\nPhysics Engine: Triggered runes apply force vectors to physics layer. Independent tick rates coordinate timing.Core Engine: Manages rune layer texture for GPU processing.Reaction Engine: Runes can trigger environmental transformation rules.UI System: Displays casting slots/pools, mana flower availability, targeting overlay, and deck builder interface.Documented:\nElement system (26 elements, cancellation rules)\nMana system (6 flowers, recharge, conversion)\nCasting interface (slot/pool, actions, cooldown)\nRune lifecycle (placement, delay, trigger, combination)\nDeck building rules (minimum size, singleton, reshuffle)\nNeeds Design:\nSpecific spell shape primitives\nVoid rune effects\nSingle element rune additional effects\nCurse system mechanics\nSpell acquisition/progression system\nLine of sight obstruction rules\nNumber of casting slots/pools\n<br>Entry Point: Start with <a data-tooltip-position=\"top\" aria-label=\"element-system\" data-href=\"element-system\" href=\"architecture/systems/spells/element-system.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Element System</a> to understand the foundational magic structure.","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Spell System","level":1,"id":"Spell_System_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Components","level":3,"id":"Core_Components_0"},{"heading":"Related Systems","level":3,"id":"Related_Systems_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"},{"heading":"Implementation Status","level":2,"id":"Implementation_Status_0"}],"links":["architecture/systems/spells/element-system.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/deck-building.html","architecture/systems/spells/customization.html","architecture/systems/spells/cpu-architecture.html","architecture/systems/physics/physics.html",".html",".html","architecture/systems/spells/element-system.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/spells.html","pathToRoot":"../../..","attachments":[],"createdTime":1760486185216,"modifiedTime":1760486185216,"sourceSize":2552,"sourcePath":"architecture/systems/spells/spells.md","exportPath":"architecture/systems/spells/spells.html","showInTree":true,"treeOrder":40,"backlinks":["architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.html","architecture/systems/systems.html","gameplay/core-mechanics.html"],"type":"markdown"},"architecture/systems/spells/spells-and-runes.html":{"title":"spells-and-runes","icon":"","description":"Slot/pool casting interface with GPU-accelerated spell shapes, element combinations, and rune lifecycle management.Structure: N casting slots + N casting pools (using 4 as example, final count TBD)Starting State: All slots empty, all pools filled with random spells from deck1. Cast Spell (from filled slot):\nConsumes required mana flowers (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/mana-system.html\" data-href=\"mana-system\" aria-label=\"mana-system\" data-tooltip-position=\"top\" target=\"_self\">Mana System</a>)\nTriggers directional targeting mode\nSlot becomes empty after cast\nPools unchanged\n2. Load Spell (pool → empty slot):\nPlayer selects spell from any pool\nChosen spell moves to clicked slot\n<br>All pools refill sequentially from deck (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/deck-building.html\" data-href=\"deck-building\" aria-label=\"deck-building\" data-tooltip-position=\"top\" target=\"_self\">Deck Building</a>)\nNo mana cost\n3. Refresh Pools:\nManually replace all pool spells with new draws from deck\nTriggers action cooldown\nFlowers do NOT recharge during refresh cooldown (unique penalty)\nUniversal Cooldown: Single shared cooldown applies to all three actionsMovement: Not affected by action cooldownHold-to-Cast Queueing: Hold mouse on filled slot during cooldown to queue cast for immediate execution when readyActivation: After clicking cast, enter targeting modeInput: Player clicks direction and distance from avatarPlacement: Spell shape centered on clicked locationRange Limits: Each spell has maximum range from casterObstruction: ⚠️ NEEDS DESIGN - Line of sight checks TBDDesign: Abstract geometric primitives (circles, rectangles, lines, etc.) evaluated at runtimeNot Textures: Mathematical definitions, not pre-rendered imagesEvaluation: GPU compute shaders evaluate shape membership per-pixelPrimitives: ⚠️ NEEDS SPECIFICATION - Specific primitive set TBD through spell design processShape Components:\nPosition (relative to spell center)\nRotation and scale\n<br>Element type (from cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/element-system.html\" data-href=\"element-system\" aria-label=\"element-system\" data-tooltip-position=\"top\" target=\"_self\">Element System</a>)\nForce vector\nDelay value Placement: Spell casting writes runes to rune layer via GPU\nDelay Countdown: GPU shader decrements delay counter each frame\nTrigger + Removal: Simultaneous - apply effects and remove rune when delay reaches zero\nCombination: Multiple runes on same pixel combine before triggering\n<br>Element Type: One of 26 elements (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/element-system.html\" data-href=\"element-system\" aria-label=\"element-system\" data-tooltip-position=\"top\" target=\"_self\">Element System</a>)Force Vector: Applied to physics layer when triggeredDelay Counter: Frame-based countdownStorage: Per-pixel on dedicated rune layer textureTiming: Runes combine when multiple exist on same pixel<br>Element Rules: Uses element system cancellation rules (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/element-system.html\" data-href=\"element-system\" aria-label=\"element-system\" data-tooltip-position=\"top\" target=\"_self\">Element System</a>)Force Combination: Vector addition of all force componentsDelay Resolution: Combined rune uses minimum delay of componentsTrigger Timing: Combined rune triggers when shortest delay expiresDelay System: 16-bit looping time counter, runes store target trigger timeShape Evaluation: Compute shaders evaluate abstract primitives per-pixel during spell placementElement Combination: Shader-based component-level cancellation during rune combinationCleanup: Separate shader pass removes triggered runesDeterminism: Fixed-point precision, order-independent combination results","aliases":[],"inlineTags":[],"frontmatterTags":["#Architecture"],"headers":[{"heading":"Spells and Runes","level":1,"id":"Spells_and_Runes_0"},{"heading":"Casting Interface","level":2,"id":"Casting_Interface_0"},{"heading":"Slot and Pool System","level":3,"id":"Slot_and_Pool_System_0"},{"heading":"Three Player Actions","level":3,"id":"Three_Player_Actions_0"},{"heading":"Action Cooldown","level":3,"id":"Action_Cooldown_0"},{"heading":"Directional Targeting","level":3,"id":"Directional_Targeting_0"},{"heading":"Spell Shapes","level":2,"id":"Spell_Shapes_0"},{"heading":"Rune System","level":2,"id":"Rune_System_0"},{"heading":"Rune Lifecycle","level":3,"id":"Rune_Lifecycle_0"},{"heading":"Rune Properties","level":3,"id":"Rune_Properties_0"},{"heading":"Rune Combination","level":3,"id":"Rune_Combination_0"},{"heading":"GPU Processing","level":2,"id":"GPU_Processing_0"}],"links":["architecture/systems/spells/mana-system.html","architecture/systems/spells/deck-building.html","architecture/systems/spells/element-system.html","architecture/systems/spells/element-system.html","architecture/systems/spells/element-system.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/spells-and-runes.html","pathToRoot":"../../..","attachments":[],"createdTime":1760486259469,"modifiedTime":1760486259469,"sourceSize":4041,"sourcePath":"architecture/systems/spells/spells-and-runes.md","exportPath":"architecture/systems/spells/spells-and-runes.html","showInTree":true,"treeOrder":41,"backlinks":["architecture/systems/spells/cpu-architecture.html","architecture/systems/spells/element-system.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/systems/ui/ui.html":{"title":"ui","icon":"","description":"Status: 🚧 Stub - This system documentation needs completionUser interface system for game controls, HUD elements, and player interaction.TODO: Add links to UI components when implemented:\nInterface layout and component hierarchy\nInput handling and interaction patterns\nHUD elements and game overlays\nMenu systems and navigation\nTODO: Document UI system responsibilities:\nGame HUD: Mana flowers, spell hand, player status indicators\nGame Controls: Spell casting interface, movement controls, action queuing\nMenu Systems: Main menu, settings, deck building, game lobby\nVisual Feedback: Action confirmations, error states, loading indicators\nTODO: Define major UI components:\nMana Flower Display: Visual representation of mana types and recharge status\nSpell Hand Interface: Spell selection and casting controls\nGrid Overlay: Tile highlighting, targeting cursors, range indicators\nAction Queue Visualization: Preview of queued player actions\nGame Status: Timer, player health, elimination status\nTODO: Add design guidelines:\nClarity: Clear visual hierarchy and information priority\nResponsiveness: Immediate feedback for all player actions\nAccessibility: Keyboard navigation, screen reader support, color accessibility\nScalability: Support for different screen sizes and resolutions\nTODO: Document system integrations:\nInput System: Mouse, keyboard, and touch input handling\nRenderer: UI rendering pipeline and performance considerations\nGame State: Real-time updates from game simulation\nSpell System: Integration with spell casting and mana management\n🚧 This file is a stub and needs completion","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"User Interface System","level":1,"id":"User_Interface_System_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"System Overview","level":2,"id":"System_Overview_0"},{"heading":"UI Components","level":2,"id":"UI_Components_0"},{"heading":"Design Principles","level":2,"id":"Design_Principles_0"},{"heading":"Integration Points","level":2,"id":"Integration_Points_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"architecture/systems/ui/ui.html","pathToRoot":"../../..","attachments":[],"createdTime":1760380506336,"modifiedTime":1760380506337,"sourceSize":2063,"sourcePath":"architecture/systems/ui/ui.md","exportPath":"architecture/systems/ui/ui.html","showInTree":true,"treeOrder":51,"backlinks":["architecture/systems/systems.html"],"type":"markdown"},"architecture/systems/systems.html":{"title":"systems","icon":"","description":"Navigational document for the systems of Reaction v2.\n<a class=\"internal-link\" data-href=\"spells/spells.md\" href=\"architecture/systems/spells/spells.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Spell System - Player spellcasting and mana management\n<br><a class=\"internal-link\" data-href=\"physics/physics.md\" href=\"architecture/systems/physics/physics.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Physics Engine - GPU-accelerated movement, collisions, and reactions\n<br><a class=\"internal-link\" data-href=\"rendering/rendering.md\" href=\"architecture/systems/rendering/rendering.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Renderer - Visual display and UI rendering\n<br><a class=\"internal-link\" data-href=\"multiplayer/multiplayer.md\" href=\"architecture/systems/multiplayer/multiplayer.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Multiplayer - Real-time PvP networking\n<br><a class=\"internal-link\" data-href=\"ui/ui.md\" href=\"architecture/systems/ui/ui.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>User Interface - Game controls, HUD elements, and player interaction\n<br><a class=\"internal-link\" data-href=\"config/config.md\" href=\"architecture/systems/config/config.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Configuration - System settings and runtime parameters\n<br><a class=\"internal-link\" data-href=\"gpu/gpu.md\" href=\"architecture/systems/gpu/gpu.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>GPU Manager - WebGPU resource management and coordination\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Systems","level":1,"id":"Systems_0"},{"heading":"System Architecture","level":2,"id":"System_Architecture_0"}],"links":["architecture/systems/spells/spells.html","architecture/systems/physics/physics.html","architecture/systems/rendering/rendering.html","architecture/systems/multiplayer/multiplayer.html","architecture/systems/ui/ui.html","architecture/systems/config/config.html","architecture/systems/gpu/gpu.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/systems.html","pathToRoot":"../..","attachments":[],"createdTime":1762579301306,"modifiedTime":1762579301306,"sourceSize":694,"sourcePath":"architecture/systems/systems.md","exportPath":"architecture/systems/systems.html","showInTree":true,"treeOrder":44,"backlinks":["architecture/architecture.html"],"type":"markdown"},"architecture/architecture.html":{"title":"architecture","icon":"","description":"High-level system design, technical decisions, and performance considerations for Reaction v2.\ncross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/overview.html\" data-href=\"overview\" aria-label=\"overview\" data-tooltip-position=\"top\" target=\"_self\">System Overview</a> - Complete architectural design and module relationships\n<br><a class=\"internal-link\" data-href=\"general/general.md\" href=\"architecture/general/general.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>General Architecture - Core architectural concepts and design patterns <br><a class=\"internal-link\" data-href=\"systems/systems.md\" href=\"architecture/systems/systems.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Systems - Individual system modules and implementations\nModular Design: Modules with focused responsibilitiesWebGPU Processing: Physics, reactions, and rendering use GPU computeDeterministic Requirements: Identical inputs must produce identical outputs for PvP through simultaneous single-read/single-write GPU passesActive Region System: Process only chunks with changing tiles ⚠️ NOT IMPLEMENTED: Active region optimization was decided against⚠️ Unsolved Issues Requiring Design Work:\nFrame rate coordination between physics, reactions, and rendering systems\nGPU thread execution determinism guarantees (current approach: simultaneous read/write passes)\nSpecific rule compilation pipeline implementation Tile Storage: 4 layers (Ground, Object, Air, Rune) with bit-packed 32-bit tiles\nChunk Size: 32×32 tiles (balances GPU workgroup efficiency with memory overhead) ⚠️ Active region system not implemented\nProcessing Order: Input → Physics → Runes → Reactions → Render\nCommunication: Core Engine coordinates data flow between modules\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Architecture Documentation","level":1,"id":"Architecture_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Architecture","level":3,"id":"Core_Architecture_0"},{"heading":"System Implementations","level":3,"id":"System_Implementations_0"},{"heading":"Architectural Approach","level":2,"id":"Architectural_Approach_0"},{"heading":"Major Technical Challenges","level":2,"id":"Major_Technical_Challenges_0"},{"heading":"System Summary","level":2,"id":"System_Summary_0"}],"links":["architecture/general/overview.html","architecture/general/general.html","architecture/systems/systems.html"],"author":"","coverImageURL":"","fullURL":"architecture/architecture.html","pathToRoot":"..","attachments":[],"createdTime":1760397055156,"modifiedTime":1760397055156,"sourceSize":2007,"sourcePath":"architecture/architecture.md","exportPath":"architecture/architecture.html","showInTree":true,"treeOrder":45,"backlinks":["docs.html","index.html"],"type":"markdown"},"development/building-documentation.html":{"title":"building-documentation","icon":"","description":"The documentation system uses Obsidian for authoring (in docs/) and exports to HTML for GitHub Pages deployment via git subtree.\nObsidian with \"Webpage HTML Export\" plugin installed\nGit command line tools Open the docs/ folder as a vault in Obsidian\nEither: Click the \"Export as HTML\" button (added by Webpage HTML Export plugin)\nOr run command \"Webpage HTML Export: Export using previous settings\" Ensure export target is set to build/docs\nAfter exporting, commit and push the changes in the worktree:cd build/docs\ngit add .\ngit commit -m \"Update documentation\"\ngit push\ncd ../.. Documentation source files (Markdown) live in docs/ on the main branch\nBuilt HTML files are in build/docs/ which is a git worktree of the gh-pages branch\nThe worktree allows direct commits to gh-pages without switching branches\nChanges to documentation require rebuilding and redeploying\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Building Documentation","level":1,"id":"Building_Documentation_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Prerequisites","level":2,"id":"Prerequisites_0"},{"heading":"Build Process","level":2,"id":"Build_Process_0"},{"heading":"1. Export Documentation from Obsidian","level":3,"id":"1._Export_Documentation_from_Obsidian_0"},{"heading":"2. Deploy to GitHub Pages","level":3,"id":"2._Deploy_to_GitHub_Pages_0"},{"heading":"Notes","level":2,"id":"Notes_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"development/building-documentation.html","pathToRoot":"..","attachments":[],"createdTime":1760380506338,"modifiedTime":1760380506338,"sourceSize":1084,"sourcePath":"development/building-documentation.md","exportPath":"development/building-documentation.html","showInTree":true,"treeOrder":55,"backlinks":["index.html"],"type":"markdown"},"development/development.html":{"title":"development","icon":"","description":"Setup, workflow, and development processes for Reaction v2.\n<a class=\"internal-link\" data-href=\"getting-started.md\" href=\"development/getting-started.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Getting Started - Project setup and first build\n<br><a class=\"internal-link\" data-href=\"DEVELOPMENT_PRINCIPLES.md\" href=\"development/development_principles.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Development Principles - Core values and guidelines for contributors\n<br><a class=\"internal-link\" data-href=\"DOCUMENTATION_STRUCTURE.md\" href=\"development/documentation_structure.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Documentation Structure - How to organize and navigate documentation\n<br><a class=\"internal-link\" data-href=\"building-documentation.md\" href=\"development/building-documentation.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Building Documentation - Export and deploy documentation to GitHub Pages <br><a class=\"internal-link\" data-href=\"tasklist.md\" href=\"development/tasklist.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Task List - Auto-generated TODO items, warnings, and documentation status\nnpm install\nnpm run dev # Development server\nnpm run test # Test suite npm run build # Production build\nnpm run lint # ESLint\nnpm run format # Prettier Core types: src/core/types.ts\nSpell types: src/spell-system/types.ts\nDocumentation: docs/\nArchitecture: docs/architecture/\n<br>See <a class=\"internal-link\" data-href=\"DEVELOPMENT_PRINCIPLES.md\" href=\"development/development_principles.html\" target=\"_self\" rel=\"noopener nofollow\">Development Principles</a> for core values and <a class=\"internal-link\" data-href=\"DOCUMENTATION_STRUCTURE.md\" href=\"development/documentation_structure.html\" target=\"_self\" rel=\"noopener nofollow\">Documentation Structure</a> for information organization guidelines.","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Development Documentation","level":1,"id":"Development_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Getting Started","level":3,"id":"Getting_Started_0"},{"heading":"Project Management","level":3,"id":"Project_Management_0"},{"heading":"Quick Start","level":2,"id":"Quick_Start_0"},{"heading":"Development Commands","level":3,"id":"Development_Commands_0"},{"heading":"Project Structure","level":3,"id":"Project_Structure_0"},{"heading":"Development Principles","level":2,"id":"Development_Principles_0"},{"heading":"Development Guidelines","level":3,"id":"Development_Guidelines_0"}],"links":["development/getting-started.html","development/development_principles.html","development/documentation_structure.html","development/building-documentation.html","development/tasklist.html","development/development_principles.html","development/documentation_structure.html"],"author":"","coverImageURL":"","fullURL":"development/development.html","pathToRoot":"..","attachments":[],"createdTime":1760383329148,"modifiedTime":1760383329149,"sourceSize":1311,"sourcePath":"development/development.md","exportPath":"development/development.html","showInTree":true,"treeOrder":56,"backlinks":["docs.html","architecture/systems/systems.html","index.html"],"type":"markdown"},"development/development_principles.html":{"title":"DEVELOPMENT_PRINCIPLES","icon":"","description":"\nNever fabricate performance numbers, statistics, or benchmarks\nMark personal ideas as such - don't present speculation as team decisions\nSay \"I don't know\" when you don't know\nUncertainty is better than false confidence Code should explain itself through naming and structure\nIf you need extensive comments to explain what code does, rewrite it\nMagic numbers and unclear constants are tech debt\nOptimize for the next person who reads your code Distinguish between your ideas and team decisions\nMake it easy for others to understand and build on your work\nAsk questions when design decisions aren't clear\nShare context behind your choices Use descriptive names for functions, variables, and files\nHandle error cases explicitly - don't ignore or hide failures\nPrefer simple, obvious solutions over clever optimizations\nDocument the \"why\" behind non-obvious business logic Be honest about what's decided vs. what you're proposing\nInclude enough context for someone to understand and challenge your reasoning\nAvoid inventing performance claims or user behavior assumptions\nNote when something needs team input or further research Understand the problem before jumping to solutions\nConsider the person who will maintain this code in 6 months\nChoose consistency with existing patterns over personal preference\nMeasure performance claims rather than guessing Write clear, descriptive commit messages that explain the \"why\" not just the \"what\"\nMake atomic commits - each commit should represent one logical change\nNever commit broken code or failing tests to main branch\nUse branches for feature development and merge via pull requests\nReview your own changes before committing - check diffs carefully\nKeep commits focused - avoid mixing unrelated changes\nTest your changes locally before pushing\nBefore committing work, ask:\nCan someone else understand this without asking me questions?\nAm I making any claims I can't back up?\nIs this the simplest solution that solves the actual problem?\nHave I clearly indicated what needs team discussion?\nAre my commit messages clear and descriptive?\nHave I tested my changes locally?\nThe goal is sustainable development where team members can confidently build on each other's work.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Development Principles","level":1,"id":"Development_Principles_0"},{"heading":"Core Values","level":2,"id":"Core_Values_0"},{"heading":"Truth Over Polish","level":3,"id":"Truth_Over_Polish_0"},{"heading":"Clarity Over Cleverness","level":3,"id":"Clarity_Over_Cleverness_0"},{"heading":"Collaboration Over Ego","level":3,"id":"Collaboration_Over_Ego_0"},{"heading":"Practical Guidelines","level":2,"id":"Practical_Guidelines_0"},{"heading":"When Writing Code","level":3,"id":"When_Writing_Code_0"},{"heading":"When Writing Documentation","level":3,"id":"When_Writing_Documentation_0"},{"heading":"When Making Decisions","level":3,"id":"When_Making_Decisions_0"},{"heading":"Source Control Practices","level":3,"id":"Source_Control_Practices_0"},{"heading":"Quality Questions","level":2,"id":"Quality_Questions_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"development/development_principles.html","pathToRoot":"..","attachments":[],"createdTime":1760380506337,"modifiedTime":1760380506337,"sourceSize":2569,"sourcePath":"development/DEVELOPMENT_PRINCIPLES.md","exportPath":"development/development_principles.html","showInTree":true,"treeOrder":57,"backlinks":["development/development.html","architecture/systems/systems.html","index.html"],"type":"markdown"},"development/documentation_structure.html":{"title":"DOCUMENTATION_STRUCTURE","icon":"","description":"Documentation should function as a navigational search tree where each level provides just enough information to guide readers to the right destination.Parent nodes are signposts, not encyclopedias\nOverview documents help readers navigate to specifics\nInclude enough detail to make informed navigation choices\nAvoid comprehensive coverage at high levels\nNo redundant information\nEach piece of information has one authoritative location\nLink to sources rather than copying content\nUpdate links when information moves\nHierarchical information flow\nOverview → Category → Implementation Details\nGeneral concepts → Specific examples\nArchitecture → Component details\nOverview Documents\nList what's covered and where to find it\nProvide context for understanding relationships\nInclude links to detailed documentation\nDon't duplicate content from linked pages\nCategory Documents\nExplain concepts specific to that category\nDirect readers to implementation details\nShow how pieces relate within the category\nLink to related categories when relevant\nDetail Documents\nContain complete implementation information\nReference but don't duplicate architectural context\nLink back to parent concepts when helpful\nFocus on specific, actionable content\nTop-Down Discovery\nStart with high-level goals or concepts\nFollow links to increasingly specific information\nEach level adds detail without repeating previous levels\nCross-ReferencingThe documentation uses two types of links to distinguish hierarchical structure from references:Regular Links - Use standard wiki-link syntax for direct parent-child relationships:[[child-document|Display Name]]\nCross-Reference Links - Use cross-reference syntax for non-hierarchical links:[cross-reference:: [[other-document|Display Name]]]\nWhen to use cross-reference syntax:\nLinking to files that are NOT direct children of the current document\nReferencing related concepts at the same level or in different branches\nLinking to authoritative sources for shared information\nAny link that represents a reference rather than a structural parent-child relationship\nPurpose: The cross-reference syntax allows Obsidian's graph view to filter out reference links, displaying only the hierarchical documentation tree structure. This makes it easier to visualize and maintain the documentation organization.Guidelines:\nUse regular links to show \"this document contains these sub-topics\"\nUse cross-reference links to show \"see this other document for more information\"\nAvoid circular documentation dependencies regardless of link type\nMaintenance\nWhen information changes, update it in one place\nCheck that navigation paths remain clear\nRemove or redirect broken internal links\nEnsure new content fits the existing hierarchy\nDocumentation files use YAML frontmatter to track document status, categorization, and task management. This metadata integrates with Dataview for automated task tracking and status monitoring.Tracks document lifecycle and implementation state:\nstub - Placeholder document that needs content\ndraft - Being actively written, incomplete\nproposed - Complete proposal awaiting team approval\napproved - Approved design ready for implementation\nimplemented - Code exists matching this documentation\noutdated - Document needs updating to match current state\ndeprecated - Obsolete but kept for historical reference\nExample:---\nstatus: proposed\n---\nCategorizes document type for filtering and organization:\nNavigation - Index, overview, or parent pages\nArchitecture - System architecture and design\nImplementation - Detailed implementation specifications\nReference - API references, data formats, constants\nDevelopment - Development process and workflow\nTesting - Testing strategies and requirements\nPerformance - Performance analysis and optimization\nSecurity - Security considerations and requirements\nMultiplayer - Multiplayer-specific systems\nLegacy - Version 1 reference material\nTaskList - Special: automated task aggregator pages\nExample:---\ntags: - Architecture - Performance\n---\nTask tracking with subcategories using tagged items. Each todo item can have an optional [category] tag at the start:Categories:\n[implementation] - Code needs to be written\n[testing] - Tests need to be written\n[discussion] - Requires team discussion/decision\n[research] - Requires investigation or research\n[documentation] - Documentation needs to be written\n[review] - Needs code or design review\n(no tag) - General uncategorized task\nExample:---\ntodo: - \"[implementation] Detailed performance benchmarking of time slice overhead\" - \"[testing] Cross-platform determinism validation suite\" - \"[discussion] Optimal slice count (current proposal: 8 slices)\" - \"[research] Alternative scheduling algorithms\" - \"[documentation] Complete API reference section\" - \"General task without category\"\n---\nTracks concerns, proposals, and issues requiring attention. Each warning can have an optional [type] tag:Types:\n[proposed] - Proposed system or architectural decision\n[outdated] - Content is outdated and needs updating\n[breaking] - Breaking change to existing implementations\n[performance] - Performance concern or bottleneck\n[security] - Security concern or vulnerability\n[debt] - Technical debt that should be addressed\n(no tag) - General warning\nExample:---\nwarnings: - \"[proposed] Time slice scheduling system enables variable timing\" - \"[performance] High memory usage with 300 snapshot buffer\" - \"[breaking] API changes required for state management\" - \"[debt] Inefficient memory allocation in snapshot system\"\n---\n---\nstatus: proposed\ntags: - Architecture - Multiplayer\ntodo: - \"[implementation] Performance benchmarking of snapshot creation\" - \"[testing] Network bandwidth testing with delta compression\" - \"[discussion] Snapshot retention policy (current: 5 seconds)\"\nwarnings: - \"[proposed] Unified state management serves single and multiplayer\" - \"[performance] Snapshot creation overhead needs measurement\"\n---\nThe subcategorized todo and warning items allow Dataview queries to filter by specific types. See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"development/tasklist.html\" data-href=\"tasklist\" aria-label=\"tasklist\" data-tooltip-position=\"top\" target=\"_self\">Task List</a> for automated queries that collect and organize these items across all documentation.\nUse status to track document maturity through its lifecycle\nApply tags for broad categorization (multiple tags allowed)\nSubcategorize todo items to help with task filtering and prioritization\nSubcategorize warnings to identify types of concerns at a glance\nUpdate status as documents progress from draft → proposed → approved → implemented\nMark documents as outdated when code diverges from documentation\nThe goal is that readers can efficiently find exactly what they need without encountering duplicate or outdated information.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Documentation Structure","level":1,"id":"Documentation_Structure_0"},{"heading":"Search Tree Architecture","level":2,"id":"Search_Tree_Architecture_0"},{"heading":"Core Principles","level":3,"id":"Core_Principles_0"},{"heading":"Practical Guidelines","level":3,"id":"Practical_Guidelines_0"},{"heading":"Navigation Patterns","level":3,"id":"Navigation_Patterns_0"},{"heading":"Frontmatter Metadata","level":2,"id":"Frontmatter_Metadata_0"},{"heading":"Status Field","level":3,"id":"Status_Field_0"},{"heading":"Tags Field","level":3,"id":"Tags_Field_0"},{"heading":"Todo Field","level":3,"id":"Todo_Field_0"},{"heading":"Warnings Field","level":3,"id":"Warnings_Field_0"},{"heading":"Complete Frontmatter Example","level":3,"id":"Complete_Frontmatter_Example_0"},{"heading":"Integration with Dataview","level":3,"id":"Integration_with_Dataview_0"},{"heading":"Usage Guidelines","level":3,"id":"Usage_Guidelines_0"}],"links":["development/tasklist.html"],"author":"","coverImageURL":"","fullURL":"development/documentation_structure.html","pathToRoot":"..","attachments":[],"createdTime":1760384850468,"modifiedTime":1760384850468,"sourceSize":7470,"sourcePath":"development/DOCUMENTATION_STRUCTURE.md","exportPath":"development/documentation_structure.html","showInTree":true,"treeOrder":58,"backlinks":["development/development.html","development/tasklist.html"],"type":"markdown"},"development/getting-started.html":{"title":"getting-started","icon":"","description":"Project setup and development environment configuration for Reaction v2.\nNode.js: Latest LTS version recommended\nnpm: Comes with Node.js installation\nWebGPU-compatible browser: Chrome 113+, Firefox 113+, or Safari Technology Preview GPU: WebGPU-compatible graphics card\nMemory: 8GB+ RAM recommended for development\nStorage: 2GB+ free space for dependencies and build artifacts\nnpm install\nnpm run dev\nThis starts the development server with hot reload and debugging enabled.\nOpen browser to development server URL (usually http://localhost:5173)\nCheck browser console for WebGPU support\nVerify no initial compilation errors\nnpm run dev # Development server with hot reload\nnpm run test # Run test suite\nnpm run build # Production build\nnpm run lint # ESLint code checking npm run format # Prettier code formatting\n.\n├── src/ # Source code\n│ ├── core/ # Core Engine module\n│ ├── spell-system/ # Spell System module │ ├── physics-engine/ # Physics Engine module\n│ ├── reaction-engine/ # Reaction Engine module\n│ ├── renderer/ # Renderer module\n│ └── tools/ # Development tools\n├── docs/ # Documentation\n├── tests/ # Test files\n└── package.json # Project configuration\nProblem: Browser doesn't support WebGPU\nSolution: Use Chrome 113+, Firefox 113+, or enable experimental featuresProblem: TypeScript compilation errors\nSolution: Run npm run lint and fix reported issuesProblem: Development server running slowly\nSolution: Close other applications, check GPU drivers are updated\nRead Architecture: Start with cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/overview.html\" data-href=\"overview\" aria-label=\"overview\" data-tooltip-position=\"top\" target=\"_self\">Architecture Overview</a>\nExplore Systems: Browse individual system documentation\nRun Tests: Verify everything works with npm run test\nMake Changes: Try modifying code and see hot reload in action\n⚠️ SUGGESTION: Consider establishing:\nIDE configuration and recommended extensions\nWebGPU debugging extensions\nPerformance profiling tools\nGPU shader debugging setup\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Getting Started","level":1,"id":"Getting_Started_0"},{"heading":"Prerequisites","level":2,"id":"Prerequisites_0"},{"heading":"Required Software","level":3,"id":"Required_Software_0"},{"heading":"Hardware Requirements","level":3,"id":"Hardware_Requirements_0"},{"heading":"Initial Setup","level":2,"id":"Initial_Setup_0"},{"heading":"1. Project Installation","level":3,"id":"1._Project_Installation_0"},{"heading":"2. Development Server","level":3,"id":"2._Development_Server_0"},{"heading":"3. Verify Setup","level":3,"id":"3._Verify_Setup_0"},{"heading":"Development Workflow","level":2,"id":"Development_Workflow_0"},{"heading":"Available Commands","level":3,"id":"Available_Commands_0"},{"heading":"File Structure Overview","level":3,"id":"File_Structure_Overview_0"},{"heading":"Common Issues","level":2,"id":"Common_Issues_0"},{"heading":"WebGPU Not Available","level":3,"id":"WebGPU_Not_Available_0"},{"heading":"Build Failures","level":3,"id":"Build_Failures_0"},{"heading":"Performance Issues","level":3,"id":"Performance_Issues_0"},{"heading":"Next Steps","level":2,"id":"Next_Steps_0"},{"heading":"Development Environment","level":2,"id":"Development_Environment_0"},{"heading":"Development Environment Setup","level":3,"id":"Development_Environment_Setup_0"}],"links":["architecture/general/overview.html"],"author":"","coverImageURL":"","fullURL":"development/getting-started.html","pathToRoot":"..","attachments":[],"createdTime":1760380506339,"modifiedTime":1760380506339,"sourceSize":2709,"sourcePath":"development/getting-started.md","exportPath":"development/getting-started.html","showInTree":true,"treeOrder":59,"backlinks":["development/development.html","architecture/systems/systems.html","index.html"],"type":"markdown"},"development/tasklist.html":{"title":"tasklist","icon":"","description":"Automatically generated task list from all TODO items found in the documentation using Dataview.Status Overview All TODO Items\n<a data-tooltip-position=\"top\" aria-label=\"architecture/systems/config/config.md\" data-href=\"architecture/systems/config/config.md\" href=\"architecture/systems/config/config.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">config</a>: Define configuration system architectureDocument configuration file formatsAdd runtime configuration managementDocument environment-specific settings<br><a data-tooltip-position=\"top\" aria-label=\"docs.md\" data-href=\"docs.md\" href=\"docs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">docs</a>: Complete main documentation indexAdd project overview sectionAdd getting started quick links<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/ghost-simulation.md\" data-href=\"architecture/general/ghost-simulation.md\" href=\"architecture/general/ghost-simulation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ghost-simulation</a>: NEEDS IMPLEMENTATION: Performance benchmarking of different complexity levelsNEEDS IMPLEMENTATION: User experience testing of ghost feedback effectivenessNEEDS IMPLEMENTATION: Integration testing with action queue and timing systems<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/state-management.md\" data-href=\"architecture/general/state-management.md\" href=\"architecture/general/state-management.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">state-management</a>: NEEDS IMPLEMENTATION: Performance benchmarking of snapshot creation overheadNEEDS IMPLEMENTATION: Network bandwidth testing with delta compressionNEEDS IMPLEMENTATION: Cross-platform determinism validation suite<br><a data-tooltip-position=\"top\" aria-label=\"architecture/systems/ui/ui.md\" data-href=\"architecture/systems/ui/ui.md\" href=\"architecture/systems/ui/ui.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ui</a>: Define UI system architectureDocument component hierarchyAdd interaction patternsDocument accessibility requirements<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/variable-timing.md\" data-href=\"architecture/general/variable-timing.md\" href=\"architecture/general/variable-timing.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">variable-timing</a>: NEEDS IMPLEMENTATION: Detailed performance benchmarking of time slice overheadNEEDS IMPLEMENTATION: Integration testing with existing Core Engine texture managementNEEDS IMPLEMENTATION: Multiplayer synchronization validation\nAll Warnings\n<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/data-flow.md\" data-href=\"architecture/general/data-flow.md\" href=\"architecture/general/data-flow.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">data-flow</a>: OUTDATED DOCUMENT: Physics system has been updated and this document no longer reflects current architectural directionNEEDS TEAM DISCUSSION: Optimal time slice count (8 vs 4 vs 16)NEEDS TEAM DISCUSSION: Performance impact of deterministic GPU orderingNEEDS TEAM DISCUSSION: Ghost simulation complexity vs performance trade-offs<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/ghost-simulation.md\" data-href=\"architecture/general/ghost-simulation.md\" href=\"architecture/general/ghost-simulation.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ghost-simulation</a>: PROPOSED SYSTEM: Predictive action visualization system shows players their queued actionsNEEDS TEAM DISCUSSION: Default simulation complexity level (minimal/basic/detailed)NEEDS TEAM DISCUSSION: Ghost prediction accuracy vs performance trade-offsNEEDS TEAM DISCUSSION: Visual design for ghost representation (transparency, colors, indicators)<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/state-management.md\" data-href=\"architecture/general/state-management.md\" href=\"architecture/general/state-management.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">state-management</a>: PROPOSED SYSTEM: Unified state management approach serves both single-player and multiplayerNEEDS TEAM DISCUSSION: Snapshot retention policy (current proposal: 5 seconds)NEEDS TEAM DISCUSSION: Delta compression vs full snapshot frequency (current proposal: every 60 frames)NEEDS TEAM DISCUSSION: Rollback window limits for client prediction<br><a data-tooltip-position=\"top\" aria-label=\"architecture/general/variable-timing.md\" data-href=\"architecture/general/variable-timing.md\" href=\"architecture/general/variable-timing.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">variable-timing</a>: PROPOSED SYSTEM: Time slice scheduling system enables variable player action timingNEEDS TEAM DISCUSSION: Optimal slice count (current proposal: 8 slices per frame)NEEDS TEAM DISCUSSION: Speed multiplier ranges (current proposal: 0.1x to 10x)NEEDS TEAM DISCUSSION: Ghost prediction complexity vs performance trade-offs\nFiles by Status Implementation Tasks\nDataview: No results to show for list query.\nTesting Tasks\nDataview: No results to show for list query.\nDiscussion Items\nDataview: No results to show for list query.\nResearch Items\nDataview: No results to show for list query.\nDocumentation Tasks\nDataview: No results to show for list query.\nReview Tasks\nDataview: No results to show for list query.\nProposed Systems\nDataview: No results to show for list query.\nOutdated Documents\nDataview: No results to show for list query.\nBreaking Changes\nDataview: No results to show for list query.\nPerformance Concerns\nDataview: No results to show for list query.\nSecurity Concerns\nDataview: No results to show for list query.\nTechnical Debt\nDataview: No results to show for list query.\nStub Files Proposed Documents Outdated Documents <br>Note: This page automatically aggregates todos, warnings, and status information from frontmatter metadata across all documentation files. For complete documentation on how to use frontmatter fields (status, tags, todo categories, warning types) and integration with the documentation structure, see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"development/documentation_structure.html#Frontmatter Metadata\" data-href=\"DOCUMENTATION_STRUCTURE#Frontmatter Metadata\" aria-label=\"DOCUMENTATION_STRUCTURE > Frontmatter Metadata\" data-tooltip-position=\"top\" target=\"_self\">Frontmatter Metadata Documentation</a>.","aliases":[],"inlineTags":[],"frontmatterTags":["#Development","#TaskList"],"headers":[{"heading":"Development Task List","level":1,"id":"Development_Task_List_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"TODO Items by Category","level":2,"id":"TODO_Items_by_Category_0"},{"heading":"Warnings by Type","level":2,"id":"Warnings_by_Type_0"},{"heading":"Specific Status Views","level":2,"id":"Specific_Status_Views_0"}],"links":["architecture/general/data-flow.html","architecture/general/ghost-simulation.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/systems/config/config.html","architecture/systems/ui/ui.html","docs.html","architecture/systems/config/config.html","docs.html","architecture/general/ghost-simulation.html","architecture/general/state-management.html","architecture/systems/ui/ui.html","architecture/general/variable-timing.html","architecture/general/data-flow.html","architecture/general/ghost-simulation.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/general/data-flow.html","architecture/general/ghost-simulation.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/systems/config/config.html","docs.html","architecture/systems/ui/ui.html","architecture/systems/config/config.html","docs.html","architecture/systems/ui/ui.html","architecture/general/ghost-simulation.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/general/data-flow.html","development/documentation_structure.html#Frontmatter Metadata"],"author":"","coverImageURL":"","fullURL":"development/tasklist.html","pathToRoot":"..","attachments":[],"createdTime":1760388163742,"modifiedTime":1760388163742,"sourceSize":3526,"sourcePath":"development/tasklist.md","exportPath":"development/tasklist.html","showInTree":true,"treeOrder":60,"backlinks":["development/documentation_structure.html","development/development.html"],"type":"markdown"},"gameplay/core-mechanics.html":{"title":"core-mechanics","icon":"","description":"Elimination: Last player standing wins. Players are eliminated when their avatar tile is destroyed.Duration: Unlimited match length - games end only when elimination occurs\nPlayer Count: Variable player count, limited only by performance constraints\nReal-Time Execution: Continuous simulation without traditional turnsNon-Turn-Based: Game runs continuously with different processes at different frequencies\nPre-Planning: Players queue actions in advance\nExecution Timing: Player actions execute at regular intervals determined by game state\nDynamic Speed: Object movement speed controlled by time delays between tile position updates\nStatus Effects: Players can be slowed, frozen, or otherwise affected by spells and environmentPlayer → Spell → World → Player: Clear action consequence chain\nPlayer casts spell\nSpell affects world tiles and environment\nWorld changes affect all players through environmental interactions\nPlayer Tiles: Players exist as tiles on the object layer\nPhysics Only: Player avatars affected by physics (velocity, collisions, forces) but never transform into other tile types\nDamage System: Players can take damage and be destroyed but maintain their tile type while alive\nMovement: Players move using same physics system as other object layer tilesDamage Sources: Tiles can deal damage, apply slow effects, or other status conditions to players\nHealing: Either no healing mechanics, or healing through specific terrain tiles\nRegeneration Strategy: No health regeneration vs. tile-based healing zones (to be playtested)\nDestruction: Players eliminated when health reaches zero, but tile type never changesPhysics-Driven: Maps generated through built-in physics simulation and tile reactions\nEmergent Terrain: World evolves naturally through rule-based transformations\nDynamic Environment: Continuous world changes create evolving strategic opportunitiesStrategic Terrain: Different tile types provide tactical advantages and challenges\nReactive Tiles: Special tiles that explode, ignite, or transform when targeted by spells\nEnvironmental Interactions: Terrain affects tactical gameplay\nSpell-Terrain Synergy: Spells designed to interact meaningfully with terrain typesSize: To be determined through playtesting for optimal performance and gameplay balance\nPerformance Scaling: Map size limited by ability to maintain 60 FPS with active player countNo Scarcity: Unlimited mana flower regeneration - focus on timing and positioning over resource conservation\nMana Recharge: 3-turn recharge cycle provides natural pacing without creating resource pressureTile-Based Escalation: Environmental changes naturally create pressure and opportunities\nNo Regeneration Alternative: Potential no-healing system to ensure permanent consequences\nEnvironmental Pressure: Reactive terrain and ongoing world changes prevent static positioningBalanced Design: Spells designed for diverse strategies\nSituational Advantage: Different spells excel in different terrain and tactical situations\nNo Power Creep: Focus on interesting combinations rather than raw damage scaling\nTerrain Understanding: Learning different tile type behaviors\nSpell Combinations: Combining rune effects\nPositioning: Tactical movement and area control\nTiming: Execution of pre-planned actions at optimal moments\nEnvironmental Prediction: Anticipating world changes and terrain evolution\nSee cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/spells.html\" data-href=\"../architecture/systems/spells/spells\" aria-label=\"../architecture/systems/spells/spells\" data-tooltip-position=\"top\" target=\"_self\">Spell System</a> for complete spell mechanics.Element Mastery:\nUnderstanding 26 elements and geometric opposition structure\nRecognizing cancellation opportunities (complete, partial, Void)\nDefensive counter-element selection against opponents\nResource Management:\nMana flower spending patterns with 3-turn recharge cycles\nAction cooldown timing (cast/load/refresh decisions)\nRefresh action strategic use (tempo cost for pool cycling)\nDeck Construction:\nPre-match element focus vs diverse coverage decisions\nMana flower conversion optimization (2:1 trade-off)\nSingleton format encourages spell variety strategies\nTactical Execution:\nSlot/pool management (when to cast vs load)\nDirectional targeting precision\nRune overlap timing for combinations Rule Interactions: Complex behaviors arising from rule combinations\nAdaptive Strategy: Changing world state requires flexible tactical adaptation\nRisk/Reward: Curse system and aggressive positioning create choices\nLong-term Planning: Pre-planning system rewards strategic foresight\nElement Counter-Play: Geometric opposition creates natural counter-strategies\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Core Mechanics","level":1,"id":"Core_Mechanics_0"},{"heading":"Core Game Flow","level":2,"id":"Core_Game_Flow_0"},{"heading":"Victory Conditions","level":3,"id":"Victory_Conditions_0"},{"heading":"Match Structure","level":3,"id":"Match_Structure_0"},{"heading":"Player Action System","level":2,"id":"Player_Action_System_0"},{"heading":"Movement and Timing","level":3,"id":"Movement_and_Timing_0"},{"heading":"Action Flow Pattern","level":3,"id":"Action_Flow_Pattern_0"},{"heading":"Player Representation","level":2,"id":"Player_Representation_0"},{"heading":"Avatar System","level":3,"id":"Avatar_System_0"},{"heading":"Health and Damage","level":3,"id":"Health_and_Damage_0"},{"heading":"World Design","level":2,"id":"World_Design_0"},{"heading":"Map Generation","level":3,"id":"Map_Generation_0"},{"heading":"Terrain Strategy","level":3,"id":"Terrain_Strategy_0"},{"heading":"Map Constraints","level":3,"id":"Map_Constraints_0"},{"heading":"Balance and Progression","level":2,"id":"Balance_and_Progression_0"},{"heading":"Resource Management","level":3,"id":"Resource_Management_0"},{"heading":"Anti-Stalemate Mechanics","level":3,"id":"Anti-Stalemate_Mechanics_0"},{"heading":"Power Scaling","level":3,"id":"Power_Scaling_0"},{"heading":"Strategic Elements","level":2,"id":"Strategic_Elements_0"},{"heading":"Core Strategy Sources","level":3,"id":"Core_Strategy_Sources_0"},{"heading":"Spell System Strategy","level":3,"id":"Spell_System_Strategy_0"},{"heading":"Depth Mechanisms","level":3,"id":"Depth_Mechanisms_0"}],"links":["architecture/systems/spells/spells.html"],"author":"","coverImageURL":"","fullURL":"gameplay/core-mechanics.html","pathToRoot":"..","attachments":[],"createdTime":1760485873346,"modifiedTime":1760485873346,"sourceSize":5486,"sourcePath":"gameplay/core-mechanics.md","exportPath":"gameplay/core-mechanics.html","showInTree":true,"treeOrder":54,"backlinks":["gameplay/gameplay.html"],"type":"markdown"},"gameplay/gameplay.html":{"title":"gameplay","icon":"","description":"Core game mechanics, rules, and design philosophy for Reaction v2.\n<a class=\"internal-link\" data-href=\"core-mechanics.md\" href=\"gameplay/core-mechanics.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Core Mechanics - Victory conditions, timing, and elimination rules\nGenre: Real-time PvP grid-based spellcasting game\nVictory: Last player standing (avatar tile elimination)\nCore Loop: Cast spells → Place runes → Transform environment → Tactical positioningNon-Turn-Based: Continuous simulation without traditional turns\nPre-Planning: Players can queue actions in advance\nDynamic Speed: Movement controlled by time delays between position updatesReactive World: Spells transform terrain according to rule-based systems\nTerrain Types: Different tile types provide tactical advantages\nEvolving World: Continuous world changes create evolving opportunitiesNo Scarcity: Unlimited mana regeneration - focus on timing over conservation\nRecharge Timing: 3-turn recharge cycle provides natural rhythm\nAllocation Choice: Specialization vs. flexibility in mana allocation","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Gameplay Documentation","level":1,"id":"Gameplay_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Mechanics","level":3,"id":"Core_Mechanics_0"},{"heading":"Game Overview","level":2,"id":"Game_Overview_0"},{"heading":"Key Design Principles","level":2,"id":"Key_Design_Principles_0"},{"heading":"Real-Time Strategy","level":3,"id":"Real-Time_Strategy_0"},{"heading":"Environmental Focus","level":3,"id":"Environmental_Focus_0"},{"heading":"Resource Philosophy","level":3,"id":"Resource_Philosophy_0"}],"links":["gameplay/core-mechanics.html"],"author":"","coverImageURL":"","fullURL":"gameplay/gameplay.html","pathToRoot":"..","attachments":[],"createdTime":1760380506340,"modifiedTime":1760380506341,"sourceSize":1221,"sourcePath":"gameplay/gameplay.md","exportPath":"gameplay/gameplay.html","showInTree":true,"treeOrder":63,"backlinks":["docs.html","architecture/systems/systems.html","architecture/general/overview.html","index.html"],"type":"markdown"},"legacy/legacy.html":{"title":"legacy","icon":"","description":"Analysis of V1 system concepts and algorithms to inform V2 development decisions.\n<a class=\"internal-link\" data-href=\"v1-reference.md\" href=\"legacy/v1-reference.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 Rules Engine Reference - Mathematical algorithms and GPU optimization from rules system\n<br><a class=\"internal-link\" data-href=\"v1-environmental-examples.md\" href=\"legacy/v1-environmental-examples.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 Environmental Examples - Terrain interaction patterns and emergent behaviors\n<br><a class=\"internal-link\" data-href=\"v1-gpu-patterns.md\" href=\"legacy/v1-gpu-patterns.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 GPU Optimization Patterns - Compute shader strategies and memory management\n<br><a class=\"internal-link\" data-href=\"v1-visual-effects.md\" href=\"legacy/v1-visual-effects.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 Visual Effects - Rendering techniques and material systems\n<br><a class=\"internal-link\" data-href=\"v1-data-strategies.md\" href=\"legacy/v1-data-strategies.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>V1 Data Packing Strategies - Data organization and bit-packing techniques\nReference material extracted from V1 codebase to ensure V2 developers understand the complexity and sophistication of systems being replaced. ","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Legacy V1 Reference Documentation","level":1,"id":"Legacy_V1_Reference_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"System Analysis","level":3,"id":"System_Analysis_0"},{"heading":"Purpose","level":2,"id":"Purpose_0"}],"links":["legacy/v1-reference.html","legacy/v1-environmental-examples.html","legacy/v1-gpu-patterns.html","legacy/v1-visual-effects.html","legacy/v1-data-strategies.html"],"author":"","coverImageURL":"","fullURL":"legacy/legacy.html","pathToRoot":"..","attachments":[],"createdTime":1760380506341,"modifiedTime":1760380506342,"sourceSize":878,"sourcePath":"legacy/legacy.md","exportPath":"legacy/legacy.html","showInTree":true,"treeOrder":65,"backlinks":["docs.html","architecture/systems/systems.html","index.html"],"type":"markdown"},"legacy/v1-data-strategies.html":{"title":"v1-data-strategies","icon":"","description":"This document captures data organization and packing techniques from V1 to inform V2's bit-packed tile system design. V1 demonstrated sophisticated GPU-optimized data structures that V2 developers should understand when designing the core engine's tile storage.Source: Analysis of V1 data structures (src/rules/rules.ts, src/core/types.ts, src/graphics/shaders/reaction.wgsl)\nStatus: Reference material for V2 data architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 data structures and hasn't been reviewed by the team.V1 Architecture: Rules stored as packed data in 128×128 GPU textureTexture format: r32uint (32-bit unsigned integers)\nTotal capacity: 16,384 × 32 bits = 64KB rule storage\nOrganization: 4 u32s horizontally per tile type, 16 vertically per reaction\nSpatial Organization Pattern:X-axis: tile_type * 4 + data_column (0-3)\nY-axis: reaction_index * 16 + condition_index (0-15)\nData access: textureLoad(rules, vec2u(x_coord, y_coord))\nPersonal Assessment: This layout optimized GPU cache access for spatially-related rule queries.My Interpretation: The 4×16 block per reaction ensured related data stayed within GPU cache lines.V1 Condition Data Format (9 bits per leaf condition):Bit allocation:\n- Tile type: 5 bits (0-31, accommodating enum value 20 for sand)\n- Direction: 3 bits (8 compass directions) - Distance: 1 bit (1 or 2 tiles away) Packing formula: (tile_type &lt;&lt; 4) | (direction &lt;&lt; 1) | distance_bit\nPersonal Observation: This encoding maximized information density while staying within GPU bit manipulation capabilities.V1 Internal Node Encoding (2 bits per operator):Operator types: AND=0, OR=1, NOR=2, NAND=3\nPacked format: 7 operators × 2 bits = 14 bits total\nStorage: Combined with condition value in single u32\nMy Assessment: This allowed complex logical trees in minimal memory.V1 Reaction Block Format (4 u32s × 16 conditions):u32[0]: (modes &lt;&lt; 15) | (value &lt;&lt; 10) | (bias &lt;&lt; 5) | result_tile\nu32[1]: leaf_conditions[0,1,2] packed as 3×9 bits + padding\nu32[2]: leaf_conditions[3,4,5] packed as 3×9 bits + padding u32[3]: leaf_conditions[6,7,8] packed as 3×9 bits + padding\nPersonal Note: This distributed related data across multiple texture coordinates while maintaining efficient access.Packed Leaf Storage (3 conditions per u32):Bit layout per u32: [condition2][condition1][condition0][padding]\nBit offsets: 0, 9, 18 bits (LSB-first packing)\nExtraction: (packed_data &gt;&gt; bit_offset) &amp; 0b111111111\nMy Interpretation: This maximized data density while allowing parallel condition evaluation.Contributor: Claude Status: Individual analysis of data flowPersonal Addition: These data access observations haven't been discussed with the team.V1 Rule Loading Strategy: Batch pre-fetch for condition evaluationRule queries per tile:\n- Base reaction data: 1 texture read (bias, result_tile, modes)\n- Leaf condition data: 3 texture reads (chunks 0-2, 3-5, 6-8)\n- Total per condition: 4 texture reads maximum\nPersonal Assessment: This minimized GPU memory bandwidth by batching related reads.Cache-Friendly Access Pattern:Spatial locality: Consecutive X coordinates for condition chunks\nTemporal locality: All rule data for one condition read together\nMemory coalescing: Adjacent GPU threads access adjacent texture coordinates\nMy Interpretation: V1 was designed around GPU memory hierarchy optimization.V1 Initialization Approach: Pre-populate with \"do nothing\" defaultsDefault leaf value: tile=31, direction=0, distance=1 (encoded as 496)\nDefault packed chunk: 3 leaves = 130,277,872\nDefault condition modes: value=0, modes=0 (AND tree)\nPersonal Observation: This eliminated special case handling during rule evaluation.Bounds Safety Pattern:Out-of-bounds behavior: Default values ensure safe evaluation\nMissing rules: \"Do nothing\" transformation (tile unchanged)\nInvalid data: Graceful degradation rather than crashes\nMy Assessment: This defensive programming approach ensured robust GPU execution.Contributor: Claude Status: Individual analysis needing validationPersonal Addition: These efficiency observations need team discussion for V2 design.V1 Rule Capacity (calculated from observed limits):Maximum tile types: 32 (5-bit encoding)\nMaximum reactions per type: 8\nMaximum conditions per reaction: 16\nMaximum tree complexity: 7 internal nodes + 8 leaves per condition\nStorage Efficiency:Bits per condition: 32 × 4 = 128 bits\nInformation density: ~9 bits condition data + 14 bits modes + 10 bits scoring\nUtilization: ~33 bits useful data / 128 bits storage ≈ 26% efficiency\nPersonal Assessment: V1 prioritized access speed over storage efficiency.My Interpretation: The 74% \"waste\" provided padding for GPU cache alignment and simplified addressing.V1 Memory Bandwidth Usage (estimated):Texture reads per tile evaluation:\n- Rule base data: 1 × 32 bits = 32 bits\n- Condition chunks: 3 × 32 bits = 96 bits - Shared cache reads: ~144 × 32 bits = 4,608 bits (amortized across workgroup)\nPersonal Calculation: ~128 bits rule data + ~72 bits shared cache per tileMy Assessment: V1's bandwidth usage was reasonable for the computational complexity achieved.V1 Scaling Limitations (observed):Rule texture size: Fixed 128×128 (no dynamic scaling)\nTile type limit: 32 types maximum (5-bit field)\nReaction complexity: 16 conditions maximum per reaction\nMemory usage: Linear with rule complexity\nPersonal Concern: V1's fixed limits might not scale to V2's ambitions.Research Questions:\nHow do V1's limits compare to V2's requirements?\nShould V2 use similar fixed-size allocations or dynamic scaling?\nContributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Approach: Complex multi-level packing with specialized extraction\nV2 Planned: Bit-packed tiles with ~6 bits type + velocity + custom dataPersonal Questions:\nShould V2 use V1's sophisticated bit manipulation techniques?\nHow will V2's 4-layer system affect packing complexity?\nWill V2's real-time requirements allow V1-style complex unpacking?\nMy Assessment: V2 might benefit from simpler packing schemes than V1's intricate system.V1 Evidence: GPU texture storage with cache-optimized layout\nV2 Plans: Texture ping-ponging with active region optimizationCompatibility Questions:\nCan V2's active regions use V1's texture organization principles?\nShould V2 pre-allocate like V1 or use dynamic allocation?\nHow do V2's performance targets compare to V1's memory usage patterns?\nTeam Discussion Needed: Memory allocation strategy for V2's different requirements.V1 Approach: Maximum density through complex bit manipulation\nV2 Considerations: Balance between efficiency and implementation complexityPersonal Assessment: V1's approach was sophisticated but complex to implement and debug.Research Needed: Whether V2's requirements justify V1-level complexity.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific data design considerations for V2.V1 Evidence: Complex packing achieved high data density and good GPU performance\nV2 Trade-offs: Implementation complexity vs memory/performance benefitsResearch Questions:\nWhat are V2's memory constraints compared to V1?\nHow important is V1-level data density for V2's goals?\nShould V2 prioritize development simplicity or runtime efficiency?\nTeam Discussion Needed: Performance requirements vs implementation complexity balance.V1 Success: Texture-based storage with spatial organization\nV2 Considerations: How to adapt V1's principles to V2's 4-layer systemDesign Questions:\nShould V2 layers share V1's texture organization approach?\nHow do V2's physics requirements affect data layout needs?\nWill V2's active region system benefit from V1's spatial locality patterns?\nPersonal Assessment: V2 should consider adapting V1's spatial organization principles.V1 Limitations: Fixed sizes and hardcoded limits\nV2 Opportunities: More flexible systems while preserving V1's efficiencyResearch Areas:\nDynamic data allocation vs V1's pre-allocation approach\nConfigurable complexity limits vs V1's hardcoded maximums\nRuntime data modification vs V1's compile-time rule baking\nTeam Input Needed: V2's flexibility requirements vs performance constraints.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These data architecture recommendations need team review before consideration.\nSpatial data organization for GPU cache efficiency\nBatch data access to minimize memory bandwidth\nDefault value strategies for robust error handling\nBit-level packing where density justifies complexity Layer-aware organization for V2's 4-layer tile system\nActive region integration with V1's spatial locality principles\nFlexible scaling beyond V1's fixed limits\nSimplified packing for easier development while preserving core efficiency Dynamic allocation instead of V1's fixed texture sizes\nConfigurable complexity instead of hardcoded limits\nDevelopment tools for debugging complex data structures\nPerformance monitoring for data access pattern optimization\nStatus: All recommendations need team evaluation and data architecture planning.Personal Suggestions (not discussed with team):\nPrototype V2 bit-packing using lessons from V1's techniques\nBenchmark data access patterns comparing V1 approaches with V2 requirements Design data validation tools to avoid V1's debugging complexity\nPlan scalability testing for V2's data structures under various load scenarios\nStatus: All suggestions need team review and core engine architecture planning.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"V1 Data Packing Strategies","level":1,"id":"V1_Data_Packing_Strategies_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Rule Data Packing System","level":2,"id":"👤_PERSONAL_V1_Rule_Data_Packing_System_0"},{"heading":"GPU Texture-Based Rule Storage","level":3,"id":"GPU_Texture-Based_Rule_Storage_0"},{"heading":"Bit-Level Data Encoding","level":3,"id":"Bit-Level_Data_Encoding_0"},{"heading":"Multi-Level Data Packing Strategy","level":3,"id":"Multi-Level_Data_Packing_Strategy_0"},{"heading":"👤 PERSONAL: V1 Memory Access Patterns","level":2,"id":"👤_PERSONAL_V1_Memory_Access_Patterns_0"},{"heading":"Texture Read Optimization","level":3,"id":"Texture_Read_Optimization_0"},{"heading":"Default Value Strategy","level":3,"id":"Default_Value_Strategy_0"},{"heading":"👤 PERSONAL: V1 Data Structure Efficiency","level":2,"id":"👤_PERSONAL_V1_Data_Structure_Efficiency_0"},{"heading":"Space Utilization Analysis","level":3,"id":"Space_Utilization_Analysis_0"},{"heading":"Access Pattern Efficiency","level":3,"id":"Access_Pattern_Efficiency_0"},{"heading":"Scalability Characteristics","level":3,"id":"Scalability_Characteristics_0"},{"heading":"👤 PERSONAL: V2 Data Design Implications","level":2,"id":"👤_PERSONAL_V2_Data_Design_Implications_0"},{"heading":"Bit-Packing Strategy Comparison","level":3,"id":"Bit-Packing_Strategy_Comparison_0"},{"heading":"Memory Architecture Decisions","level":3,"id":"Memory_Architecture_Decisions_0"},{"heading":"Data Density Vs Simplicity Trade-offs","level":3,"id":"Data_Density_Vs_Simplicity_Trade-offs_0"},{"heading":"🟠 RESEARCH: V2 Data Architecture Decisions","level":2,"id":"🟠_RESEARCH_V2_Data_Architecture_Decisions_0"},{"heading":"Packing Complexity Vs Performance","level":3,"id":"Packing_Complexity_Vs_Performance_0"},{"heading":"Data Layout Strategy","level":3,"id":"Data_Layout_Strategy_0"},{"heading":"Scalability and Flexibility","level":3,"id":"Scalability_and_Flexibility_0"},{"heading":"👤 PERSONAL: Recommendations for V2 Data Design","level":2,"id":"👤_PERSONAL_Recommendations_for_V2_Data_Design_0"},{"heading":"Preserve Effective V1 Concepts","level":3,"id":"Preserve_Effective_V1_Concepts_0"},{"heading":"Adapt V1 Patterns for V2","level":3,"id":"Adapt_V1_Patterns_for_V2_0"},{"heading":"Learn from V1 Limitations","level":3,"id":"Learn_from_V1_Limitations_0"},{"heading":"Next Steps for V2 Data Architecture","level":2,"id":"Next_Steps_for_V2_Data_Architecture_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-data-strategies.html","pathToRoot":"..","attachments":[],"createdTime":1760380506342,"modifiedTime":1760389062738,"sourceSize":11299,"sourcePath":"legacy/v1-data-strategies.md","exportPath":"legacy/v1-data-strategies.html","showInTree":true,"treeOrder":66,"backlinks":["legacy/legacy.html"],"type":"markdown"},"legacy/v1-environmental-examples.html":{"title":"v1-environmental-examples","icon":"","description":"This document captures environmental interaction patterns from V1 to inform V2 rule design. These examples demonstrate the complexity and emergent behaviors that V2's JSON compilation system should be capable of expressing.Source: Analysis of V1 game logic examples (src/game.ts lines 48-158)\nStatus: Reference patterns for V2 rule creationContributor: Claude Status: Individual analysis of V1 examplesPersonal Addition: This analysis of V1's environmental behaviors hasn't been discussed with the team.V1 Pattern Observed: Complex water behavior through multiple condition typesWater Flow Detection:Condition: Water north (distance 1) AND Water north (distance 2) AND NOT (Water northwest OR Water northeast)\nPersonal Interpretation: This created directional water flow by detecting \"channels\" without side branching.Water Pooling Detection:Condition: (Water north distance 1 OR 2) AND (Water east distance 1 OR 2) AND (Water south distance 1 OR 2)\nMy Assessment: This detected water collecting in corners or depressions.Water Pressure/Volume Detection:Condition: Water north AND Water east AND Water northeast AND (Water northwest OR Water southeast)\nPersonal Note: This seemed to detect \"enough water pressure\" for certain transformations.V1 Grass-to-Mud Pattern:\nTrigger: Close to water (bias: +4, total reaction bias: -3)\nResult: Net positive when water adjacent\nBehavior: Grass becomes mud near water sources\nV1 Mud-to-Water Pattern:\nMultiple conditions: Water flow (+2), surrounded by water (+2), close to water (+5), close to sand (+2)\nBase bias: -6 (requires multiple conditions to trigger)\nBehavior: Mud liquefies under water pressure\nV1 Mud-to-Grass Recovery:\nNegative conditions: Close to water (-2), kind of close to water (-1), close to mud (-1)\nBase bias: +2\nBehavior: Mud dries to grass when water recedes\nPersonal Observation: This created realistic seasonal or drought cycles in terrain.V1 Water-to-Sand Pattern:\nNegative scoring: All water-related conditions had negative values\nBase bias: -1\nInterpretation: Water became sand only when \"water pressure\" was low\nV1 Sand-to-Water Pattern:\nCondition: Surrounded by water (+2)\nBase bias: -1\nBehavior: Sand eroded when completely surrounded\nV1 Sand-to-Grass Colonization:\nCondition: Lots of grass nearby (+3)\nBase bias: -2\nBehavior: Vegetation gradually reclaimed sandy areas\nPersonal Assessment: This created believable geological processes.V1 Lava Spread Pattern:Condition: Lava northwest AND Lava northeast AND Lava north Pattern: Required 3 adjacent lava tiles in a row formation\nTarget: Grass tiles (turning them to lava)\nBase bias: -1 (requiring the specific pattern to overcome)\nPersonal Interpretation: This created lava \"fronts\" that advanced in lines rather than randomly.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These behavioral observations need team discussion for V2 design.Multiple Transformations per Tile Type: V1 allowed each tile type to have multiple possible reactions with different conditions.Example - Grass Tile Transformations:\nGrass → Mud (when near water)\nGrass → Lava (when in lava line formation) Grass → Sand (when conditions met - though this was commented out)\nPersonal Observation: This created realistic environmental competition where multiple forces could affect the same terrain.Observed Pattern: Mud ↔ Grass ↔ Sand cycles\nWet seasons: Grass → Mud → Water\nDry seasons: Water → Sand, Mud → Grass\nVegetation recovery: Sand → Grass (slow colonization)\nPersonal Assessment: V1's bias system created natural environmental cycles without explicit seasonal programming.Pattern: Many transformations required specific neighbor counts or arrangements\nWater flow: Exactly the right configuration\nLava spread: 3-tile line formation required\nVegetation growth: Multiple grass neighbors needed\nMy Interpretation: This prevented chaotic transformations and created stable intermediate states.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.Observed V1 Complexity:\nConditions checking multiple directions and distances\nLogical combinations with AND, OR, NOT operators\nNegative scoring for inhibitory effects\nDistance-based neighbor detection (1 and 2 tiles away)\nPersonal Question: Can V2's JSON format express this level of spatial complexity?Example V1 Rule Expressed in Potential V2 JSON:{ \"grass\": [ { \"id\": \"WaterFlow_Erosion\", \"action\": {\"type\": \"SetType\", \"new_type\": \"mud\"}, \"score_calculation\": { \"type\": \"Add\", \"children\": [ {\"type\": \"Constant\", \"value\": -3}, { \"type\": \"BooleanToValue\", \"condition\": { \"type\": \"AND\", \"children\": [ {\"type\": \"TileAt\", \"tile\": \"water\", \"direction\": \"N\", \"distance\": 1}, {\"type\": \"TileAt\", \"tile\": \"water\", \"direction\": \"N\", \"distance\": 2}, { \"type\": \"NOT\", \"child\": { \"type\": \"OR\", \"children\": [ {\"type\": \"TileAt\", \"tile\": \"water\", \"direction\": \"NW\", \"distance\": 1}, {\"type\": \"TileAt\", \"tile\": \"water\", \"direction\": \"NE\", \"distance\": 1} ] } } ] }, \"value_if_true\": 4, \"value_if_false\": 0 } ] } } ]\n}\nPersonal Concern: This JSON is already complex for a single V1 condition. V1 reactions had up to 16 conditions.V1 Optimization Evidence: Rules were pre-compiled into GPU textures\nComplex conditions evaluated in parallel across all tiles\nShared memory caching for neighbor access\nPersonal Assessment: V2 needs comparable optimization strategies for similar environmental complexity.Research Needed: Performance testing of JSON compilation vs V1's direct GPU implementation.Identified by: Claude Status: Team input neededPersonal Assessment: V1 examples suggest specific environmental behavior goals that V2 should validate.\nGeological cycles: Water erosion, sediment deposition, vegetation recovery\nCompetitive dynamics: Multiple environmental forces affecting same areas\nThreshold stability: Avoiding chaotic oscillations between states\nDirectional flow: Water and lava following realistic propagation patterns\nTeam Discussion Needed: Should V2 target similar environmental realism?\nHow important are complex multi-condition interactions?\nWhat level of rule complexity should V2 support?\nV1 Evidence: Creating realistic environmental behaviors required intricate condition combinations and careful bias tuning.Personal Question: Will V2's visual editor be capable of creating rules of similar sophistication?Research Needed: UI/UX design for complex rule creation without overwhelming users.Personal Recommendations (not discussed with team):\nUse V1 patterns as test cases for V2 JSON compilation system\nCreate V2 equivalents of key V1 environmental behaviors\nValidate rule complexity limits early in V2 development\nDesign rule editor to handle spatial complexity observed in V1\nStatus: All recommendations need team review and design discussion.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Environmental Interaction Examples","level":1,"id":"Environmental_Interaction_Examples_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Terrain Interaction Patterns","level":2,"id":"👤_PERSONAL_V1_Terrain_Interaction_Patterns_0"},{"heading":"Water Flow and Pooling Systems","level":3,"id":"Water_Flow_and_Pooling_Systems_0"},{"heading":"Mud Formation and Transformation","level":3,"id":"Mud_Formation_and_Transformation_0"},{"heading":"Sand Erosion and Deposition","level":3,"id":"Sand_Erosion_and_Deposition_0"},{"heading":"Fire and Lava Propagation","level":3,"id":"Fire_and_Lava_Propagation_0"},{"heading":"👤 PERSONAL: Emergent Behavior Patterns","level":2,"id":"👤_PERSONAL_Emergent_Behavior_Patterns_0"},{"heading":"Competitive Environmental Dynamics","level":3,"id":"Competitive_Environmental_Dynamics_0"},{"heading":"Seasonal and Cyclical Behaviors","level":3,"id":"Seasonal_and_Cyclical_Behaviors_0"},{"heading":"Threshold-Based State Changes","level":3,"id":"Threshold-Based_State_Changes_0"},{"heading":"👤 PERSONAL: V2 Design Implications","level":2,"id":"👤_PERSONAL_V2_Design_Implications_0"},{"heading":"Rule Complexity Requirements","level":3,"id":"Rule_Complexity_Requirements_0"},{"heading":"Performance Considerations","level":3,"id":"Performance_Considerations_0"},{"heading":"🟠 RESEARCH: Environmental Behavior Validation","level":2,"id":"🟠_RESEARCH_Environmental_Behavior_Validation_0"},{"heading":"Behavior Realism Targets","level":3,"id":"Behavior_Realism_Targets_0"},{"heading":"Rule Authoring Complexity","level":3,"id":"Rule_Authoring_Complexity_0"},{"heading":"Next Steps for V2 Examples","level":2,"id":"Next_Steps_for_V2_Examples_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-environmental-examples.html","pathToRoot":"..","attachments":[],"createdTime":1760380506342,"modifiedTime":1760380506342,"sourceSize":8492,"sourcePath":"legacy/v1-environmental-examples.md","exportPath":"legacy/v1-environmental-examples.html","showInTree":true,"treeOrder":67,"backlinks":["legacy/legacy.html"],"type":"markdown"},"legacy/v1-gpu-patterns.html":{"title":"v1-gpu-patterns","icon":"","description":"This document captures GPU optimization strategies from V1 to inform V2 compute shader design. V1's reaction compute shader contained sophisticated optimization patterns that V2 developers should understand when designing the core engine's GPU architecture.Source: Analysis of V1 compute shader (src/graphics/shaders/reaction.wgsl)\nStatus: Reference material for V2 GPU architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 GPU code and hasn't been reviewed by the team.V1 Pattern Observed: Sophisticated neighborhood caching systemWorkgroup size: 8×8 threads (64 total)\nCache dimensions: 12×12 tiles (144 total)\nBorder padding: 2 tiles in each direction\nMemory layout: array&lt;array&lt;u32, 12&gt;, 12&gt;\nCaching Algorithm:\nEach thread loads multiple cache pixels (144 pixels ÷ 64 threads = ~2.25 pixels per thread)\nLinear cache index distribution across threads\nWrap-around coordinate calculation for world boundaries\nWorkgroup barrier synchronization before shared memory reads\nPersonal Assessment: This eliminated redundant texture reads for neighbor checks, likely providing significant performance benefits.My Interpretation: The 2-tile border allowed checking neighbors at distance 1 and 2 without additional texture fetches.V1 Coordinate Calculation Pattern:Global origin: workgroup_id * workgroup_size - cache_offset\nLinear thread mapping: local_id.y * workgroup_size_x + local_id.x Wrap-around handling: (coord % tex_dims + tex_dims) % tex_dims\nPersonal Observation: This avoided branching and handled torus world topology efficiently.Cache Access Pattern:Cache position: local_coordinate + cache_offset + relative_neighbor_offset\nNo bounds checking: Relied on cache being large enough for all valid accesses\nMy Assessment: This trusted the cache dimensions to handle all possible neighbor accesses within the 2-tile radius.V1 Pattern: Dual texture approach for race condition prevention\nInput texture: Read-only during compute pass\nOutput texture: Write-only during compute pass Swap textures between frames\nPersonal Note: This matches V2's planned ping-ponging strategy, validating the approach.Contributor: Claude Status: Individual analysis of GPU optimizationPersonal Addition: These observations from V1's data access patterns haven't been discussed with the team.V1 Approach: Minimize texture reads through strategic batchingRule data chunks: 3 texture reads for 9 leaf conditions (3 conditions per u32)\nChunk storage: array&lt;u32, 3&gt; for indexed access\nPre-computation: All rule data loaded before tree evaluation\nPersonal Interpretation: This reduced GPU memory bandwidth usage by batching related data.My Assessment: V2's rule compilation should consider similar data locality optimization.V1 Pattern: Efficient tree traversal without recursionNode results array: Fixed-size array for all tree nodes\nBottom-up evaluation: Leaves first (indices 7-15), then internal nodes (6 down to 0)\nLoop-based traversal: Avoided GPU recursion limitations\nPersonal Note: This was a clever solution to GPU architectural constraints.My Concern: V2's JSON compilation needs similar tree evaluation efficiency.V1 Optimization: Early exit on symmetry successSymmetry loop: 8 iterations (rotations and reflections)\nEarly termination: Break immediately when any symmetry evaluates true\nResult aggregation: OR operation across all symmetries\nPersonal Assessment: This reduced unnecessary computation when patterns matched early.What I Don't Know: Whether V2's compiled rules will include similar short-circuit optimizations.Contributor: Claude Status: Individual analysis of GPU synchronizationPersonal Addition: These synchronization observations need team consideration for V2.V1 Processing Phases:\nCache Loading Phase: All threads cooperatively load neighborhood data\nSynchronization Barrier: workgroupBarrier() ensures cache completion\nIndependent Processing Phase: Each thread processes its assigned tile\nPersonal Observation: Clear separation between cooperative and independent work.My Interpretation: This maximized GPU efficiency by aligning with hardware capabilities.V1 Cache Loading Strategy:Work distribution: (cache_pixels + num_threads - 1) / num_threads // Ceiling division\nLoad balancing: Each thread loads 0-3 cache pixels depending on position\nBounds checking: Prevents threads from loading beyond cache dimensions\nPersonal Assessment: This ensured even work distribution across the workgroup.My Note: V2 should consider similar load balancing for any cooperative operations.V1 Synchronization Points:\nSingle workgroupBarrier() after cache loading\nNo additional barriers during tree evaluation\nIndependent tile processing without cross-thread communication\nPersonal Interpretation: Minimal synchronization overhead while ensuring data consistency.Personal Question: Will V2's active region system require additional synchronization?Contributor: Claude Status: Individual assessment needing team discussionPersonal Addition: These performance observations haven't been validated with actual measurements.V1 Work per Tile:\nReaction evaluation: Up to 8 reactions per tile type\nCondition evaluation: Up to 16 conditions per reaction Symmetry testing: 8 geometric transformations per condition\nTree traversal: 7 internal nodes + 8 leaf evaluations\nPersonal Calculation: Worst case ~8×16×8×15 = 15,360 operations per tileMy Assessment: This suggests V1 could handle very complex environmental behaviors, but at computational cost.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations.V1 Memory Footprint per Workgroup:\nShared cache: 144 × 32-bit = 576 bytes\nNode results array: 16 × 1-bit = 2 bytes (negligible)\nRule data cache: 3 × 32-bit = 12 bytes per condition\nPersonal Note: Shared memory usage was well within typical GPU limits.What I Don't Know: How V2's bit-packed tile format will affect memory access patterns.V1 Texture Access Patterns:\nInput texture reads: 1 per cache pixel (coalesced across workgroup)\nRules texture reads: 4 per tile (base + 3 condition chunks)\nOutput texture writes: 1 per tile\nNeighbor access: From cache (no additional texture reads)\nPersonal Assessment: Well-optimized memory access pattern with minimal bandwidth waste.My Concern: V2's 4-layer system may increase memory bandwidth requirements.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific GPU architecture considerations for V2.V1 Evidence: 8×8 workgroups with 12×12 cache worked well for 2-tile radius operationsResearch Questions for V2:\nShould V2 use similar workgroup dimensions?\nHow does V2's active region system (32×32 chunks) align with workgroup sizes?\nWill V2's tile operations require different neighbor access patterns?\nTeam Discussion Needed: Workgroup sizing based on V2's specific requirements.V1 Strategy: Heavy use of workgroup shared memory for cachingV2 Considerations:\nDoes V2's 4-layer system benefit from similar caching?\nShould V2 cache active region metadata in shared memory?\nHow do V2's bit-packed tiles affect cache efficiency?\nResearch Needed: Performance testing of V2 memory access patterns.V1 Evidence: Minimal synchronization (single barrier) provided good performanceV2 Questions:\nWill V2's physics integration require additional synchronization?\nDoes V2's active region updating need workgroup coordination?\nShould V2 pipeline different processing phases differently?\nPersonal Assessment: V2 may need more complex synchronization than V1.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These design recommendations need team review before consideration.\nWorkgroup shared memory caching for neighbor access optimization\nPhase-based processing with clear synchronization points Early exit optimizations where applicable\nTexture ping-ponging (already planned for V2) Scale caching strategy for V2's 4-layer tile system\nIntegrate active region optimization with V1's workgroup patterns\nConsider rule compilation targeting similar GPU optimization patterns Complexity vs Performance: V1 handled very complex rules - should V2 target similar capability?\nMemory vs Computation: V1 used memory to reduce computation - is this optimal for V2?\nSynchronization Overhead: Will V2's additional systems require more GPU barriers?\nStatus: All recommendations need team evaluation and design discussion.Personal Suggestions (not discussed with team):\nPrototype V2 compute shaders using V1 optimization patterns as starting point\nBenchmark memory access patterns for V2's bit-packed 4-layer system\nDesign active region processing to leverage V1's workgroup coordination strategies\nTest synchronization requirements for V2's multi-system integration\nStatus: All suggestions need team review and implementation planning.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"V1 GPU Optimization Patterns","level":1,"id":"V1_GPU_Optimization_Patterns_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Memory Architecture Patterns","level":2,"id":"👤_PERSONAL_V1_Memory_Architecture_Patterns_0"},{"heading":"Workgroup Shared Memory Strategy","level":3,"id":"Workgroup_Shared_Memory_Strategy_0"},{"heading":"Memory Access Optimization","level":3,"id":"Memory_Access_Optimization_0"},{"heading":"Texture Ping-Ponging Implementation","level":3,"id":"Texture_Ping-Ponging_Implementation_0"},{"heading":"👤 PERSONAL: V1 Data Pre-fetching Strategies","level":2,"id":"👤_PERSONAL_V1_Data_Pre-fetching_Strategies_0"},{"heading":"Rule Data Batching","level":3,"id":"Rule_Data_Batching_0"},{"heading":"Condition Tree Evaluation Optimization","level":3,"id":"Condition_Tree_Evaluation_Optimization_0"},{"heading":"Symmetry Evaluation Batching","level":3,"id":"Symmetry_Evaluation_Batching_0"},{"heading":"👤 PERSONAL: V1 Workgroup Coordination Patterns","level":2,"id":"👤_PERSONAL_V1_Workgroup_Coordination_Patterns_0"},{"heading":"Phase-Based Processing","level":3,"id":"Phase-Based_Processing_0"},{"heading":"Thread Work Distribution","level":3,"id":"Thread_Work_Distribution_0"},{"heading":"Memory Barrier Usage","level":3,"id":"Memory_Barrier_Usage_0"},{"heading":"👤 PERSONAL: V1 Performance Characteristics","level":2,"id":"👤_PERSONAL_V1_Performance_Characteristics_0"},{"heading":"Computational Complexity Patterns","level":3,"id":"Computational_Complexity_Patterns_0"},{"heading":"Memory Usage Patterns","level":3,"id":"Memory_Usage_Patterns_0"},{"heading":"Bandwidth Optimization Evidence","level":3,"id":"Bandwidth_Optimization_Evidence_0"},{"heading":"🟠 RESEARCH: V2 GPU Architecture Implications","level":2,"id":"🟠_RESEARCH_V2_GPU_Architecture_Implications_0"},{"heading":"Workgroup Size Decisions","level":3,"id":"Workgroup_Size_Decisions_0"},{"heading":"Memory Architecture Choices","level":3,"id":"Memory_Architecture_Choices_0"},{"heading":"Synchronization Requirements","level":3,"id":"Synchronization_Requirements_0"},{"heading":"👤 PERSONAL: Recommendations for V2 GPU Design","level":2,"id":"👤_PERSONAL_Recommendations_for_V2_GPU_Design_0"},{"heading":"Preserve Effective V1 Patterns","level":3,"id":"Preserve_Effective_V1_Patterns_0"},{"heading":"Adapt V1 Concepts for V2","level":3,"id":"Adapt_V1_Concepts_for_V2_0"},{"heading":"Research V1 Vs V2 Trade-offs","level":3,"id":"Research_V1_Vs_V2_Trade-offs_0"},{"heading":"Next Steps for V2 GPU Architecture","level":2,"id":"Next_Steps_for_V2_GPU_Architecture_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-gpu-patterns.html","pathToRoot":"..","attachments":[],"createdTime":1760380506343,"modifiedTime":1760389062736,"sourceSize":10531,"sourcePath":"legacy/v1-gpu-patterns.md","exportPath":"legacy/v1-gpu-patterns.html","showInTree":true,"treeOrder":68,"backlinks":["legacy/legacy.html"],"type":"markdown"},"legacy/v1-reference.html":{"title":"v1-reference","icon":"","description":"This document captures fundamental concepts and mathematical algorithms from the V1 rules engine to inform V2 development. V1 contained sophisticated rule evaluation systems that V2 developers should understand when designing the JSON compilation pipeline.Source: Analysis of V1 legacy codebase (archived)\nStatus: Reference material for V2 design considerationContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 code and hasn't been reviewed by the team.V1 Approach: Rules were evaluated across 8 geometric transformations (4 rotations × 2 reflections) to create symmetric environmental behaviors.Mathematical Pattern Observed:Rotation calculation: (symmetry &gt;&gt; 1u) &lt;&lt; 1u // Even number rotations\nReflection: select(1, -1, (symmetry &amp; 1u) != 0u) // Flip on odd symmetries\nFinal position: scale * flip * base_direction_vector\nMy Assessment: This created natural-looking environmental effects where fire spreading, water flow, etc. worked consistently in all directions.Personal Concern: V2's JSON compilation needs to handle similar geometric transformations or environmental effects may look artificial.V1 Pattern: Complex conditions organized as binary trees with packed evaluation:\n7 internal nodes (operators: AND, OR, NOR, NAND)\n8 leaf nodes (spatial conditions)\nBottom-up evaluation from leaves to root\nData Packing Observed:\nInternal node modes: 2 bits each, packed into 14 bits total\nLeaf conditions: 9 bits each (5-bit tile type, 3-bit direction, 1-bit distance)\nEvaluation results: Boolean array with indices mapping to tree structure\nMy Interpretation: This allowed arbitrarily complex logical conditions while maintaining GPU efficiency.Personal Question: How will V2's JSON compilation achieve similar complexity without runtime memory overhead?V1 Bias System:\nBase reaction bias: signed 5-bit value (-16 to +15)\nCondition contributions: signed values added when conditions met\nWinning rule: highest total score after all conditions evaluated\nPersonal Observation: This created emergent behaviors where multiple environmental effects competed naturally (e.g., fire spreading vs water extinguishing).What I Don't Know: Whether V2's competitive scoring will replicate this mathematical sophistication.Contributor: Claude Status: Individual analysis of compute shaderPersonal Addition: These observations from V1's GPU implementation haven't been discussed with the team.V1 Pattern: 12×12 shared memory cache for 8×8 workgroup with 2-tile border\nEach thread loads multiple cache pixels to fill neighborhood\nWorkgroup barrier synchronization before condition evaluation\nEliminates redundant texture reads for neighbor checks\nMy Assessment: This optimization was sophisticated and likely provided significant performance benefits.Personal Concern: V2 GPU shader design should consider similar caching strategies.V1 Approach: Pre-computed direction offset arrays with wrap-around handlingDirection offsets: 8 compass directions as vec2i\nWrap-around: (global_coord % tex_dims + tex_dims) % tex_dims\nCache position: local_coord + cache_offset + relative_position\nPersonal Note: This handled world boundaries elegantly while maintaining cache efficiency.V1 Pattern: Batch-loaded rule data chunks before evaluation\n3 texture reads for all 9 possible leaf conditions\nStored in array for indexed access during tree evaluation\nMinimized GPU texture bandwidth usage\nMy Interpretation: This was a carefully optimized memory access pattern.Contributor: Claude Status: Questions identified from V1 analysisPersonal Assessment: These issues need team discussion based on V1 complexity:Question: How will V2's JSON compilation handle the mathematical sophistication of V1's binary tree evaluation and 8-fold symmetry?V1 Evidence: Rules could express conditions like \"fire spreads if 2+ fire neighbors AND no water within 2 tiles AND not in NW/NE corners\"My Concern: V2 JSON format may need significant complexity to match V1 expressiveness.Question: Will V2 replicate V1's shared memory optimizations or use different strategies?V1 Evidence: Complex workgroup coordination and cache management in compute shaderPersonal Assessment: V2 might benefit from studying V1's memory access patterns before designing new shaders.Question: How will V2 ensure deterministic evaluation order that V1 achieved?V1 Evidence: Strict tile-by-tile processing with consistent neighbor checking orderWhat I Don't Know: Whether V2's approach will maintain this level of determinism.Identified by: Claude Status: Team input neededPersonal Assessment: V1 performance characteristics need measurement, but patterns suggest optimization priorities.\n128×128 texture for rules (16,384 × 32-bit values = 64KB rule storage)\nWorkgroup shared memory: 144 × 32-bit values per workgroup\nDual texture ping-ponging: 2× map memory usage\nMy Interpretation: V1 traded memory for computational efficiency.Research Needed: Actual performance measurements and comparison with V2 targets.\n8 symmetry evaluations per condition\nBinary tree evaluation with up to 7 internal nodes\n16 conditions maximum per reaction\n8 reactions maximum per tile type\nPersonal Note: This suggests V1 could handle very complex environmental behaviors.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations for simplicity.Personal Recommendations (not discussed with team):\nStudy V1's mathematical patterns before finalizing JSON compilation approach\nConsider V1's GPU optimization strategies for V2 shader architecture Evaluate whether V2 competitive scoring can achieve V1's sophistication\nPlan for complexity testing to ensure V2 can handle intricate environmental behaviors\nStatus: All recommendations need team review and discussion.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"V1 Rules Engine Reference","level":1,"id":"V1_Rules_Engine_Reference_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Mathematical Concepts Worth Preserving","level":2,"id":"👤_PERSONAL_V1_Mathematical_Concepts_Worth_Preserving_0"},{"heading":"8-Fold Symmetry Evaluation System","level":3,"id":"8-Fold_Symmetry_Evaluation_System_0"},{"heading":"Binary Tree Condition Evaluation","level":3,"id":"Binary_Tree_Condition_Evaluation_0"},{"heading":"Competitive Scoring Mathematics","level":3,"id":"Competitive_Scoring_Mathematics_0"},{"heading":"👤 PERSONAL: V1 GPU Optimization Patterns","level":2,"id":"👤_PERSONAL_V1_GPU_Optimization_Patterns_0"},{"heading":"Workgroup Shared Memory Caching","level":3,"id":"Workgroup_Shared_Memory_Caching_0"},{"heading":"Neighbor Access Optimization","level":3,"id":"Neighbor_Access_Optimization_0"},{"heading":"Data Pre-fetching Strategy","level":3,"id":"Data_Pre-fetching_Strategy_0"},{"heading":"👤 PERSONAL: Critical Implementation Unknowns for V2","level":2,"id":"👤_PERSONAL_Critical_Implementation_Unknowns_for_V2_0"},{"heading":"Rule Complexity Handling","level":3,"id":"Rule_Complexity_Handling_0"},{"heading":"GPU Memory Architecture","level":3,"id":"GPU_Memory_Architecture_0"},{"heading":"Determinism Guarantees","level":3,"id":"Determinism_Guarantees_0"},{"heading":"🟠 RESEARCH: Performance Characteristics","level":2,"id":"🟠_RESEARCH_Performance_Characteristics_0"},{"heading":"Memory Usage Patterns Observed","level":3,"id":"Memory_Usage_Patterns_Observed_0"},{"heading":"Computational Complexity Patterns","level":3,"id":"Computational_Complexity_Patterns_0"},{"heading":"Next Steps for V2 Design","level":2,"id":"Next_Steps_for_V2_Design_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-reference.html","pathToRoot":"..","attachments":[],"createdTime":1760380506343,"modifiedTime":1760389062735,"sourceSize":6836,"sourcePath":"legacy/v1-reference.md","exportPath":"legacy/v1-reference.html","showInTree":true,"treeOrder":69,"backlinks":["legacy/legacy.html"],"type":"markdown"},"legacy/v1-visual-effects.html":{"title":"v1-visual-effects","icon":"","description":"This document captures visual rendering techniques from V1 to inform V2 renderer design. V1's render shader contained sophisticated visual effects that created distinct, animated appearances for different tile types.Source: Analysis of V1 render shader (src/graphics/shaders/render.wgsl)\nStatus: Reference material for V2 visual design decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 rendering code and hasn't been reviewed by the team.V1 Water Effect: Complex wave system using multiple sine functionsWave components (observed):\n- Wave 1: sin(worldUV.x * 3.2 + time * 1.03) * 0.5 (primary horizontal)\n- Wave 2: sin(worldUV.y * 14.0 - time * 1.3) * 0.25 (vertical fine)\n- Wave 3: sin(worldUV.y * 8.3 + time * 1.5) * 0.25 (vertical medium)\n- Wave 4: sin((worldUV.x + worldUV.y) * 13.7 - time * 0.8) * 0.15 (diagonal)\n- Wave 5: sin((2.43 * worldUV.x + 3.0 * worldUV.y) * 15.5 - time * 1.2) * 0.12 (complex)\n- Wave 6: sin((worldUV.x - 1.3 * worldUV.y) * 16.7 - time * 0.7) * 0.1 (counter-diagonal)\nPersonal Assessment: This created realistic water movement with multiple overlapping wave patterns.Color Blending System:Base colors: Deep blue (#0099CC) to cyan (#33CCFF)\nHeight mapping: Wave height influences color interpolation\nHighlight system: White foam on wave peaks using smoothstep\nMy Interpretation: The multi-wave approach created natural-looking water with depth variation.Personal Note: V2 should consider similar layered animation techniques for environmental immersion.V1 Grass Blade Technique: Individual blade rendering within each tileBlade positioning: Offset by sine(time + worldUV.y * 2) for wind effect\nBlade dimensions: Triangle-based blade shapes with height variation\nDual blade system: Two offset blade patterns per tile for density\nBlade Generation Algorithm:Blade coordinate mapping: (worldUV * 10) % 1 for repeating pattern\nBlade shape: 1 - abs(bladepos.x - 0.5) * 2 (triangle profile)\nHeight variation: bladepos.y-based cutting for blade tips\nWind animation: X-offset by sine function creates swaying\nPersonal Assessment: This created convincing grass appearance at the tile level.Color System:Base colors: Dark green (#1A4D33) to bright green (#19FF19)\nHeight-based mixing: Taller blade portions lighter\nHighlight integration: White highlights on blade tips\nMy Interpretation: The procedural approach provided detailed grass without requiring texture assets.V1 Lava Effect: Similar wave system to water but with different parametersWave pattern: Subset of water waves (4 components instead of 6)\nColor palette: Orange-red (#FF3300) to yellow-orange (#FFCC80)\nHighlight system: Pink-magenta highlights (#FF80FF) on wave peaks\nPersonal Observation: Lava reused water's animation framework with different visual parameters.My Assessment: This suggests V2 could use unified animation systems with material-specific parameters.V1 Noise Functions: Multiple noise layers for various effectsBasic Perlin: Standard 2D Perlin noise with gradient interpolation\nFractal Brownian Motion (FBM): 4 octaves of layered noise\nHash function: Deterministic pseudo-random for gradient generation\nNoise Applications Observed:\nMountain height maps with contour effects\nTerrain distortion for organic tile boundaries\nTexture variation within tile types\nPersonal Note: V2 should consider noise as a fundamental rendering primitive.V1 Distortion System: World UV coordinates modified by noiseDistortion calculation: Perlin noise at multiple scales\nApplication: UV += distortion_vector before tile sampling\nEffect: Organic, non-grid-aligned visual boundaries\nPersonal Assessment: This helped disguise the underlying grid structure.Tile Edge Softening:Distance calculation: max(abs(tileUV.x-0.5), abs(tileUV.y-0.5)) * 2 - 0.2\nFalloff function: 1 - pow(square_dist, 6.0)\nApplication: Multiply final color by falloff\nMy Interpretation: This created soft tile boundaries and visual cohesion.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These material observations need team consideration for V2 visual design.V1 Material Definitions:\nWater: Blue spectrum with white foam highlights\nLava: Orange-red spectrum with magenta highlights\nMagic: Purple-green spectrum (similar animation to water)\nGrass: Green spectrum with procedural blade geometry\nVoid: Animated mountain texture with brown/purple palette\nPersonal Observation: Each material had distinct color relationships and animation characteristics.My Assessment: V2 should define similar material systems for consistent visual identity.V1 Color Blend Patterns:Height-based interpolation: mix(deepColor, lightColor, height_factor)\nHighlight overlays: mix(baseColor, highlightColor, highlight_strength)\nTime-based variation: Colors influenced by animation state\nPersonal Note: This created natural-looking material variation without texture sampling.Material Property System (inferred):\nBase color ranges per material type\nAnimation amplitude and frequency per material\nHighlight color and trigger thresholds per material\nMy Interpretation: V2 could benefit from similar parameterized material systems.V1 Shader Efficiency Patterns:\nSwitch statement for tile type selection (GPU-friendly branching)\nShared mathematical functions across material types\nSingle-pass rendering with material-specific logic branches\nPersonal Assessment: V1 balanced visual complexity with rendering performance.Mathematical Function Reuse:\nPerlin noise used across multiple material types\nWave functions shared between water, lava, and magic\nColor interpolation patterns repeated across materials\nMy Note: V2 should consider similar function reuse for consistency and performance.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Evidence: Complex mathematical calculations per pixel (6-wave water system, procedural grass, multi-octave noise)Personal Questions for V2:\nShould V2 target similar visual complexity?\nHow will V2's 4-layer system affect rendering performance?\nWill V2 support material-specific animation systems?\nResearch Needed: Performance testing of V1-style effects with V2's architecture.V1 Approach: Hardcoded material properties in shader switch statementsV2 Considerations:\nShould V2 use similar hardcoded materials or data-driven systems?\nHow do V2's layers interact visually (transparency, blending)?\nWill V2 support runtime material customization?\nPersonal Assessment: V2 might benefit from more flexible material systems than V1's hardcoded approach.V1 Time Usage: Global time parameter for synchronized animations across all tilesV2 Questions:\nHow will V2 handle time synchronization across distributed processing?\nShould V2 support per-tile animation offsets for variety?\nWill V2's physics system affect visual animation timing?\nTeam Discussion Needed: Integration between V2's physics timing and visual animation.Identified by: Claude Status: Team input neededPersonal Assessment: V1's visual complexity suggests performance considerations for V2.V1 Per-Pixel Calculations (observed):\nWater: 6 sine function evaluations + color interpolation\nGrass: Blade geometry generation + multiple conditional branches\nNoise: 4-octave fractal calculation + hash function evaluations\nPersonal Calculation: Potentially 10-20 mathematical operations per pixel for complex materialsResearch Questions:\nWhat are V2's target performance characteristics?\nShould V2 support multiple detail levels for different devices?\nHow does V1's performance compare to V2's goals?\nTeam Discussion Needed: Visual quality vs performance trade-offs for V2.V1 Approach: Procedural generation without texture assets\nNo texture memory usage for material appearance\nAll effects generated mathematically in shader\nTime and UV coordinates as only inputs\nV2 Implications:\nShould V2 continue the fully-procedural approach?\nHow do V2's bit-packed tiles affect rendering pipeline?\nWill V2's 4-layer system require additional rendering passes?\nPersonal Assessment: V1's procedural approach was memory-efficient but computationally intensive.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These visual design recommendations need team review before consideration.\nMulti-wave animation systems for natural-looking environmental movement\nProcedural material generation for memory efficiency\nPerlin noise integration for organic visual variation\nMaterial-specific color palettes for visual distinction Layer-aware rendering for V2's 4-layer tile system\nMaterial property systems for easier customization than V1's hardcoded approach\nPerformance scaling for different device capabilities\nAnimation synchronization with V2's physics and reaction systems Visual complexity scaling - V1 effects were computationally expensive\nMaterial variety - V1 had limited material types compared to V2's ambitions\nLayer interaction - V1 was single-layer, V2 needs multi-layer visual compositing\nStatus: All recommendations need team evaluation and visual design discussion.Personal Suggestions (not discussed with team):\nPrototype V2 materials using V1 techniques as starting point\nTest rendering performance with V2's 4-layer system and V1-style effects\nDesign material property systems that provide V1's visual quality with more flexibility\nPlan animation integration with V2's physics and reaction timing\nStatus: All suggestions need team review and renderer architecture planning.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"V1 Visual Effects Reference","level":1,"id":"V1_Visual_Effects_Reference_0"},{"heading":"Purpose and Context","level":2,"id":"Purpose_and_Context_0"},{"heading":"👤 PERSONAL: V1 Visual Effect Techniques","level":2,"id":"👤_PERSONAL_V1_Visual_Effect_Techniques_0"},{"heading":"Multi-Directional Water Animation","level":3,"id":"Multi-Directional_Water_Animation_0"},{"heading":"Procedural Grass Rendering","level":3,"id":"Procedural_Grass_Rendering_0"},{"heading":"Lava Flow Animation","level":3,"id":"Lava_Flow_Animation_0"},{"heading":"Perlin Noise Integration","level":3,"id":"Perlin_Noise_Integration_0"},{"heading":"Advanced Visual Techniques","level":3,"id":"Advanced_Visual_Techniques_0"},{"heading":"👤 PERSONAL: V1 Color and Material Systems","level":2,"id":"👤_PERSONAL_V1_Color_and_Material_Systems_0"},{"heading":"Material-Specific Color Palettes","level":3,"id":"Material-Specific_Color_Palettes_0"},{"heading":"Dynamic Color Mixing","level":3,"id":"Dynamic_Color_Mixing_0"},{"heading":"Performance-Optimized Rendering","level":3,"id":"Performance-Optimized_Rendering_0"},{"heading":"👤 PERSONAL: V2 Renderer Implications","level":2,"id":"👤_PERSONAL_V2_Renderer_Implications_0"},{"heading":"Visual Complexity Vs Performance","level":3,"id":"Visual_Complexity_Vs_Performance_0"},{"heading":"Material System Design","level":3,"id":"Material_System_Design_0"},{"heading":"Animation and Time Integration","level":3,"id":"Animation_and_Time_Integration_0"},{"heading":"🟠 RESEARCH: Visual Effect Performance","level":2,"id":"🟠_RESEARCH_Visual_Effect_Performance_0"},{"heading":"Computational Intensity Evidence","level":3,"id":"Computational_Intensity_Evidence_0"},{"heading":"Memory and Bandwidth Considerations","level":3,"id":"Memory_and_Bandwidth_Considerations_0"},{"heading":"👤 PERSONAL: Recommendations for V2 Visual Design","level":2,"id":"👤_PERSONAL_Recommendations_for_V2_Visual_Design_0"},{"heading":"Preserve Effective V1 Techniques","level":3,"id":"Preserve_Effective_V1_Techniques_0"},{"heading":"Enhance V1 Concepts for V2","level":3,"id":"Enhance_V1_Concepts_for_V2_0"},{"heading":"Consider V1 Limitations","level":3,"id":"Consider_V1_Limitations_0"},{"heading":"Next Steps for V2 Visual Design","level":2,"id":"Next_Steps_for_V2_Visual_Design_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"legacy/v1-visual-effects.html","pathToRoot":"..","attachments":[],"createdTime":1760380506344,"modifiedTime":1760389062734,"sourceSize":11094,"sourcePath":"legacy/v1-visual-effects.md","exportPath":"legacy/v1-visual-effects.html","showInTree":true,"treeOrder":70,"backlinks":["legacy/legacy.html"],"type":"markdown"},"docs.html":{"title":"docs","icon":"","description":"Status: 🚧 Stub - This index file needs completionComplete documentation for the Reaction v2 real-time PvP grid-based spellcasting game engine.\n<a class=\"internal-link\" data-href=\"architecture/architecture.md\" href=\"architecture/architecture.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Architecture - System design and technical approach\n<br><a class=\"internal-link\" data-href=\"development/development.md\" href=\"development/development.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Development - Setup, workflow, and development processes <br><a class=\"internal-link\" data-href=\"gameplay/gameplay.md\" href=\"gameplay/gameplay.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Gameplay - Core game mechanics and design philosophy <br><a class=\"internal-link\" data-href=\"legacy/legacy.md\" href=\"legacy/legacy.html\" target=\"_self\" rel=\"noopener nofollow\"><strong></strong></a>Legacy V1 Analysis - V1 system concepts for V2 development reference\nTODO: Add quick start section with:\nProject setup instructions\nFirst build steps\nDevelopment environment configuration\nTODO: Add project overview with:\nGame concept summary\nTechnical architecture highlights\nDevelopment status and roadmap\n🚧 This file is a stub and needs completion","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Reaction Documentation","level":1,"id":"Reaction_Documentation_0"},{"heading":"Navigation","level":2,"id":"Navigation_0"},{"heading":"Core Documentation","level":3,"id":"Core_Documentation_0"},{"heading":"Reference","level":3,"id":"Reference_0"},{"heading":"Quick Start","level":2,"id":"Quick_Start_0"},{"heading":"Project Overview","level":2,"id":"Project_Overview_0"}],"links":["architecture/architecture.html","development/development.html","gameplay/gameplay.html","legacy/legacy.html"],"author":"","coverImageURL":"","fullURL":"docs.html","pathToRoot":".","attachments":[],"createdTime":1760380506339,"modifiedTime":1760380506340,"sourceSize":1107,"sourcePath":"docs.md","exportPath":"docs.html","showInTree":true,"treeOrder":71,"backlinks":["index.html"],"type":"markdown"},"index.html":{"title":"index","icon":"","description":"Reaction v2 is a complete reimagining of the original Reaction game, featuring GPU-accelerated physics, deterministic gameplay, and a powerful spell crafting system where players cast spells that place magical runes, transforming terrain through physics-based rule systems.We're currently in the architecture design phase, focusing on creating robust system designs before moving to implementation.\nReal-time PvP Combat - Fast-paced multiplayer battles on grid-based terrain\nSpell Crafting System - Create custom spell combinations using magical runes\nRule-based Physics - Dynamic terrain transformation through deterministic physics\nGPU Acceleration - High-performance rendering and physics calculations\nDeterministic Gameplay - Consistent game state across all clients for competitive play cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/architecture.html\" data-href=\"architecture/architecture\" aria-label=\"architecture/architecture\" data-tooltip-position=\"top\" target=\"_self\">Architecture</a> - System design and technical approach\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"development/development.html\" data-href=\"development/development\" aria-label=\"development/development\" data-tooltip-position=\"top\" target=\"_self\">Development</a> - Setup, workflow, and development processes\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"gameplay/gameplay.html\" data-href=\"gameplay/gameplay\" aria-label=\"gameplay/gameplay\" data-tooltip-position=\"top\" target=\"_self\">Gameplay</a> - Core game mechanics and design philosophy <br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"legacy/legacy.html\" data-href=\"legacy/legacy\" aria-label=\"legacy/legacy\" data-tooltip-position=\"top\" target=\"_self\">Legacy V1 Analysis</a> - V1 system concepts for V2 development reference <br>Development Setup: See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"development/getting-started.html\" data-href=\"development/getting-started\" aria-label=\"development/getting-started\" data-tooltip-position=\"top\" target=\"_self\">Getting Started Guide</a>\n<br>Architecture Overview: Read cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/overview.html\" data-href=\"architecture/general/overview\" aria-label=\"architecture/general/overview\" data-tooltip-position=\"top\" target=\"_self\">System Overview</a>\n<br>Development Principles: Review cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"development/development_principles.html\" data-href=\"development/DEVELOPMENT_PRINCIPLES\" aria-label=\"development/DEVELOPMENT_PRINCIPLES\" data-tooltip-position=\"top\" target=\"_self\">Core Principles</a>\nnpm run dev # Start development server\nnpm run test # Run test suite\nnpm run build # Create production build /docs - Documentation source (Markdown)\n/src - Source code\n/tests - Test suites\n/build - Build outputs (gitignored) <br><a data-tooltip-position=\"top\" aria-label=\"https://github.com/FireToDust/Reaction-Web\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/FireToDust/Reaction-Web\" target=\"_self\">GitHub Repository</a>\n<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"development/building-documentation.html\" data-href=\"development/building-documentation\" aria-label=\"development/building-documentation\" data-tooltip-position=\"top\" target=\"_self\">Building Documentation</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"docs\" data-href=\"docs\" href=\"docs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Full Documentation Index</a>\nFor detailed documentation, explore the links above or browse the documentation tree.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Welcome to Reaction V2","level":1,"id":"Welcome_to_Reaction_V2_0"},{"heading":"A Real-Time PvP Grid-Based Spellcasting Game","level":2,"id":"A_Real-Time_PvP_Grid-Based_Spellcasting_Game_0"},{"heading":"Current Status: Architecture Phase","level":2,"id":"Current_Status_Architecture_Phase_0"},{"heading":"Key Features","level":2,"id":"Key_Features_0"},{"heading":"Documentation","level":2,"id":"Documentation_0"},{"heading":"Core Documentation","level":3,"id":"Core_Documentation_0"},{"heading":"Reference","level":3,"id":"Reference_0"},{"heading":"Getting Started","level":2,"id":"Getting_Started_0"},{"heading":"Quick Commands","level":2,"id":"Quick_Commands_0"},{"heading":"Project Structure","level":2,"id":"Project_Structure_0"},{"heading":"Links","level":2,"id":"Links_0"}],"links":["architecture/architecture.html","development/development.html","gameplay/gameplay.html","legacy/legacy.html","development/getting-started.html","architecture/general/overview.html","development/development_principles.html","development/building-documentation.html","docs.html"],"author":"","coverImageURL":"","fullURL":"index.html","pathToRoot":".","attachments":[],"createdTime":1760382802746,"modifiedTime":1760389062731,"sourceSize":2365,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown"},"architecture/general/shader-data-layout.html":{"title":"shader-data-layout","icon":"","description":"Central tracking document for all data stored in GPU shader passes and bit allocation for each field.This document tracks all fields that need to be stored in GPU textures for physics, reactions, and rendering systems. Once all requirements are gathered, bit allocations will be determined to optimize texture memory usage.\nHex cell coordinates (q, r)\nSub-grid offset (x, y) - fixed-point Velocity vector (x, y) - fixed-point Object type ID\nMass (may be computed from type instead of stored)\nLayer (Ground/Object/Air) Timer type (number of bits TBD - depends on number of timer types)\nTimer value (number of bits TBD - count-up timer, max duration TBD) Object exists flag\n(Additional flags TBD)\n⚠️ TODO: Determine bit counts for each field once all requirements are gathered.⚠️ TODO: Calculate total bits per object and optimize packing strategy.\nPhysics: Position, velocity, mass - see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/movement-system.html\" data-href=\"movement-system\" aria-label=\"movement-system\" data-tooltip-position=\"top\" target=\"_self\">Movement System</a>\n<br>Reactions: Timer type, timer value, type transformations - see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/reactions.html\" data-href=\"reactions\" aria-label=\"reactions\" data-tooltip-position=\"top\" target=\"_self\">Reaction System</a>\n<br>Rendering: All data for visual representation - see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/rendering/rendering.html\" data-href=\"rendering\" aria-label=\"rendering\" data-tooltip-position=\"top\" target=\"_self\">Rendering</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Reference","#Implementation"],"headers":[{"heading":"Shader Data Layout","level":1,"id":"Shader_Data_Layout_0"},{"heading":"Purpose","level":2,"id":"Purpose_0"},{"heading":"Object Data Fields","level":2,"id":"Object_Data_Fields_0"},{"heading":"Position","level":3,"id":"Position_0"},{"heading":"Velocity","level":3,"id":"Velocity_0"},{"heading":"Type and Properties","level":3,"id":"Type_and_Properties_0"},{"heading":"Timer System","level":3,"id":"Timer_System_0"},{"heading":"Flags","level":3,"id":"Flags_0"},{"heading":"Bit Allocation","level":2,"id":"Bit_Allocation_0"},{"heading":"Total Storage Requirements","level":2,"id":"Total_Storage_Requirements_0"},{"heading":"Related Systems","level":2,"id":"Related_Systems_0"}],"links":["architecture/systems/physics/movement-system.html","architecture/systems/physics/reactions.html","architecture/systems/rendering/rendering.html"],"author":"","coverImageURL":"","fullURL":"architecture/general/shader-data-layout.html","pathToRoot":"../..","attachments":[],"createdTime":1762578714553,"modifiedTime":1762578714553,"sourceSize":1948,"sourcePath":"architecture/general/shader-data-layout.md","exportPath":"architecture/general/shader-data-layout.html","showInTree":true,"treeOrder":9,"backlinks":["architecture/systems/physics/reactions.html"],"type":"markdown"},"architecture/systems/physics/reactions.html":{"title":"reactions","icon":"","description":"Type transformations triggered by object combinations, environmental interactions, and timers.The reaction system determines how objects transform when they combine, interact with neighbors, or reach timer thresholds. Reactions are tightly integrated with physics, running every physics frame within the same GPU passes.When: Objects merge during physics overlap passes when distance &lt; d.Lookup: Hashmap mapping object type pairs to new types: (type_a, type_b) -&gt; new_typeMultiple Objects: When 3+ objects combine, only pairs are considered (see todo for preventing triple combinations).Timer Reset: All transformations reset the object's timer.When: Every physics frame during \"Apply Forces + Move\" pass.Gather-Based: Each object checks its two-layer hex neighborhood for nearby types.Lookup: Search tree structure maps neighborhood patterns to reactions.Range: Uses same two-layer hex range (sqrt(7)d/2 - d) as force calculations.Example: Wood object detects nearby fire → increases heat timer.When: Timer value reaches threshold for transformation.Exclusive Timers: Each object has one active timer (saves memory).Timer Types: Burning, freezing, electrified, etc. (exact types TBD).Timer Modifications: Environmental reactions can increase/decrease/reset timer values or swap timer types.Transformations: When timer reaches threshold, object type transforms based on timer type.Timer Type: Limited set of timer types (bit count TBD - see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/general/shader-data-layout.html\" data-href=\"shader-data-layout\" aria-label=\"shader-data-layout\" data-tooltip-position=\"top\" target=\"_self\">Shader Data Layout</a>).Timer Value: Count-up timer (bit count TBD).Exclusive: Only one active timer per object to minimize storage.Reset on Transformation: All type transformations reset timer to zero.Increase/Decrease: Environmental reactions modify timer value.Type Swap: Reactions can change which timer type is active.Threshold Check: When timer value exceeds threshold, transformation triggers.Examples:\nWood near fire → heat timer increases → at threshold, wood transforms to fire\nWater near fire → fire timer decreases → at threshold, fire extinguishes\nGather Pattern: Each object examines its two-layer hex neighborhood.Search Tree Lookup: Neighbor configuration maps to reaction data via search tree.Reaction Data: Includes timer modifications, type swaps, and transformation rules.Combined Effects: Neighbor combinations may have distinct reactions (not independent).Current State: Object considers its current timer type and value.Neighbor Pattern: Looks up reaction based on nearby object types.Modifications:\nSwap timer type\nSet timer value\nIncrease/decrease timer value\nImmediate type transformation (if applicable)\nExample: Wood object with heat timer near fire → heat timer increases by X per frame.⚠️ TODO: Design how reactions can create objects on different layers.Constraint: Maintain one-object-per-cell guarantee within each layer.Possibility: Object on one layer creates object on different layer in same or neighboring cell.Use Case: Fire (air layer) creating ash (ground layer), explosions creating debris, etc.Key: Ordered or unordered pair of object types (type_a, type_b).Value: New object type after combination.Properties: New object inherits mass from type, velocity from mass-weighted average.Element Handling: If types have elements, use element combination rules.Apply Forces + Move: Environmental reactions happen during force application.Overlap Passes: Combination reactions happen during object merging.Set Grid Position: Reactions complete before grid position updates.Frequency: Reactions run every physics frame (60fps).Shared Neighborhood: Use same two-layer hex data loaded for forces.Combined Shaders: Environmental reactions integrated into force application shader.Memory Efficiency: Reuse neighborhood cache for both forces and reactions.<br>Details: See cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/physics/gpu-shaders.html\" data-href=\"gpu-shaders\" aria-label=\"gpu-shaders\" data-tooltip-position=\"top\" target=\"_self\">GPU Shaders</a> for implementation.Basic: Object type changes (e.g., wood → fire).Properties Updated: Mass and other properties update based on new type.Timer Reset: Timer returns to zero on transformation.Removal: Object not output to next pass, removed from simulation.Use Case: Fire extinguished by water, objects consumed by reactions.⚠️ TODO: Cross-layer creation design needed.Constraint: Respect one-per-cell within each layer.Examples: Fire creating smoke, explosions creating particles.","aliases":[],"inlineTags":[],"frontmatterTags":["#Navigation"],"headers":[{"heading":"Reaction System","level":1,"id":"Reaction_System_0"},{"heading":"Overview","level":2,"id":"Overview_0"},{"heading":"Reaction Triggers","level":2,"id":"Reaction_Triggers_0"},{"heading":"Combination Reactions","level":3,"id":"Combination_Reactions_0"},{"heading":"Environmental Reactions","level":3,"id":"Environmental_Reactions_0"},{"heading":"Timer Reactions","level":3,"id":"Timer_Reactions_0"},{"heading":"Timer System","level":2,"id":"Timer_System_0"},{"heading":"Timer Structure","level":3,"id":"Timer_Structure_0"},{"heading":"Timer Modifications","level":3,"id":"Timer_Modifications_0"},{"heading":"Environmental Reaction Mechanics","level":2,"id":"Environmental_Reaction_Mechanics_0"},{"heading":"Neighbor Checking","level":3,"id":"Neighbor_Checking_0"},{"heading":"Reaction Application","level":3,"id":"Reaction_Application_0"},{"heading":"Cross-Layer Object Creation","level":2,"id":"Cross-Layer_Object_Creation_0"},{"heading":"Hashmap Structure","level":2,"id":"Hashmap_Structure_0"},{"heading":"Combination Reactions","level":3,"id":"Combination_Reactions_1"},{"heading":"Integration with Physics","level":2,"id":"Integration_with_Physics_0"},{"heading":"Same GPU Passes","level":3,"id":"Same_GPU_Passes_0"},{"heading":"Shader Integration","level":3,"id":"Shader_Integration_0"},{"heading":"Transformation Types","level":2,"id":"Transformation_Types_0"},{"heading":"Type Change","level":3,"id":"Type_Change_0"},{"heading":"Object Destruction","level":3,"id":"Object_Destruction_0"},{"heading":"Object Creation (Future)","level":3,"id":"Object_Creation_(Future)_0"}],"links":["architecture/general/shader-data-layout.html","architecture/systems/physics/gpu-shaders.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/physics/reactions.html","pathToRoot":"../../..","attachments":[],"createdTime":1762579296802,"modifiedTime":1762579837489,"sourceSize":5758,"sourcePath":"architecture/systems/physics/reactions.md","exportPath":"architecture/systems/physics/reactions.html","showInTree":true,"treeOrder":31,"backlinks":["architecture/general/shader-data-layout.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.html"],"type":"markdown"},"architecture/systems/spells/deck-building.html":{"title":"deck-building","icon":"","description":"Pre-match deck construction with singleton format, infinite reshuffle, and mana flower conversion.Minimum Size: 6 × number of casting pools\nExample: 4 pools requires minimum 24 spells\nEnsures sufficient variety for pool cycling\nSingleton Format: No duplicate spells\nMaximum 1 copy of each spell in deck\nPrevents single-spell spam strategies\nMaximum Size: ⚠️ NEEDS DISCUSSION - Should there be a deck size cap?Infinite Reshuffle: Deck never depletes\nAutomatically reshuffles when exhausted\nAll spells remain available throughout match\nTiming: Deck built before match starts in pre-game lobbyConstruction Steps:\nSelect spells from player's collection\nConfigure mana flower conversion (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/mana-system.html\" data-href=\"mana-system\" aria-label=\"mana-system\" data-tooltip-position=\"top\" target=\"_self\">Mana System</a>)\nValidate deck meets minimum size\nEnter match with finalized configuration\nImmutable: Deck and flower configuration cannot change during match<br>Flower conversion details in cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/mana-system.html\" data-href=\"mana-system\" aria-label=\"mana-system\" data-tooltip-position=\"top\" target=\"_self\">Mana System</a>.Mechanic: Lose 2 flowers → gain 1 flower of chosen typePurpose: Specialize flower distribution to match deck's element compositionTrade-off: More specialized casting capability at cost of total flower capacityExamples:\nFire-focused deck: Convert toward Chaos/Creation flowers\nBalanced deck: Use default 3-3-3-3-3-3 allocation\n<br>Element Access: All 26 elements accessible from game start (see cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/element-system.html\" data-href=\"element-system\" aria-label=\"element-system\" data-tooltip-position=\"top\" target=\"_self\">Element System</a>)\nNo progression gate on element types\nBase, dual, and triple elements all available\nSpell Acquisition: ⚠️ NEEDS DESIGN - How players acquire spells for collection\nSpells are collectible (specific system TBD)\nElement availability ≠ spell availability\nStrategic depth from spell variety, not element unlocks\n","aliases":[],"inlineTags":[],"frontmatterTags":["#Architecture"],"headers":[{"heading":"Deck Building","level":1,"id":"Deck_Building_0"},{"heading":"Core Deck Rules","level":2,"id":"Core_Deck_Rules_0"},{"heading":"Pre-Match Construction","level":2,"id":"Pre-Match_Construction_0"},{"heading":"Flower Conversion","level":2,"id":"Flower_Conversion_0"},{"heading":"Element and Spell Availability","level":2,"id":"Element_and_Spell_Availability_0"}],"links":["architecture/systems/spells/mana-system.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/element-system.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/deck-building.html","pathToRoot":"../../..","attachments":[],"createdTime":1760486275771,"modifiedTime":1760486275771,"sourceSize":2117,"sourcePath":"architecture/systems/spells/deck-building.md","exportPath":"architecture/systems/spells/deck-building.html","showInTree":true,"treeOrder":37,"backlinks":["architecture/systems/spells/customization.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/spells.html"],"type":"markdown"},"architecture/systems/spells/element-system.html":{"title":"element-system","icon":"","description":"26 elements organized in cube/octahedron geometric structure where opposing elements are geometrically opposite and cancel when combined.Geometric Foundation: Elements map onto cube/octahedron vertices (6), edges (12), and faces (8).Opposition Principle: Geometric opposites are element opposites. Opposite elements cancel when combined.Total: 26 elements (6 base + 12 dual + 8 triple)Fundamental forces forming three opposing pairs:\nOrder ↔ Chaos\nCreation ↔ Destruction\nSpirit ↔ Form\nUsage: Base elements used as mana costs, rarely appear as standalone spell elements.Combinations of two base elements, forming primary spell types:Usage: Most spells use dual elements. Core gameplay.Combinations of three base elements, forming rare specialized magic:Usage: Created by rare spells or combination mechanics. Will dramatically change terrain and biome.Component-Level: Elements cancel at base element level according to three opposition pairs.Complete Cancellation: When all components cancel, no rune is created.\nExample: Fire (Chaos+Creation) + Frost (Order+Destruction) = nothing\nPartial Cancellation: When some but not all components cancel, remaining elements determine result.\nExample: Fire (Chaos+Creation) + Water (Order+Creation) = Creation (single element rune)\nOrder Independence: Combination result is deterministic regardless of evaluation order.Creation: Partial cancellation between dual elements with one shared component.Effect: Recharge player's mana flowers when triggered.Additional Effects: ⚠️ TBDCreation: Triple element rune + opposite triple element rune on same location.Example: Life (Order+Creation+Spirit) + Death (Chaos+Destruction+Form) = VoidDiscovery: Not explained in tutorials. Players discover through experimentation.Effects: ⚠️ NEEDS DESIGN - Powerful secret mechanic, details TBD.cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/mana-system.html\" data-href=\"mana-system\" aria-label=\"mana-system\" data-tooltip-position=\"top\" target=\"_self\">Mana System</a> - Flower types match base elements, spell costs require specific combinations<br>cross-reference<a rel=\"noopener nofollow\" class=\"internal-link\" href=\"architecture/systems/spells/spells-and-runes.html\" data-href=\"spells-and-runes\" aria-label=\"spells-and-runes\" data-tooltip-position=\"top\" target=\"_self\">Spells and Runes</a> - Element combinations computed in GPU shaders during rune placementAvailability: All 26 elements accessible from game start. No progression gate on element types.","aliases":[],"inlineTags":[],"frontmatterTags":["#Architecture"],"headers":[{"heading":"Element System","level":1,"id":"Element_System_0"},{"heading":"Structure","level":2,"id":"Structure_0"},{"heading":"Base Elements (6)","level":2,"id":"Base_Elements_(6)_0"},{"heading":"Dual Elements (12)","level":2,"id":"Dual_Elements_(12)_0"},{"heading":"Triple Elements (8)","level":2,"id":"Triple_Elements_(8)_0"},{"heading":"Cancellation Mechanics","level":2,"id":"Cancellation_Mechanics_0"},{"heading":"Special Runes","level":2,"id":"Special_Runes_0"},{"heading":"Single Element Runes","level":3,"id":"Single_Element_Runes_0"},{"heading":"Void Rune","level":3,"id":"Void_Rune_0"},{"heading":"Related Systems","level":2,"id":"Related_Systems_0"}],"links":["architecture/systems/spells/mana-system.html","architecture/systems/spells/spells-and-runes.html"],"author":"","coverImageURL":"","fullURL":"architecture/systems/spells/element-system.html","pathToRoot":"../../..","attachments":[],"createdTime":1760486211073,"modifiedTime":1760487456980,"sourceSize":3792,"sourcePath":"architecture/systems/spells/element-system.md","exportPath":"architecture/systems/spells/element-system.html","showInTree":true,"treeOrder":38,"backlinks":["architecture/systems/spells/deck-building.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/spells.html"],"type":"markdown"}},"fileInfo":{"architecture/general/data-flow.html":{"createdTime":1760380506316,"modifiedTime":1760380506317,"sourceSize":5271,"sourcePath":"architecture/general/data-flow.md","exportPath":"architecture/general/data-flow.html","showInTree":true,"treeOrder":2,"backlinks":["architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/state-management.html","architecture/general/variable-timing.html","architecture/general/overview.html"],"type":"markdown","data":null},"architecture/general/deterministic-execution.html":{"createdTime":1760397027347,"modifiedTime":1760397027347,"sourceSize":7976,"sourcePath":"architecture/general/deterministic-execution.md","exportPath":"architecture/general/deterministic-execution.html","showInTree":true,"treeOrder":3,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html","architecture/general/implementation-guide.html","architecture/general/variable-timing.html"],"type":"markdown","data":null},"architecture/general/general.html":{"createdTime":1760397071790,"modifiedTime":1760397071790,"sourceSize":2286,"sourcePath":"architecture/general/general.md","exportPath":"architecture/general/general.html","showInTree":true,"treeOrder":4,"backlinks":["architecture/architecture.html"],"type":"markdown","data":null},"architecture/general/ghost-simulation.html":{"createdTime":1760380506318,"modifiedTime":1760380506318,"sourceSize":12880,"sourcePath":"architecture/general/ghost-simulation.md","exportPath":"architecture/general/ghost-simulation.html","showInTree":true,"treeOrder":5,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html"],"type":"markdown","data":null},"architecture/general/implementation-guide.html":{"createdTime":1760397001332,"modifiedTime":1760397001333,"sourceSize":7058,"sourcePath":"architecture/general/implementation-guide.md","exportPath":"architecture/general/implementation-guide.html","showInTree":true,"treeOrder":6,"backlinks":["architecture/general/general.html"],"type":"markdown","data":null},"architecture/general/overview.html":{"createdTime":1760485950150,"modifiedTime":1760485950150,"sourceSize":6673,"sourcePath":"architecture/general/overview.md","exportPath":"architecture/general/overview.html","showInTree":true,"treeOrder":7,"backlinks":["architecture/architecture.html","architecture/general/general.html","development/getting-started.html","index.html"],"type":"markdown","data":null},"architecture/general/performance.html":{"createdTime":1760397321210,"modifiedTime":1760397321210,"sourceSize":4629,"sourcePath":"architecture/general/performance.md","exportPath":"architecture/general/performance.html","showInTree":true,"treeOrder":8,"backlinks":["architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/overview.html"],"type":"markdown","data":null},"architecture/general/state-management.html":{"createdTime":1760380506320,"modifiedTime":1760380506320,"sourceSize":12367,"sourcePath":"architecture/general/state-management.md","exportPath":"architecture/general/state-management.html","showInTree":true,"treeOrder":9,"backlinks":["architecture/general/data-flow.html","architecture/general/general.html","architecture/general/implementation-guide.html","architecture/general/variable-timing.html","architecture/systems/multiplayer/client-prediction.html"],"type":"markdown","data":null},"architecture/general/technical-decisions.html":{"createdTime":1760485920351,"modifiedTime":1760485920351,"sourceSize":8100,"sourcePath":"architecture/general/technical-decisions.md","exportPath":"architecture/general/technical-decisions.html","showInTree":true,"treeOrder":11,"backlinks":["architecture/general/general.html"],"type":"markdown","data":null},"architecture/general/variable-timing.html":{"createdTime":1760380506321,"modifiedTime":1760380506321,"sourceSize":9400,"sourcePath":"architecture/general/variable-timing.md","exportPath":"architecture/general/variable-timing.html","showInTree":true,"treeOrder":11,"backlinks":["architecture/general/data-flow.html","architecture/general/deterministic-execution.html","architecture/general/general.html","architecture/general/ghost-simulation.html","architecture/general/implementation-guide.html","architecture/general/state-management.html"],"type":"markdown","data":null},"architecture/systems/config/config.html":{"createdTime":1760380506322,"modifiedTime":1760380506322,"sourceSize":1478,"sourcePath":"architecture/systems/config/config.md","exportPath":"architecture/systems/config/config.html","showInTree":true,"treeOrder":14,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/gpu/gpu.html":{"createdTime":1760380506324,"modifiedTime":1760389062751,"sourceSize":2654,"sourcePath":"architecture/systems/gpu/gpu.md","exportPath":"architecture/systems/gpu/gpu.html","showInTree":true,"treeOrder":22,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/deployment.html":{"createdTime":1760380506325,"modifiedTime":1760380506325,"sourceSize":8009,"sourcePath":"architecture/systems/multiplayer/deployment.md","exportPath":"architecture/systems/multiplayer/deployment.html","showInTree":true,"treeOrder":25,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/multiplayer.html":{"createdTime":1760397290336,"modifiedTime":1760397290336,"sourceSize":3014,"sourcePath":"architecture/systems/multiplayer/multiplayer.md","exportPath":"architecture/systems/multiplayer/multiplayer.html","showInTree":true,"treeOrder":20,"backlinks":["architecture/general/state-management.html","architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/network-protocol.html":{"createdTime":1760397305658,"modifiedTime":1760397305658,"sourceSize":6298,"sourcePath":"architecture/systems/multiplayer/network-protocol.md","exportPath":"architecture/systems/multiplayer/network-protocol.html","showInTree":true,"treeOrder":21,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/performance.html":{"createdTime":1760380506327,"modifiedTime":1760380506327,"sourceSize":6185,"sourcePath":"architecture/systems/multiplayer/performance.md","exportPath":"architecture/systems/multiplayer/performance.html","showInTree":true,"treeOrder":28,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/security.html":{"createdTime":1760380506327,"modifiedTime":1760380506328,"sourceSize":7536,"sourcePath":"architecture/systems/multiplayer/security.md","exportPath":"architecture/systems/multiplayer/security.html","showInTree":true,"treeOrder":29,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/multiplayer/server-architecture.html":{"createdTime":1760380506328,"modifiedTime":1760380506329,"sourceSize":4288,"sourcePath":"architecture/systems/multiplayer/server-architecture.md","exportPath":"architecture/systems/multiplayer/server-architecture.html","showInTree":true,"treeOrder":30,"backlinks":["architecture/systems/multiplayer/multiplayer.html"],"type":"markdown","data":null},"architecture/systems/physics/determinism.html":{"createdTime":1760380506329,"modifiedTime":1762477101929,"sourceSize":1285,"sourcePath":"architecture/systems/physics/determinism.md","exportPath":"architecture/systems/physics/determinism.html","showInTree":true,"treeOrder":26,"backlinks":["architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/physics.html"],"type":"markdown","data":null},"architecture/systems/physics/forces.html":{"createdTime":1762476762550,"modifiedTime":1762476762551,"sourceSize":6935,"sourcePath":"architecture/systems/physics/forces.md","exportPath":"architecture/systems/physics/forces.html","showInTree":true,"treeOrder":27,"backlinks":["architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.html"],"type":"markdown","data":null},"architecture/systems/physics/gpu-shaders.html":{"createdTime":1762476838960,"modifiedTime":1762476838961,"sourceSize":12480,"sourcePath":"architecture/systems/physics/gpu-shaders.md","exportPath":"architecture/systems/physics/gpu-shaders.html","showInTree":true,"treeOrder":28,"backlinks":["architecture/systems/physics/forces.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.html","architecture/systems/physics/reactions.html"],"type":"markdown","data":null},"architecture/systems/physics/movement-system.html":{"createdTime":1762476711145,"modifiedTime":1762476711145,"sourceSize":6058,"sourcePath":"architecture/systems/physics/movement-system.md","exportPath":"architecture/systems/physics/movement-system.html","showInTree":true,"treeOrder":29,"backlinks":["architecture/general/shader-data-layout.html","architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/physics.html"],"type":"markdown","data":null},"architecture/systems/physics/physics.html":{"createdTime":1762579364528,"modifiedTime":1762579364528,"sourceSize":2045,"sourcePath":"architecture/systems/physics/physics.md","exportPath":"architecture/systems/physics/physics.html","showInTree":true,"treeOrder":30,"backlinks":["architecture/systems/spells/spells.html","architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/rendering/rendering.html":{"createdTime":1760380506332,"modifiedTime":1760380506333,"sourceSize":639,"sourcePath":"architecture/systems/rendering/rendering.md","exportPath":"architecture/systems/rendering/rendering.html","showInTree":true,"treeOrder":41,"backlinks":["architecture/general/ghost-simulation.html","architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/spells/cpu-architecture.html":{"createdTime":1760486638438,"modifiedTime":1760486638438,"sourceSize":923,"sourcePath":"architecture/systems/spells/cpu-architecture.md","exportPath":"architecture/systems/spells/cpu-architecture.html","showInTree":true,"treeOrder":35,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/systems/spells/customization.html":{"createdTime":1760486633200,"modifiedTime":1760486633200,"sourceSize":1195,"sourcePath":"architecture/systems/spells/customization.md","exportPath":"architecture/systems/spells/customization.html","showInTree":true,"treeOrder":36,"backlinks":["architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/systems/spells/mana-system.html":{"createdTime":1760486230290,"modifiedTime":1760486230290,"sourceSize":2531,"sourcePath":"architecture/systems/spells/mana-system.md","exportPath":"architecture/systems/spells/mana-system.html","showInTree":true,"treeOrder":39,"backlinks":["architecture/systems/spells/customization.html","architecture/systems/spells/deck-building.html","architecture/systems/spells/element-system.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/systems/spells/spells.html":{"createdTime":1760486185216,"modifiedTime":1760486185216,"sourceSize":2552,"sourcePath":"architecture/systems/spells/spells.md","exportPath":"architecture/systems/spells/spells.html","showInTree":true,"treeOrder":40,"backlinks":["architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.html","architecture/systems/systems.html","gameplay/core-mechanics.html"],"type":"markdown","data":null},"architecture/systems/spells/spells-and-runes.html":{"createdTime":1760486259469,"modifiedTime":1760486259469,"sourceSize":4041,"sourcePath":"architecture/systems/spells/spells-and-runes.md","exportPath":"architecture/systems/spells/spells-and-runes.html","showInTree":true,"treeOrder":41,"backlinks":["architecture/systems/spells/cpu-architecture.html","architecture/systems/spells/element-system.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/systems/ui/ui.html":{"createdTime":1760380506336,"modifiedTime":1760380506337,"sourceSize":2063,"sourcePath":"architecture/systems/ui/ui.md","exportPath":"architecture/systems/ui/ui.html","showInTree":true,"treeOrder":51,"backlinks":["architecture/systems/systems.html"],"type":"markdown","data":null},"architecture/systems/systems.html":{"createdTime":1762579301306,"modifiedTime":1762579301306,"sourceSize":694,"sourcePath":"architecture/systems/systems.md","exportPath":"architecture/systems/systems.html","showInTree":true,"treeOrder":44,"backlinks":["architecture/architecture.html"],"type":"markdown","data":null},"architecture/architecture.html":{"createdTime":1760397055156,"modifiedTime":1760397055156,"sourceSize":2007,"sourcePath":"architecture/architecture.md","exportPath":"architecture/architecture.html","showInTree":true,"treeOrder":45,"backlinks":["docs.html","index.html"],"type":"markdown","data":null},"development/building-documentation.html":{"createdTime":1760380506338,"modifiedTime":1760380506338,"sourceSize":1084,"sourcePath":"development/building-documentation.md","exportPath":"development/building-documentation.html","showInTree":true,"treeOrder":55,"backlinks":["index.html"],"type":"markdown","data":null},"development/development.html":{"createdTime":1760383329148,"modifiedTime":1760383329149,"sourceSize":1311,"sourcePath":"development/development.md","exportPath":"development/development.html","showInTree":true,"treeOrder":56,"backlinks":["docs.html","architecture/systems/systems.html","index.html"],"type":"markdown","data":null},"development/development_principles.html":{"createdTime":1760380506337,"modifiedTime":1760380506337,"sourceSize":2569,"sourcePath":"development/DEVELOPMENT_PRINCIPLES.md","exportPath":"development/development_principles.html","showInTree":true,"treeOrder":57,"backlinks":["development/development.html","architecture/systems/systems.html","index.html"],"type":"markdown","data":null},"development/documentation_structure.html":{"createdTime":1760384850468,"modifiedTime":1760384850468,"sourceSize":7470,"sourcePath":"development/DOCUMENTATION_STRUCTURE.md","exportPath":"development/documentation_structure.html","showInTree":true,"treeOrder":58,"backlinks":["development/development.html","development/tasklist.html"],"type":"markdown","data":null},"development/getting-started.html":{"createdTime":1760380506339,"modifiedTime":1760380506339,"sourceSize":2709,"sourcePath":"development/getting-started.md","exportPath":"development/getting-started.html","showInTree":true,"treeOrder":59,"backlinks":["development/development.html","architecture/systems/systems.html","index.html"],"type":"markdown","data":null},"development/tasklist.html":{"createdTime":1760388163742,"modifiedTime":1760388163742,"sourceSize":3526,"sourcePath":"development/tasklist.md","exportPath":"development/tasklist.html","showInTree":true,"treeOrder":60,"backlinks":["development/documentation_structure.html","development/development.html"],"type":"markdown","data":null},"gameplay/core-mechanics.html":{"createdTime":1760485873346,"modifiedTime":1760485873346,"sourceSize":5486,"sourcePath":"gameplay/core-mechanics.md","exportPath":"gameplay/core-mechanics.html","showInTree":true,"treeOrder":54,"backlinks":["gameplay/gameplay.html"],"type":"markdown","data":null},"gameplay/gameplay.html":{"createdTime":1760380506340,"modifiedTime":1760380506341,"sourceSize":1221,"sourcePath":"gameplay/gameplay.md","exportPath":"gameplay/gameplay.html","showInTree":true,"treeOrder":63,"backlinks":["docs.html","architecture/systems/systems.html","architecture/general/overview.html","index.html"],"type":"markdown","data":null},"legacy/legacy.html":{"createdTime":1760380506341,"modifiedTime":1760380506342,"sourceSize":878,"sourcePath":"legacy/legacy.md","exportPath":"legacy/legacy.html","showInTree":true,"treeOrder":65,"backlinks":["docs.html","architecture/systems/systems.html","index.html"],"type":"markdown","data":null},"legacy/v1-data-strategies.html":{"createdTime":1760380506342,"modifiedTime":1760389062738,"sourceSize":11299,"sourcePath":"legacy/v1-data-strategies.md","exportPath":"legacy/v1-data-strategies.html","showInTree":true,"treeOrder":66,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"legacy/v1-environmental-examples.html":{"createdTime":1760380506342,"modifiedTime":1760380506342,"sourceSize":8492,"sourcePath":"legacy/v1-environmental-examples.md","exportPath":"legacy/v1-environmental-examples.html","showInTree":true,"treeOrder":67,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"legacy/v1-gpu-patterns.html":{"createdTime":1760380506343,"modifiedTime":1760389062736,"sourceSize":10531,"sourcePath":"legacy/v1-gpu-patterns.md","exportPath":"legacy/v1-gpu-patterns.html","showInTree":true,"treeOrder":68,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"legacy/v1-reference.html":{"createdTime":1760380506343,"modifiedTime":1760389062735,"sourceSize":6836,"sourcePath":"legacy/v1-reference.md","exportPath":"legacy/v1-reference.html","showInTree":true,"treeOrder":69,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"legacy/v1-visual-effects.html":{"createdTime":1760380506344,"modifiedTime":1760389062734,"sourceSize":11094,"sourcePath":"legacy/v1-visual-effects.md","exportPath":"legacy/v1-visual-effects.html","showInTree":true,"treeOrder":70,"backlinks":["legacy/legacy.html"],"type":"markdown","data":null},"docs.html":{"createdTime":1760380506339,"modifiedTime":1760380506340,"sourceSize":1107,"sourcePath":"docs.md","exportPath":"docs.html","showInTree":true,"treeOrder":71,"backlinks":["index.html"],"type":"markdown","data":null},"index.html":{"createdTime":1760382802746,"modifiedTime":1760389062731,"sourceSize":2365,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown","data":null},"site-lib/scripts/graph-wasm.wasm":{"createdTime":1762895140134,"modifiedTime":1760380506311.4614,"sourceSize":23655,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.wasm","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1762895159371,"modifiedTime":1762895159371,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1762895159372,"modifiedTime":1762895159372,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1762895159372,"modifiedTime":1762895159372,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1762895159373,"modifiedTime":1762895159373,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1762895159374,"modifiedTime":1762895159374,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/293fd13dbca5a3e450ef.woff2":{"createdTime":1762895159374,"modifiedTime":1762895159374,"sourceSize":105924,"sourcePath":"","exportPath":"site-lib/fonts/293fd13dbca5a3e450ef.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/085cb93e613ba3d40d2b.woff2":{"createdTime":1762895159375,"modifiedTime":1762895159375,"sourceSize":112184,"sourcePath":"","exportPath":"site-lib/fonts/085cb93e613ba3d40d2b.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1762895159375,"modifiedTime":1762895159375,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1762895159376,"modifiedTime":1762895159376,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1762895159376,"modifiedTime":1762895159376,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1762895159373,"modifiedTime":1762895159373,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1762895159377,"modifiedTime":1762895159377,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1762895159377,"modifiedTime":1762895159377,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1762895159378,"modifiedTime":1762895159378,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1762895159322,"modifiedTime":1762895159322,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1762895159323,"modifiedTime":1762895159323,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1762895159323,"modifiedTime":1762895159323,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1762895159961,"modifiedTime":1762895159961,"sourceSize":27367,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1762895141456,"modifiedTime":1762895141456,"sourceSize":110729,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-wasm.js":{"createdTime":1762895141456,"modifiedTime":1762895141456,"sourceSize":12885,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-render-worker.js":{"createdTime":1762895141456,"modifiedTime":1762895141456,"sourceSize":5681,"sourcePath":"","exportPath":"site-lib/scripts/graph-render-worker.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1762895159184,"modifiedTime":1762895159184,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/snippets.css":{"createdTime":1762895159368,"modifiedTime":1762895159368,"sourceSize":797,"sourcePath":"","exportPath":"site-lib/styles/snippets.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/obsidian.css":{"createdTime":1762895159455,"modifiedTime":1762895159455,"sourceSize":198316,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1762895159298,"modifiedTime":1762895159298,"sourceSize":305,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1762895141495,"modifiedTime":1762895141495,"sourceSize":19521,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/rss.xml":{"createdTime":1762895167794,"modifiedTime":1762895167794,"sourceSize":268102,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"architecture/general/shader-data-layout.html":{"createdTime":1762578714553,"modifiedTime":1762578714553,"sourceSize":1948,"sourcePath":"architecture/general/shader-data-layout.md","exportPath":"architecture/general/shader-data-layout.html","showInTree":true,"treeOrder":9,"backlinks":["architecture/systems/physics/reactions.html"],"type":"markdown","data":null},"architecture/systems/physics/reactions.html":{"createdTime":1762579296802,"modifiedTime":1762579837489,"sourceSize":5758,"sourcePath":"architecture/systems/physics/reactions.md","exportPath":"architecture/systems/physics/reactions.html","showInTree":true,"treeOrder":31,"backlinks":["architecture/general/shader-data-layout.html","architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.html"],"type":"markdown","data":null},"architecture/systems/spells/deck-building.html":{"createdTime":1760486275771,"modifiedTime":1760486275771,"sourceSize":2117,"sourcePath":"architecture/systems/spells/deck-building.md","exportPath":"architecture/systems/spells/deck-building.html","showInTree":true,"treeOrder":37,"backlinks":["architecture/systems/spells/customization.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/spells.html"],"type":"markdown","data":null},"architecture/systems/spells/element-system.html":{"createdTime":1760486211073,"modifiedTime":1760487456980,"sourceSize":3792,"sourcePath":"architecture/systems/spells/element-system.md","exportPath":"architecture/systems/spells/element-system.html","showInTree":true,"treeOrder":38,"backlinks":["architecture/systems/spells/deck-building.html","architecture/systems/spells/mana-system.html","architecture/systems/spells/spells-and-runes.html","architecture/systems/spells/spells.html"],"type":"markdown","data":null}},"sourceToTarget":{"architecture/general/data-flow.md":"architecture/general/data-flow.html","architecture/general/deterministic-execution.md":"architecture/general/deterministic-execution.html","architecture/general/general.md":"architecture/general/general.html","architecture/general/ghost-simulation.md":"architecture/general/ghost-simulation.html","architecture/general/implementation-guide.md":"architecture/general/implementation-guide.html","architecture/general/overview.md":"architecture/general/overview.html","architecture/general/performance.md":"architecture/general/performance.html","architecture/general/state-management.md":"architecture/general/state-management.html","architecture/general/technical-decisions.md":"architecture/general/technical-decisions.html","architecture/general/variable-timing.md":"architecture/general/variable-timing.html","architecture/systems/config/config.md":"architecture/systems/config/config.html","architecture/systems/core/active-regions.md":"architecture/systems/core/active-regions.html","architecture/systems/core/api-reference.md":"architecture/systems/core/api-reference.html","architecture/systems/core/core.md":"architecture/systems/core/core.html","architecture/systems/core/texture-management.md":"architecture/systems/core/texture-management.html","architecture/systems/core/tile-storage.md":"architecture/systems/core/tile-storage.html","architecture/systems/gpu/gpu.md":"architecture/systems/gpu/gpu.html","architecture/systems/multiplayer/client-prediction.md":"architecture/systems/multiplayer/client-prediction.html","architecture/systems/multiplayer/deployment.md":"architecture/systems/multiplayer/deployment.html","architecture/systems/multiplayer/multiplayer.md":"architecture/systems/multiplayer/multiplayer.html","architecture/systems/multiplayer/network-protocol.md":"architecture/systems/multiplayer/network-protocol.html","architecture/systems/multiplayer/performance.md":"architecture/systems/multiplayer/performance.html","architecture/systems/multiplayer/security.md":"architecture/systems/multiplayer/security.html","architecture/systems/multiplayer/server-architecture.md":"architecture/systems/multiplayer/server-architecture.html","architecture/systems/physics/determinism.md":"architecture/systems/physics/determinism.html","architecture/systems/physics/forces.md":"architecture/systems/physics/forces.html","architecture/systems/physics/gpu-shaders.md":"architecture/systems/physics/gpu-shaders.html","architecture/systems/physics/movement-system.md":"architecture/systems/physics/movement-system.html","architecture/systems/physics/physics.md":"architecture/systems/physics/physics.html","architecture/systems/reactions/reactions.md":"architecture/systems/reactions/reactions.html","architecture/systems/reactions/rule-compilation.md":"architecture/systems/reactions/rule-compilation.html","architecture/systems/rendering/rendering.md":"architecture/systems/rendering/rendering.html","architecture/systems/spells/cpu-architecture.md":"architecture/systems/spells/cpu-architecture.html","architecture/systems/spells/customization.md":"architecture/systems/spells/customization.html","architecture/systems/spells/mana-system.md":"architecture/systems/spells/mana-system.html","architecture/systems/spells/spells.md":"architecture/systems/spells/spells.html","architecture/systems/spells/spells-and-runes.md":"architecture/systems/spells/spells-and-runes.html","architecture/systems/tools/tools.md":"architecture/systems/tools/tools.html","architecture/systems/ui/ui.md":"architecture/systems/ui/ui.html","architecture/systems/systems.md":"architecture/systems/systems.html","architecture/architecture.md":"architecture/architecture.html","development/building-documentation.md":"development/building-documentation.html","development/development.md":"development/development.html","development/DEVELOPMENT_PRINCIPLES.md":"development/development_principles.html","development/DOCUMENTATION_STRUCTURE.md":"development/documentation_structure.html","development/getting-started.md":"development/getting-started.html","development/tasklist.md":"development/tasklist.html","gameplay/core-mechanics.md":"gameplay/core-mechanics.html","gameplay/gameplay.md":"gameplay/gameplay.html","legacy/legacy.md":"legacy/legacy.html","legacy/v1-data-strategies.md":"legacy/v1-data-strategies.html","legacy/v1-environmental-examples.md":"legacy/v1-environmental-examples.html","legacy/v1-gpu-patterns.md":"legacy/v1-gpu-patterns.html","legacy/v1-reference.md":"legacy/v1-reference.html","legacy/v1-visual-effects.md":"legacy/v1-visual-effects.html","docs.md":"docs.html","index.md":"index.html","":"site-lib/rss.xml","architecture/general/shader-data-layout.md":"architecture/general/shader-data-layout.html","architecture/systems/physics/reactions.md":"architecture/systems/physics/reactions.html","architecture/systems/spells/deck-building.md":"architecture/systems/spells/deck-building.html","architecture/systems/spells/element-system.md":"architecture/systems/spells/element-system.html"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Backlinks","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Aliases","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Properties","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Search...","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Outline","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Graph View","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"hideSettingsButton":false,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"rss","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"siteUrl":"","authorName":"","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}},"linkPreview":{"featureId":"link-preview","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":true}},"modifiedTime":1762895159463,"siteName":"source_docs","vaultName":"docs","exportRoot":"","baseURL":"","pluginVersion":"1.9.2","themeName":"","bodyClasses":"publish css-settings-manager show-inline-title show-ribbon is-focused","hasFavicon":false}