<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[source_docs]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>source_docs</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 11 Nov 2025 21:06:07 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 11 Nov 2025 21:05:59 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[reactions]]></title><description><![CDATA[Type transformations triggered by object combinations, environmental interactions, and timers.The reaction system determines how objects transform when they combine, interact with neighbors, or reach timer thresholds. Reactions are tightly integrated with physics, running every physics frame within the same GPU passes.When: Objects merge during physics overlap passes when distance &lt; d.Lookup: Hashmap mapping object type pairs to new types: (type_a, type_b) -&gt; new_typeMultiple Objects: When 3+ objects combine, only pairs are considered (see todo for preventing triple combinations).Timer Reset: All transformations reset the object's timer.When: Every physics frame during "Apply Forces + Move" pass.Gather-Based: Each object checks its two-layer hex neighborhood for nearby types.Lookup: Search tree structure maps neighborhood patterns to reactions.Range: Uses same two-layer hex range (sqrt(7)d/2 - d) as force calculations.Example: Wood object detects nearby fire → increases heat timer.When: Timer value reaches threshold for transformation.Exclusive Timers: Each object has one active timer (saves memory).Timer Types: Burning, freezing, electrified, etc. (exact types TBD).Timer Modifications: Environmental reactions can increase/decrease/reset timer values or swap timer types.Transformations: When timer reaches threshold, object type transforms based on timer type.Timer Type: Limited set of timer types (bit count TBD - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/shader-data-layout.html" data-href="shader-data-layout" aria-label="shader-data-layout" data-tooltip-position="top" target="_self">Shader Data Layout</a>).Timer Value: Count-up timer (bit count TBD).Exclusive: Only one active timer per object to minimize storage.Reset on Transformation: All type transformations reset timer to zero.Increase/Decrease: Environmental reactions modify timer value.Type Swap: Reactions can change which timer type is active.Threshold Check: When timer value exceeds threshold, transformation triggers.Examples:
Wood near fire → heat timer increases → at threshold, wood transforms to fire
Water near fire → fire timer decreases → at threshold, fire extinguishes
Gather Pattern: Each object examines its two-layer hex neighborhood.Search Tree Lookup: Neighbor configuration maps to reaction data via search tree.Reaction Data: Includes timer modifications, type swaps, and transformation rules.Combined Effects: Neighbor combinations may have distinct reactions (not independent).Current State: Object considers its current timer type and value.Neighbor Pattern: Looks up reaction based on nearby object types.Modifications:
Swap timer type
Set timer value
Increase/decrease timer value
Immediate type transformation (if applicable)
Example: Wood object with heat timer near fire → heat timer increases by X per frame.⚠️ TODO: Design how reactions can create objects on different layers.Constraint: Maintain one-object-per-cell guarantee within each layer.Possibility: Object on one layer creates object on different layer in same or neighboring cell.Use Case: Fire (air layer) creating ash (ground layer), explosions creating debris, etc.Key: Ordered or unordered pair of object types (type_a, type_b).Value: New object type after combination.Properties: New object inherits mass from type, velocity from mass-weighted average.Element Handling: If types have elements, use element combination rules.Apply Forces + Move: Environmental reactions happen during force application.Overlap Passes: Combination reactions happen during object merging.Set Grid Position: Reactions complete before grid position updates.Frequency: Reactions run every physics frame (60fps).Shared Neighborhood: Use same two-layer hex data loaded for forces.Combined Shaders: Environmental reactions integrated into force application shader.Memory Efficiency: Reuse neighborhood cache for both forces and reactions.<br>Details: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/gpu-shaders.html" data-href="gpu-shaders" aria-label="gpu-shaders" data-tooltip-position="top" target="_self">GPU Shaders</a> for implementation.Basic: Object type changes (e.g., wood → fire).Properties Updated: Mass and other properties update based on new type.Timer Reset: Timer returns to zero on transformation.Removal: Object not output to next pass, removed from simulation.Use Case: Fire extinguished by water, objects consumed by reactions.⚠️ TODO: Cross-layer creation design needed.Constraint: Respect one-per-cell within each layer.Examples: Fire creating smoke, explosions creating particles.]]></description><link>architecture/systems/physics/reactions.html</link><guid isPermaLink="false">architecture/systems/physics/reactions.md</guid><pubDate>Sat, 08 Nov 2025 05:30:37 GMT</pubDate></item><item><title><![CDATA[physics]]></title><description><![CDATA[GPU-accelerated physics simulation on a hexagonal grid with sub-grid positioning, force-based interactions, and combination mechanics.The physics engine provides realistic object movement, interactions, and transformations using:
Hexagonal grid with polar coordinates for efficient circular world representation
Sub-grid positioning with fixed-point arithmetic for smooth, deterministic movement
Force-based physics including collision repulsion, cohesion attraction, and spell forces
Combination mechanic that merges nearby objects to maintain one object per hex cell
Reaction system for object transformations from combinations, environmental interactions, and timers
Multi-pass GPU pipeline for parallel force application, reactions, and collision resolution <a class="internal-link" data-href="movement-system.md" href="architecture/systems/physics/movement-system.html" target="_self" rel="noopener nofollow"><strong></strong></a>Movement System - Hexagonal grid, sub-grid positioning, velocity, mass, and combinations
<br><a class="internal-link" data-href="forces.md" href="architecture/systems/physics/forces.html" target="_self" rel="noopener nofollow"><strong></strong></a>Forces - Collision, cohesion, and spell force mechanics
<br><a class="internal-link" data-href="reactions.md" href="architecture/systems/physics/reactions.html" target="_self" rel="noopener nofollow"><strong></strong></a>Reactions - Object transformations from combinations, environmental interactions, and timers
<br><a class="internal-link" data-href="gpu-shaders.md" href="architecture/systems/physics/gpu-shaders.html" target="_self" rel="noopener nofollow"><strong></strong></a>GPU Shaders - Multi-pass compute pipeline and implementation
<br><a class="internal-link" data-href="determinism.md" href="architecture/systems/physics/determinism.html" target="_self" rel="noopener nofollow"><strong></strong></a>Determinism - Fixed-point arithmetic and reproducibility guarantees
Hexagonal Grid: Corner-to-corner cell size d ensures no two objects occupy the same cell, even during movement.Direct Force Resolution: Forces applied continuously while objects overlap - no iterative convergence.Speed Limits: Maximum ~9.69 cells/second at 60fps, with typical gameplay 2-6 cells/second.Three Layers: Ground, Object, and Air layers for different entity types.
Spell System: Objects check overlapping spell shapes for force application; element combination rules determine reaction outcomes
Renderer: Provides sub-grid positions, velocities, and timer states for smooth visuals
]]></description><link>architecture/systems/physics/physics.html</link><guid isPermaLink="false">architecture/systems/physics/physics.md</guid><pubDate>Sat, 08 Nov 2025 05:22:44 GMT</pubDate></item><item><title><![CDATA[systems]]></title><description><![CDATA[Navigational document for the systems of Reaction v2.
<a class="internal-link" data-href="spells/spells.md" href="architecture/systems/spells/spells.html" target="_self" rel="noopener nofollow"><strong></strong></a>Spell System - Player spellcasting and mana management
<br><a class="internal-link" data-href="physics/physics.md" href="architecture/systems/physics/physics.html" target="_self" rel="noopener nofollow"><strong></strong></a>Physics Engine - GPU-accelerated movement, collisions, and reactions
<br><a class="internal-link" data-href="rendering/rendering.md" href="architecture/systems/rendering/rendering.html" target="_self" rel="noopener nofollow"><strong></strong></a>Renderer - Visual display and UI rendering
<br><a class="internal-link" data-href="multiplayer/multiplayer.md" href="architecture/systems/multiplayer/multiplayer.html" target="_self" rel="noopener nofollow"><strong></strong></a>Multiplayer - Real-time PvP networking
<br><a class="internal-link" data-href="ui/ui.md" href="architecture/systems/ui/ui.html" target="_self" rel="noopener nofollow"><strong></strong></a>User Interface - Game controls, HUD elements, and player interaction
<br><a class="internal-link" data-href="config/config.md" href="architecture/systems/config/config.html" target="_self" rel="noopener nofollow"><strong></strong></a>Configuration - System settings and runtime parameters
<br><a class="internal-link" data-href="gpu/gpu.md" href="architecture/systems/gpu/gpu.html" target="_self" rel="noopener nofollow"><strong></strong></a>GPU Manager - WebGPU resource management and coordination
]]></description><link>architecture/systems/systems.html</link><guid isPermaLink="false">architecture/systems/systems.md</guid><pubDate>Sat, 08 Nov 2025 05:21:41 GMT</pubDate></item><item><title><![CDATA[shader-data-layout]]></title><description><![CDATA[Central tracking document for all data stored in GPU shader passes and bit allocation for each field.This document tracks all fields that need to be stored in GPU textures for physics, reactions, and rendering systems. Once all requirements are gathered, bit allocations will be determined to optimize texture memory usage.
Hex cell coordinates (q, r)
Sub-grid offset (x, y) - fixed-point Velocity vector (x, y) - fixed-point Object type ID
Mass (may be computed from type instead of stored)
Layer (Ground/Object/Air) Timer type (number of bits TBD - depends on number of timer types)
Timer value (number of bits TBD - count-up timer, max duration TBD) Object exists flag
(Additional flags TBD)
⚠️ TODO: Determine bit counts for each field once all requirements are gathered.⚠️ TODO: Calculate total bits per object and optimize packing strategy.
Physics: Position, velocity, mass - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/movement-system.html" data-href="movement-system" aria-label="movement-system" data-tooltip-position="top" target="_self">Movement System</a>
<br>Reactions: Timer type, timer value, type transformations - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="reactions" aria-label="reactions" data-tooltip-position="top" target="_self">Reaction System</a>
<br>Rendering: All data for visual representation - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/rendering/rendering.html" data-href="rendering" aria-label="rendering" data-tooltip-position="top" target="_self">Rendering</a>
]]></description><link>architecture/general/shader-data-layout.html</link><guid isPermaLink="false">architecture/general/shader-data-layout.md</guid><pubDate>Sat, 08 Nov 2025 05:11:54 GMT</pubDate></item><item><title><![CDATA[determinism]]></title><description><![CDATA[Ensuring reproducible physics simulation for fair PvP gameplay.Identical Inputs → Identical Outputs: Essential for fair PvP gameplay
Cross-Platform Consistency: Same results across different hardware and drivers
Replay Capability: Matches should be perfectly reproducible
Spatial Ordering: Process tiles in strict top-left to bottom-right order
Integer Mathematics: Fixed-point arithmetic prevents floating-point drift Cross-Platform Consistency: Identical results across GPU architectures
Validation Framework: Automated testing for deterministic execution
No Floating-Point Drift: Use integer-only calculations to prevent precision accumulation
Fixed-Point Arithmetic: ⚠️ NEEDS SPECIFICATION - Specific fixed-point formats for velocity and position
Rounding Consistency: Deterministic rounding rules across all calculationsNo Shared State: Tiles don't share mutable state during processing
Atomic Operations: Critical for marking active chunks and activity propagation
Data Races: Prevent concurrent read/write conflicts]]></description><link>architecture/systems/physics/determinism.html</link><guid isPermaLink="false">architecture/systems/physics/determinism.md</guid><pubDate>Fri, 07 Nov 2025 00:58:21 GMT</pubDate></item><item><title><![CDATA[gpu-shaders]]></title><description><![CDATA[Multi-pass GPU compute pipeline for force-based physics with combination mechanics on a hexagonal grid.The physics system uses a sequence of GPU compute passes to update object positions and handle combinations:
Apply Forces + Move: Calculate and apply all forces, update velocities and sub-grid offsets
Overlap Passes (2-N): Detect and merge objects that are too close
Set Grid Position: Update hex cell assignments based on final offsets
Purpose: Apply collision, cohesion, and spell forces; update velocity and sub-grid offset.Grid Position Preserved: Objects remain in their current hex cell until final pass.Neighbor Range: Check two-layer hexagonal neighborhood for force interactions.@compute @workgroup_size(8, 8)
fn apply_forces_and_move( @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;, @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;
) { let hex_coord = calculate_hex_coord(global_id); let object = read_object(hex_coord); if (!object.exists) { return; } // Load two-layer hex neighborhood into shared memory load_hex_neighborhood_to_cache(hex_coord, local_id); workgroupBarrier(); // Accumulate forces from neighbors var total_force = vec2&lt;i32&gt;(0, 0); // Fixed-point // Collision forces (from overlapping objects) total_force += calculate_collision_forces(object, neighborhood_cache); // Cohesion forces (from nearby objects within radius) total_force += calculate_cohesion_forces(object, neighborhood_cache); // Spell forces (from overlapping spell shapes) total_force += calculate_spell_forces(object, spell_buffer); // Update velocity (F = ma, so a = F/m) let acceleration = fixed_point_divide(total_force, object.mass); object.velocity = fixed_point_add(object.velocity, acceleration); // Clamp velocity to maximum object.velocity = clamp_velocity(object.velocity, MAX_VELOCITY); // Update sub-grid offset (don't change hex cell assignment yet) object.offset = fixed_point_add(object.offset, object.velocity); write_object(hex_coord, object);
}
Collision Forces: For each overlapping neighbor, calculate repulsion force based on overlap distance and mass.Cohesion Forces: For neighbors within cohesion radius, calculate attraction force toward group centroid.Spell Forces: Check spell buffer for overlapping spell shapes; apply impulses or set velocities based on element type.Details: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/forces.html" data-href="forces" aria-label="forces" data-tooltip-position="top" target="_self">Forces</a> for force formulas and mechanics.Purpose: Detect objects closer than combination distance d; merge them into single objects.Scatter-Gather: Complex algorithm to identify and merge groups of nearby objects.Multiple Passes: May require several passes to fully resolve cascading combinations.⚠️ NEEDS SPECIFICATION: Exact scatter-gather implementation approach TBD.@compute @workgroup_size(8, 8)
fn overlap_detection_pass( @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;, @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;
) { let hex_coord = calculate_hex_coord(global_id); let object = read_object(hex_coord); if (!object.exists) { return; } // Load two-layer hex neighborhood load_hex_neighborhood_to_cache(hex_coord, local_id); workgroupBarrier(); // Find all objects within combination distance d var nearby_objects = find_objects_within_distance(object, neighborhood_cache, COMBINATION_DISTANCE); if (nearby_objects.count &gt; 0) { // Mark for combination // TODO: Implement scatter-gather algorithm // - Assign combination group ID // - Calculate combined properties (mass-averaged velocity, centroid position) // - Apply reaction rules for type transformation // - Write combined object, mark merged objects for deletion }
}
Distance Check: Calculate distance between object centers; trigger if &lt; d.Group Formation: All objects within d of combined center merge together.Property Calculation:
Velocity: Mass-weighted average of all merged objects
Position: Mass-weighted centroid
<br>Type: Determined by reaction rules (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="reactions" aria-label="reactions" data-tooltip-position="top" target="_self">Reaction System</a>)
Mass: Based on new type
Atomic Operations: Use atomics to prevent race conditions when multiple groups overlap.Purpose: Update which hex cell each object occupies based on its final sub-grid offset.Boundary Wrapping: Handle objects that have moved across world edges.Spatial Indexing: Ensure objects are correctly indexed for next frame's neighbor queries.@compute @workgroup_size(8, 8)
fn set_grid_position( @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;
) { let hex_coord = calculate_hex_coord(global_id); let object = read_object(hex_coord); if (!object.exists) { return; } // Calculate new hex cell based on offset let new_hex_coord = calculate_hex_from_offset(hex_coord, object.offset); // Normalize offset relative to new cell center let normalized_offset = normalize_offset_to_cell(object.offset, new_hex_coord); // Handle world wrapping let wrapped_coord = wrap_hex_coordinate(new_hex_coord); if (wrapped_coord != hex_coord) { // Object moved to new cell - relocate it object.offset = normalized_offset; atomic_write_object(wrapped_coord, object); delete_object(hex_coord); } else { // Object stayed in same cell - just update offset object.offset = normalized_offset; write_object(hex_coord, object); }
}
Coordinate System: Use cube coordinates (q, r, s) where q + r + s = 0.Neighbor Lookup: Efficient neighbor calculation using coordinate offsets.Point-to-Hex: Convert Cartesian (x, y) position to hex coordinates using cube algorithm.GPU Layout: Grid stored as skewed parallelogram in texture memory.Rectangular Indexing: Standard 2D texture coordinates map to hex cells.Wrapped Boundaries: World edges wrap seamlessly for continuous circular world.Layer Definition: Objects check 19 hex cells (center + 6 immediate + 12 second-layer).Shared Memory Size: 19 objects fit efficiently in workgroup shared memory.Coordinate Calculation: Precompute neighbor offsets for each hex layer.Purpose: Load neighborhood data once per workgroup to minimize texture reads.Cache Size: 19 hex cells × object data size (position, velocity, type, mass).Synchronization: Workgroup barriers ensure all threads see cached data.// Workgroup shared memory for hex neighborhood
var&lt;workgroup&gt; neighborhood_cache: array&lt;ObjectData, 19&gt;;
var&lt;workgroup&gt; cache_loaded: bool; fn load_hex_neighborhood_to_cache( center_hex: vec2&lt;i32&gt;, local_id: vec3&lt;u32&gt;
) { // First thread loads all 19 neighbors if (local_id.x == 0 &amp;&amp; local_id.y == 0) { for (var i = 0; i &lt; 19; i++) { let neighbor_hex = center_hex + HEX_NEIGHBOR_OFFSETS[i]; neighborhood_cache[i] = read_object(neighbor_hex); } cache_loaded = true; }
}
Current Choice: 8×8 workgroups (64 threads).Rationale: Balance between GPU occupancy and shared memory usage.⚠️ NEEDS TUNING: Optimal workgroup size TBD through GPU profiling.GPU Texture Layout:struct ObjectData { // Position (12 bytes) hex_coord: vec2&lt;i32&gt;, // 8 bytes - hex cell coordinates offset: vec2&lt;i32&gt;, // 8 bytes - fixed-point offset from cell center // Velocity (8 bytes) velocity: vec2&lt;i32&gt;, // 8 bytes - fixed-point velocity vector // Properties (8 bytes) type_id: u32, // 4 bytes - object type mass: u32, // 4 bytes - mass (or could be computed from type) // Flags (4 bytes) layer: u32, // 4 bytes - Ground/Object/Air (could be packed) exists: bool, // 1 byte - object exists flag // ... potential padding or additional flags
}
// Total: ~32 bytes per object (may be optimized with bit-packing)
Memory Packing: Consider bit-packing to reduce texture memory and bandwidth.Structure: Array of active spell shapes in GPU buffer.Data Per Spell:
Shape geometry (circle, rectangle, etc.)
Position and radius
Element type(s)
Cast time (for element combination ordering)
Force magnitude/velocity value
Spatial Partitioning: Future optimization to limit spell checks per object.Integer-Only Operations: All physics calculations use fixed-point (scaled integers).Platform Independence: Avoids floating-point precision differences across GPUs.Bit Precision: Balance accuracy vs overflow risk (e.g., 16.16 fixed-point).<br>Details: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/determinism.html" data-href="determinism" aria-label="determinism" data-tooltip-position="top" target="_self">Determinism</a> for implementation.// Fixed-point addition (trivial)
fn fixed_point_add(a: vec2&lt;i32&gt;, b: vec2&lt;i32&gt;) -&gt; vec2&lt;i32&gt; { return a + b;
} // Fixed-point multiplication (scale factor = 2^16)
fn fixed_point_multiply(a: i32, b: i32) -&gt; i32 { return (i64(a) * i64(b)) &gt;&gt; 16;
} // Fixed-point division
fn fixed_point_divide(numerator: i32, denominator: i32) -&gt; i32 { return (i64(numerator) &lt;&lt; 16) / i64(denominator);
}
Stationary Objects: Skip force calculations for objects with zero velocity and no nearby activity.Convergence Detection: In overlap passes, terminate early if no combinations triggered.Pass Skipping: Skip remaining overlap passes once no objects need merging.Coalesced Access: Threads in workgroup access contiguous memory locations.Texture Cache: Structure data layout for optimal GPU cache utilization.Bit-Packing: Compress object data to minimize texture memory bandwidth.Combination Conflicts: Use atomic operations when multiple objects try to merge.Cell Relocation: Atomic writes when moving objects to new hex cells.Flag Updates: Atomic flags for convergence detection across workgroups.
Pipeline implements movement, velocity, and combination mechanics
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/movement-system.html" data-href="movement-system" aria-label="movement-system" data-tooltip-position="top" target="_self">Movement System</a> for conceptual details Force calculation details and formulas
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/forces.html" data-href="forces" aria-label="forces" data-tooltip-position="top" target="_self">Forces</a> for force types and equations Spell buffer provides force input
Objects check for overlapping spell shapes
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a> for spell mechanics Combination type transformations use reaction rules
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="reactions" aria-label="reactions" data-tooltip-position="top" target="_self">Reaction System</a> for transformation rules
Language: WebGPU Shading Language (WGSL).Compilation: Shaders compiled at runtime by WebGPU driver.Validation: Browser provides shader compilation errors during development.Development Mode: Support shader hot-reloading for rapid iteration.Error Handling: Graceful fallback when shader compilation fails.Debugging: Use browser GPU debugging tools for shader profiling.GPU Timers: Measure individual pass execution times.Bandwidth Monitoring: Track texture read/write operations.Workgroup Tuning: Profile different workgroup sizes for optimal performance.]]></description><link>architecture/systems/physics/gpu-shaders.html</link><guid isPermaLink="false">architecture/systems/physics/gpu-shaders.md</guid><pubDate>Fri, 07 Nov 2025 00:53:58 GMT</pubDate></item><item><title><![CDATA[forces]]></title><description><![CDATA[Force mechanics for collision repulsion, cohesion attraction, and spell-driven movement.Forces modify object velocities each frame, creating realistic physics interactions. All forces operate within the two-layer hexagonal neighborhood range, ensuring objects can respond before collisions become problematic.Coverage: Objects check two layers of surrounding hexagons for force interactions.Maximum Range: All forces operate within sqrt(7)d/2 - d distance limit, where d is the hex cell size.Range Guarantee: Two hex layers provide sufficient coverage for all force interactions given speed limits (~9.69 cells/second max).Efficiency: Neighbor checking limited to necessary range reduces computation.Polar Coordinates: Use polar/cube coordinate system for efficient neighbor queries.Wrapped Boundaries: Handle world wrapping when checking neighbors near edges.Layer Order: Process neighbors in consistent order for deterministic results.Overlap Resolution: Push objects apart when they overlap to prevent interpenetration.Continuous Application: Forces applied every frame while objects remain overlapping.Mass-Based Response: Force produces different accelerations based on object mass.Repulsion: Objects push apart when overlapping, with force directed away from collision point.Overlap-Based Magnitude: Force magnitude increases with overlap amount.Mass Influence: Force applied to both objects, with acceleration inversely proportional to mass (F = ma).Breaking Threshold: High overlap triggers combination mechanic instead of force (when distance &lt; d).⚠️ NEEDS SPECIFICATION: Exact collision force formula TBD through playtesting.Considerations:
Linear vs non-linear force scaling with overlap distance
Force strength calibration for gameplay feel
Balance between collision response and combination trigger
Interaction with cohesion forces
Gap Closure: Automatically close gaps between objects for natural density management.Clustering: Maintain dense object coverage without rigid grid constraints.Breaking Force: Allow high-velocity impacts to overcome cohesion and create temporary gaps.Attraction: Objects within cohesion radius pull toward each other.Density Management: Prevents permanent gaps in object field while allowing dynamic separation.Gameplay Interaction: Creates emergent behavior where objects naturally cluster unless disrupted.⚠️ NEEDS SPECIFICATION: Exact cohesion force formula and radius TBD through playtesting.Considerations:
Cohesion radius (likely smaller than two-layer range)
Force strength relative to collision forces
Linear vs clamped force falloff with distance
Centroid vs pairwise attraction
Impulse Elements: Some spell elements apply instantaneous velocity changes (impulses).Velocity-Setting Elements: Other spell elements directly set object velocities to specific values.Element Determination: Spell element type determines force application method.⚠️ NEEDS SPECIFICATION: Mapping of spell elements to force types TBD through spell system design.Buffer Lookup: Objects check spell buffer for active spell shapes.Overlap Detection: Determine which spell shapes overlap the object's center point.Multiple Spells: Objects can be affected by multiple overlapping spell shapes.Combination Order: When multiple spells overlap, combine elements by cast time order (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a>).Impulse Method: Add velocity delta to current velocity (Δv applied once per spell contact).Velocity-Set Method: Directly replace velocity with spell-specified value.Mass Independence: Spell forces may ignore mass (TBD through spell design).<br>Details: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a> for spell shape mechanics and element combination rules.Force Sources: Each frame, objects accumulate forces from:
Collision forces (from overlapping objects)
Cohesion forces (from nearby objects within radius)
Spell forces (from overlapping spell shapes)
Summation: Forces summed using vector addition.Velocity Update: Net force applied to update velocity: v_new = v_old + (F_total / mass) * dtPosition Update: Updated velocity used to modify sub-grid offset.Determinism: All force calculations use fixed-point arithmetic for platform-independent results.Precision: Bit precision chosen to balance accuracy and GPU texture storage.Overflow Prevention: Force magnitudes clamped to prevent fixed-point overflow.<br>Details: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/determinism.html" data-href="determinism" aria-label="determinism" data-tooltip-position="top" target="_self">Determinism</a> for fixed-point implementation.
Forces modify object velocities each frame
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/movement-system.html" data-href="movement-system" aria-label="movement-system" data-tooltip-position="top" target="_self">Movement System</a> for velocity and mass details Force calculations performed in "Apply Forces + Move" pass
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/gpu-shaders.html" data-href="gpu-shaders" aria-label="gpu-shaders" data-tooltip-position="top" target="_self">GPU Shaders</a> for pipeline details Spell shapes provide force input from buffer
Element types determine force application method
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a> for spell mechanics
Collision vs Cohesion: Collision forces must overcome cohesion to allow object separation.Spell Dominance: Spell forces should be noticeable over ambient collision/cohesion forces.Combination Threshold: Objects approaching distance d should combine rather than bounce indefinitely.Playtesting Required: Force formulas will be refined through gameplay iteration.Adjustable Parameters: Force strengths and radii exposed as configuration values.Element Variation: Different spell elements may use different force strengths/types.Neighbor Limits: Two-layer range constraint keeps force calculations bounded.Parallel Computation: Force calculations fully parallelizable across objects in GPU.Early Termination: Skip force calculations for stationary objects with no nearby activity.]]></description><link>architecture/systems/physics/forces.html</link><guid isPermaLink="false">architecture/systems/physics/forces.md</guid><pubDate>Fri, 07 Nov 2025 00:52:42 GMT</pubDate></item><item><title><![CDATA[movement-system]]></title><description><![CDATA[Hexagonal grid with sub-grid positioning, velocity management, mass-based interactions, and combination mechanics.Objects move freely on a hexagonal grid using sub-grid offsets and persistent velocities. The combination mechanic merges objects that get too close, maintaining the one-object-per-cell guarantee while enabling dynamic physics interactions.Hex Cell Size: Corner-to-corner distance d chosen to equal the minimum combination distance.One-Per-Cell Guarantee: Cell size ensures no two objects can occupy the same cell, even during mid-movement.Polar Coordinates: Grid uses polar/cube coordinate system for neighbor lookup and point-to-hex conversion.GPU Storage: Grid stored as skewed parallelogram with wrapped boundaries, enabling rectangular indexing.World Wrapping: Objects at world edges wrap to opposite side for continuous circular world.Offset Storage: Each object stores precise x,y offsets from its hex cell center using fixed-point arithmetic.Unconstrained Movement: Objects can move freely in any direction based on applied forces.Precision: Fixed-point representation ensures deterministic positioning across platforms.Cell Assignment: Objects remain assigned to their current hex cell until the final "set grid position" pass.Vector Representation: Two-component velocity (x,y) stored with fixed-point precision.Texture Storage: Velocities stored in GPU textures alongside position data.Deterministic Updates: All velocity changes use fixed-point arithmetic.Frame Persistence: Velocity persists frame-to-frame unless modified by forces.Applied Forces: Collision, cohesion, and spell forces modify velocity each frame (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/forces.html" data-href="forces" aria-label="forces" data-tooltip-position="top" target="_self">Forces</a>).Spell Inputs: Spell elements can apply impulses or directly set velocities.Combinations: Merged objects receive mass-averaged velocity.Damping: Optional velocity damping to prevent perpetual motion (TBD through playtesting).Maximum Velocity: ~9.69 hex cells/second at 60fps based on two-layer force range guarantee.Gameplay Range: Typical gameplay velocities 2-6 cells/second, providing margin for force application.Range Guarantee: Two hex layers sufficient for all force interactions within speed limits.Type-Based: Each object type has an associated mass value.Layer Variation: Different layers may have different mass ranges (e.g., ground heavier than air).Gameplay Impact: Mass affects force response and combination outcomes.⚠️ NEEDS SPECIFICATION: Specific mass values for object types TBD through gameplay balancing.Force Response: Heavier objects accelerate less from the same applied force (F = ma).Collision Interaction: Mass ratio between colliding objects affects their relative force responses.Combination Averaging: When objects combine, velocities are mass-averaged to conserve momentum.Conservation: Total momentum preserved during combinations: m1*v1 + m2*v2 = m_combined * v_combinedOne-Per-Cell Guarantee: Ensures no hex cell ever contains more than one object.Gameplay Feature: Creates dynamic object fusion and reaction chains.Physics Stability: Prevents infinite force application from perpetually overlapping objects.Distance Threshold: Combination triggered when two objects approach closer than distance d.Merge Radius: All objects with centers within d of the combined center are included in the merge.Multi-Object Merges: Single combination can merge 3+ objects if they're all within radius.Velocity Averaging: Combined velocity is mass-weighted average of all merged objects.<br>Type Transformation: New object type determined by reaction rules applied to merged objects (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="reactions" aria-label="reactions" data-tooltip-position="top" target="_self">Reaction System</a>).Mass Assignment: New object mass based on its transformed type.Position: Combined object placed at mass-weighted centroid of merged objects.Position:
Hex cell coordinates (using polar/cube system)
Fixed-point offset (x,y) from cell center
Velocity:
Fixed-point vector (x,y)
Stored in GPU texture alongside position
Properties:
Object type ID (for mass lookup and reactions)
Mass value (may be stored or computed from type)
Layer assignment (Ground/Object/Air)
Texture Layout: Data packed efficiently for GPU texture storage and access patterns.
Velocity modified by forces each frame
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/forces.html" data-href="forces" aria-label="forces" data-tooltip-position="top" target="_self">Forces</a> for force types and calculations Movement calculations performed in GPU compute shaders
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/gpu-shaders.html" data-href="gpu-shaders" aria-label="gpu-shaders" data-tooltip-position="top" target="_self">GPU Shaders</a> for pipeline details Objects check spell buffer for overlapping spell shapes
Spell elements determine force application method
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a> for spell mechanics Combination types determined by reaction rules
New object mass based on reaction-determined type
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="reactions" aria-label="reactions" data-tooltip-position="top" target="_self">Reaction System</a> for transformation rules Sub-grid offsets provide precise visual positioning
Velocities available for motion blur and particle effects Ground Layer: Terrain foundation (dirt, stone, water)
Object Layer: Interactive entities (rocks, trees, creatures, players)
Air Layer: Gases and effects (fire, smoke, magic)
]]></description><link>architecture/systems/physics/movement-system.html</link><guid isPermaLink="false">architecture/systems/physics/movement-system.md</guid><pubDate>Fri, 07 Nov 2025 00:51:51 GMT</pubDate></item><item><title><![CDATA[element-system]]></title><description><![CDATA[26 elements organized in cube/octahedron geometric structure where opposing elements are geometrically opposite and cancel when combined.Geometric Foundation: Elements map onto cube/octahedron vertices (6), edges (12), and faces (8).Opposition Principle: Geometric opposites are element opposites. Opposite elements cancel when combined.Total: 26 elements (6 base + 12 dual + 8 triple)Fundamental forces forming three opposing pairs:
Order ↔ Chaos
Creation ↔ Destruction
Spirit ↔ Form
Usage: Base elements used as mana costs, rarely appear as standalone spell elements.Combinations of two base elements, forming primary spell types:Usage: Most spells use dual elements. Core gameplay.Combinations of three base elements, forming rare specialized magic:Usage: Created by rare spells or combination mechanics. Will dramatically change terrain and biome.Component-Level: Elements cancel at base element level according to three opposition pairs.Complete Cancellation: When all components cancel, no rune is created.
Example: Fire (Chaos+Creation) + Frost (Order+Destruction) = nothing
Partial Cancellation: When some but not all components cancel, remaining elements determine result.
Example: Fire (Chaos+Creation) + Water (Order+Creation) = Creation (single element rune)
Order Independence: Combination result is deterministic regardless of evaluation order.Creation: Partial cancellation between dual elements with one shared component.Effect: Recharge player's mana flowers when triggered.Additional Effects: ⚠️ TBDCreation: Triple element rune + opposite triple element rune on same location.Example: Life (Order+Creation+Spirit) + Death (Chaos+Destruction+Form) = VoidDiscovery: Not explained in tutorials. Players discover through experimentation.Effects: ⚠️ NEEDS DESIGN - Powerful secret mechanic, details TBD.cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a> - Flower types match base elements, spell costs require specific combinations<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells-and-runes.html" data-href="spells-and-runes" aria-label="spells-and-runes" data-tooltip-position="top" target="_self">Spells and Runes</a> - Element combinations computed in GPU shaders during rune placementAvailability: All 26 elements accessible from game start. No progression gate on element types.]]></description><link>architecture/systems/spells/element-system.html</link><guid isPermaLink="false">architecture/systems/spells/element-system.md</guid><pubDate>Wed, 15 Oct 2025 00:17:36 GMT</pubDate></item><item><title><![CDATA[cpu-architecture]]></title><description><![CDATA[⚠️ DEPRECATED: This document describes a CPU-based spell system that was not implemented.The spell system is now fully GPU-accelerated. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells-and-runes.html" data-href="spells-and-runes" aria-label="spells-and-runes" data-tooltip-position="top" target="_self">Spells and Runes</a> for current architecture.GPU Processing:
Shape evaluation (compute shaders)
Element combination (shader computation)
Rune delay countdown (GPU texture counters)
Rune triggering and cleanup (multi-pass shaders)
This document originally explored CPU-based spell processing for flexibility and ease of debugging. The decision was later revised to use GPU processing for consistency with physics and reaction systems, better performance at scale, and deterministic parallel evaluation.]]></description><link>architecture/systems/spells/cpu-architecture.html</link><guid isPermaLink="false">architecture/systems/spells/cpu-architecture.md</guid><pubDate>Wed, 15 Oct 2025 00:03:58 GMT</pubDate></item><item><title><![CDATA[customization]]></title><description><![CDATA[Player customization through deck building and optional curse mechanics.Deck building is the primary customization system. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/deck-building.html" data-href="deck-building" aria-label="deck-building" data-tooltip-position="top" target="_self">Deck Building</a> for complete rules.Key Decisions:
Spell selection from collection
<br>Mana flower conversion to match deck composition (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a>)
Element focus vs diverse coverage
⚠️ NEEDS DESIGN: Curse system implementation details TBD.Risk/Reward: Cursed builds offer advantages with meaningful drawbacksOptional: Curses are optional - pure builds remain viableBuild Diversity: Support multiple viable build approaches⚠️ NEEDS SPECIFICATION:
Curse selection mechanics
Stacking rules (can multiple curses be combined?)
Activation conditions and triggers
Balancing approach between pure and cursed builds
Integration with deck building and flower conversion
]]></description><link>architecture/systems/spells/customization.html</link><guid isPermaLink="false">architecture/systems/spells/customization.md</guid><pubDate>Wed, 15 Oct 2025 00:03:53 GMT</pubDate></item><item><title><![CDATA[deck-building]]></title><description><![CDATA[Pre-match deck construction with singleton format, infinite reshuffle, and mana flower conversion.Minimum Size: 6 × number of casting pools
Example: 4 pools requires minimum 24 spells
Ensures sufficient variety for pool cycling
Singleton Format: No duplicate spells
Maximum 1 copy of each spell in deck
Prevents single-spell spam strategies
Maximum Size: ⚠️ NEEDS DISCUSSION - Should there be a deck size cap?Infinite Reshuffle: Deck never depletes
Automatically reshuffles when exhausted
All spells remain available throughout match
Timing: Deck built before match starts in pre-game lobbyConstruction Steps:
Select spells from player's collection
Configure mana flower conversion (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a>)
Validate deck meets minimum size
Enter match with finalized configuration
Immutable: Deck and flower configuration cannot change during match<br>Flower conversion details in cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a>.Mechanic: Lose 2 flowers → gain 1 flower of chosen typePurpose: Specialize flower distribution to match deck's element compositionTrade-off: More specialized casting capability at cost of total flower capacityExamples:
Fire-focused deck: Convert toward Chaos/Creation flowers
Balanced deck: Use default 3-3-3-3-3-3 allocation
<br>Element Access: All 26 elements accessible from game start (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>)
No progression gate on element types
Base, dual, and triple elements all available
Spell Acquisition: ⚠️ NEEDS DESIGN - How players acquire spells for collection
Spells are collectible (specific system TBD)
Element availability ≠ spell availability
Strategic depth from spell variety, not element unlocks
]]></description><link>architecture/systems/spells/deck-building.html</link><guid isPermaLink="false">architecture/systems/spells/deck-building.md</guid><pubDate>Tue, 14 Oct 2025 23:57:55 GMT</pubDate></item><item><title><![CDATA[spells-and-runes]]></title><description><![CDATA[Slot/pool casting interface with GPU-accelerated spell shapes, element combinations, and rune lifecycle management.Structure: N casting slots + N casting pools (using 4 as example, final count TBD)Starting State: All slots empty, all pools filled with random spells from deck1. Cast Spell (from filled slot):
Consumes required mana flowers (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a>)
Triggers directional targeting mode
Slot becomes empty after cast
Pools unchanged
2. Load Spell (pool → empty slot):
Player selects spell from any pool
Chosen spell moves to clicked slot
<br>All pools refill sequentially from deck (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/deck-building.html" data-href="deck-building" aria-label="deck-building" data-tooltip-position="top" target="_self">Deck Building</a>)
No mana cost
3. Refresh Pools:
Manually replace all pool spells with new draws from deck
Triggers action cooldown
Flowers do NOT recharge during refresh cooldown (unique penalty)
Universal Cooldown: Single shared cooldown applies to all three actionsMovement: Not affected by action cooldownHold-to-Cast Queueing: Hold mouse on filled slot during cooldown to queue cast for immediate execution when readyActivation: After clicking cast, enter targeting modeInput: Player clicks direction and distance from avatarPlacement: Spell shape centered on clicked locationRange Limits: Each spell has maximum range from casterObstruction: ⚠️ NEEDS DESIGN - Line of sight checks TBDDesign: Abstract geometric primitives (circles, rectangles, lines, etc.) evaluated at runtimeNot Textures: Mathematical definitions, not pre-rendered imagesEvaluation: GPU compute shaders evaluate shape membership per-pixelPrimitives: ⚠️ NEEDS SPECIFICATION - Specific primitive set TBD through spell design processShape Components:
Position (relative to spell center)
Rotation and scale
<br>Element type (from cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>)
Force vector
Delay value Placement: Spell casting writes runes to rune layer via GPU
Delay Countdown: GPU shader decrements delay counter each frame
Trigger + Removal: Simultaneous - apply effects and remove rune when delay reaches zero
Combination: Multiple runes on same pixel combine before triggering
<br>Element Type: One of 26 elements (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>)Force Vector: Applied to physics layer when triggeredDelay Counter: Frame-based countdownStorage: Per-pixel on dedicated rune layer textureTiming: Runes combine when multiple exist on same pixel<br>Element Rules: Uses element system cancellation rules (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>)Force Combination: Vector addition of all force componentsDelay Resolution: Combined rune uses minimum delay of componentsTrigger Timing: Combined rune triggers when shortest delay expiresDelay System: 16-bit looping time counter, runes store target trigger timeShape Evaluation: Compute shaders evaluate abstract primitives per-pixel during spell placementElement Combination: Shader-based component-level cancellation during rune combinationCleanup: Separate shader pass removes triggered runesDeterminism: Fixed-point precision, order-independent combination results]]></description><link>architecture/systems/spells/spells-and-runes.html</link><guid isPermaLink="false">architecture/systems/spells/spells-and-runes.md</guid><pubDate>Tue, 14 Oct 2025 23:57:39 GMT</pubDate></item><item><title><![CDATA[mana-system]]></title><description><![CDATA[Resource economy based on 6 elemental flower types with individual flower tracking and strategic conversion mechanics.6 Base Element Flowers: Each flower type corresponds to a base element from cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>:
Order Flowers
Chaos Flowers
Creation Flowers
Destruction Flowers
Spirit Flowers
Form Flowers
Default Allocation: 3 of each type (18 total)Individual Tracking: Each flower has independent recharge state and cooldown.Duration: 3 turns per flowerIndividual Cooldowns: Each flower tracks its own timer independently.Recharge Behavior:
✅ Cast spell: Flowers recharge normally
✅ Load spell: Flowers recharge normally
✅ Movement: Flowers recharge normally
❌ Refresh pools: Flowers do NOT recharge (strategic penalty)
Unlimited Regeneration: Flowers always regenerate. Never permanently lost during match.Flexible Costs: Spells require specific combinations and quantities of flower types.Examples:
Basic Fire spell: 1 Chaos + 1 Creation
Powerful Fire spell: 3 Chaos + 2 Creation
Life spell: 1 Order + 1 Creation + 1 Spirit
Validation: All required flowers must be available (not recharging) to cast spell.Cost-Power Relationship: Higher costs = more powerful spells. Specific costs TBD through playtesting.When: During deck building phase (before match starts)Operation: Lose 2 flowers → gain 1 flower of chosen typeIrreversible: Conversion affects starting flower configuration for that match.Purpose: Specialize flower distribution to match deck element composition.Trade-off: Increased element focus at cost of total capacity and flexibility.<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a> - Spell costs require combinations matching element structure (dual elements = 2 flower types, triple elements = 3 flower types)<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells-and-runes.html" data-href="spells-and-runes" aria-label="spells-and-runes" data-tooltip-position="top" target="_self">Spells and Runes</a> - Refresh action uniquely prevents flower recharge during cooldown<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/deck-building.html" data-href="deck-building" aria-label="deck-building" data-tooltip-position="top" target="_self">Deck Building</a> - Flower conversion configured during deck construction]]></description><link>architecture/systems/spells/mana-system.html</link><guid isPermaLink="false">architecture/systems/spells/mana-system.md</guid><pubDate>Tue, 14 Oct 2025 23:57:10 GMT</pubDate></item><item><title><![CDATA[spells]]></title><description><![CDATA[GPU-accelerated spellcasting with 26-element magic system, mana flower economy, slot/pool casting interface, and deck customization.Player-controlled spellcasting creates runes on the game world through geometric element combinations, resource management, and strategic deck building.Processing: Fully GPU-accelerated (shape evaluation, element combination, rune lifecycle)Core Systems: Elements (26), Mana (6 flowers), Casting (slot/pool), Runes (lifecycle), Deck Building (singleton)
<a data-tooltip-position="top" aria-label="element-system" data-href="element-system" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">Element System</a> - 26 elements in cube/octahedron structure
<br><a data-tooltip-position="top" aria-label="mana-system" data-href="mana-system" href="architecture/systems/spells/mana-system.html" class="internal-link" target="_self" rel="noopener nofollow">Mana System</a> - 6 flower types with recharge and conversion
<br><a data-tooltip-position="top" aria-label="spells-and-runes" data-href="spells-and-runes" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">Spells and Runes</a> - Casting interface and rune lifecycle
<br><a data-tooltip-position="top" aria-label="deck-building" data-href="deck-building" href="architecture/systems/spells/deck-building.html" class="internal-link" target="_self" rel="noopener nofollow">Deck Building</a> - Deck rules and pre-match construction
<br><a data-tooltip-position="top" aria-label="customization" data-href="customization" href="architecture/systems/spells/customization.html" class="internal-link" target="_self" rel="noopener nofollow">Customization</a> - Curse system and build options
<br><a data-tooltip-position="top" aria-label="cpu-architecture" data-href="cpu-architecture" href="architecture/systems/spells/cpu-architecture.html" class="internal-link" target="_self" rel="noopener nofollow">CPU Architecture</a> - Outdated, system now GPU-accelerated <br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/physics.html" data-href="../physics/physics" aria-label="../physics/physics" data-tooltip-position="top" target="_self">Physics System</a> - Force application from triggered runes
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href=".html" data-href="../core/core" aria-label="../core/core" data-tooltip-position="top" target="_self">Core Engine</a> - Texture management and layer coordination
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href=".html" data-href="../reactions/reactions" aria-label="../reactions/reactions" data-tooltip-position="top" target="_self">Reaction System</a> - Environmental interactions
Physics Engine: Triggered runes apply force vectors to physics layer. Independent tick rates coordinate timing.Core Engine: Manages rune layer texture for GPU processing.Reaction Engine: Runes can trigger environmental transformation rules.UI System: Displays casting slots/pools, mana flower availability, targeting overlay, and deck builder interface.Documented:
Element system (26 elements, cancellation rules)
Mana system (6 flowers, recharge, conversion)
Casting interface (slot/pool, actions, cooldown)
Rune lifecycle (placement, delay, trigger, combination)
Deck building rules (minimum size, singleton, reshuffle)
Needs Design:
Specific spell shape primitives
Void rune effects
Single element rune additional effects
Curse system mechanics
Spell acquisition/progression system
Line of sight obstruction rules
Number of casting slots/pools
<br>Entry Point: Start with <a data-tooltip-position="top" aria-label="element-system" data-href="element-system" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">Element System</a> to understand the foundational magic structure.]]></description><link>architecture/systems/spells/spells.html</link><guid isPermaLink="false">architecture/systems/spells/spells.md</guid><pubDate>Tue, 14 Oct 2025 23:56:25 GMT</pubDate></item><item><title><![CDATA[overview]]></title><description><![CDATA[Reaction is a real-time PvP game where players cast spells that place magical runes on a grid. These runes transform the terrain according to rule-based systems.The core technical challenge: simulate thousands of interacting tiles at 60 FPS while allowing complex spell interactions that feel responsive and fair.Performance Goal: High performance with many active tilesDeterminism: Identical inputs produce identical outputs (essential for fair PvP)Responsiveness: Spell casting feels immediate despite complex backend processingExtensibility: New spells and tile interactions can be added without engine rewritesThe system separates concerns into focused, loosely-coupled modules:Purpose: Central coordination and tile data management.Responsibilities:
Bit-packed tile storage across 4 layers (Ground, Object, Air, Rune)
GPU texture management with ping-ponging (enables GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards) for race-condition prevention
Active region optimization (32×32 chunks - chosen to balance GPU workgroup efficiency with memory overhead) ⚠️ NOT IMPLEMENTED: Active region optimization was decided against
Frame execution pipeline coordination
Dependencies: WebGPU APIPurpose: GPU-accelerated player-controlled spellcasting with geometric element system.Responsibilities:
26-element system (cube/octahedron structure) with component-level cancellation
6-flower mana economy (individual tracking, 3-turn recharge, 2:1 conversion)
Slot/pool casting interface (cast/load/refresh actions with universal cooldown)
Abstract spell shapes (geometric primitives evaluated in GPU shaders)
Rune lifecycle (GPU delay counters, triggering, combination, cleanup)
Deck building (singleton format, infinite reshuffle, minimum size 6×pools)
Curse system (TBD)
Dependencies: Core Engine (rune layer texture), Physics Engine (force application)Processing: GPU compute shaders for shape evaluation, element combination, and rune lifecyclePurpose: GPU-accelerated tile movement and collision simulation.Responsibilities:
Free-form movement with fixed-precision Vector2 velocities
Mass-based collision physics with momentum transfer
Cohesion forces for natural tile clustering (1.5 block radius, 5×5 neighborhood)
Multi-pass collision resolution for deterministic results
Sub-grid positioning with integer fixed-point arithmetic
Layer interaction physics (falling, bouncing)
Dependencies: Core Engine (texture coordination)Processing: GPU compute shaders with hardcoded physics rulesNote: Frame rate coordination approach proposed in cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">data-flow.md</a> - implementation and effectiveness TBD ⚠️ data-flow.md is outdatedPurpose: Rule-based environmental transformations.Responsibilities:
JSON rule compilation to optimized GPU shaders
Competitive rule scoring and execution
Environmental pattern matching (fire spreading, etc.)
Optimization pipeline (specific implementation TBD)
Dependencies: Core Engine (texture access), Build toolchainProcessing: GPU compute shaders with compiled rulesNote: The rule compilation pipeline allows simple code generation with sophisticated optimization. Alternative approaches welcome if simpler.Purpose: Visual display and user interface.Responsibilities:
Multi-layer world rendering
UI elements (mana flowers, spell hand)
Visual effects and animations
Camera and viewport management
Dependencies: Core Engine (tile data access)Processing: GPU rendering pipelinePurpose: Development and debugging utilities.Responsibilities:
Visual rule editor with grid-based interface
Debug overlays and tile inspection
Performance profiling and rule tracing
Asset validation and testing tools
Dependencies: All modules (for debugging access)<br>⚠️ PROPOSED ARCHITECTURE: A Deterministic Time-Sliced Execution approach has been proposed for variable timing and multiplayer synchronization. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">data-flow.md</a> for proposed pipeline details - implementation and validation TBD.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href=".html" data-href="tile-storage" aria-label="tile-storage" data-tooltip-position="top" target="_self">tile-storage.md</a> for complete tile format and layer architecture details. Specific bit allocation TBD during implementation.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/performance.html" data-href="performance" aria-label="performance" data-tooltip-position="top" target="_self">performance.md</a> and individual system documentation for specific optimization strategies.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="gameplay/gameplay.html" data-href="gameplay" aria-label="gameplay" data-tooltip-position="top" target="_self">gameplay mechanics</a> for complete gameplay mechanics and customization systems.
Visual Editor: Grid-based rule design interface
JSON Export: Human-readable rule definitions
Compilation: Automatic shader generation and optimization
Testing: Live rule testing and validation
Integration: Hot-reload in development builds Tile Inspector: Real-time tile data examination
Rule Tracer: Understand why specific rules activated
Performance Overlay: Monitor frame timing and bottlenecks
Determinism Validation: Verify identical execution across runs
Tile Types: ~64 per layer (chosen to be comfortably under realistic limits)World Size: Fixed at initialization (no dynamic streaming)Flower Types: 6 (matching base elements)Casting Slots/Pools: Count TBD through playtesting (using 4 as example)Performance Degradation: Automated benchmarks prevent optimization regressionsRule Complexity: Visual editor prevents impossible shader compilationDeterminism: Strict execution ordering and integer-only mathematicsToolchain Stability: Containerized build environment for consistent results]]></description><link>architecture/general/overview.html</link><guid isPermaLink="false">architecture/general/overview.md</guid><pubDate>Tue, 14 Oct 2025 23:52:30 GMT</pubDate></item><item><title><![CDATA[technical-decisions]]></title><description><![CDATA[Design choices, rationale, and alternative approaches considered during Reaction v2 architecture.Decision: Separate concerns into focused, loosely-coupled modules
Rationale: Enables independent development and testing of complex systems
Alternative Considered: Monolithic architecture - rejected for maintainability concernsDecision: WebGPU-based processing for physics, reactions, and rendering
Rationale: Required performance for thousands of interacting tiles at 60 FPS
Trade-offs: Added complexity vs. performance requirementsSpell System: GPU compute shaders for shape evaluation, element combination, and rune lifecycle
Rationale: Consistency with physics/reaction systems, parallel evaluation, deterministic combination results
Alternative Considered: CPU processing - rejected for performance at scale and system consistencyPhysics Engine: GPU compute shaders with hardcoded physics rules
Rationale: High parallelization needs for tile movement and collision detection
Update: Physics now includes mass-based collisions with momentum transfer for realistic tile interactionsReaction Engine: GPU compute shaders with compiled rules
Rationale: Complex rule evaluation benefits from parallel processingDecision: Input → Physics → Runes → Reactions → Render
Rationale: Ensures deterministic execution and proper data dependencies
⚠️ UNSOLVED: Timing coordination between systems at different frequenciesDecision: Simultaneous single-read/single-write GPU passes with deterministic internal rules
Rationale: Achieves determinism without complex spatial ordering or thread synchronization
Alternatives Considered: Spatial ordering strategy - rejected for complexityDecision: 32-bit integers with packed tile data
Rationale: GPU cache efficiency and memory bandwidth optimization
⚠️ NOTE: Specific bit allocation TBD during implementation. See <a class="internal-link" data-href="../systems/core-engine/tile-storage.md" href=".html" target="_self" rel="noopener nofollow">tile-storage.md</a> for current architectural approach.Decision: Ground, Object, Air, Rune layers
Rationale: Clean separation of different tile behaviors and interactions
Alternative Considered: Single layer with type flags - rejected for complexityDecision: Dual texture approach for each layer
Rationale: Prevents GPU read-after-write hazards and race conditions
Trade-off: Double memory usage for synchronization safetyDecision: NOT IMPLEMENTING active region optimization
Rationale: Implementation deemed too complex for expected benefit; planning for relatively few dormant areas in game design
Alternative Sizes Considered: 32×32 tile chunks were originally proposed to balance GPU workgroup efficiency with memory overhead
Status: All 32×32 chunk references throughout documentation are now outdatedDecision: JSON rules → GPU shaders via offline compilation
Rationale: Move computational work to build time for runtime performance
⚠️ NOTE: Alternative approaches may be considered during implementationDecision: 26 elements organized in cube/octahedron geometric structure
Rationale: Intuitive geometric opposition creates natural counter-play, component-level cancellation enables emergent combinations
Structure: 6 base + 12 dual + 8 triple elements
Alternative Considered: Smaller element set - rejected for strategic depthDecision: N slots + N pools system with three player actions (cast/load/refresh)
Rationale: Creates meaningful decisions between immediate casting and deck cycling
Trade-offs: Refresh action uniquely prevents flower recharge (strategic cost)
Alternative Considered: Traditional hand system - rejected for limited strategic depthDecision: Abstract geometric primitives evaluated at runtime in GPU shaders
Rationale: Perfect rotational symmetry, minimal memory, flexible design
Alternative Considered: Pre-rendered texture system - rejected for memory cost and symmetry concernsDecision: Singleton format (no duplicates) with infinite reshuffle
Rationale: Encourages spell variety, prevents deck depletion strategies
Minimum Size: 6 × number of pools ensures sufficient variety
Alternative Considered: Duplicate limits with deck depletion - rejected for complexityDecision: 6 flower types matching base elements with 3-turn recharge cycle
Rationale: Direct correspondence with element system, individual tracking enables strategic timing
Default Allocation: 3 of each type (18 total), unlimited regeneration
Alternative Considered: 4-element system (fire/water/earth/air) - rejected for misalignment with element structureDecision: 2:1 flower conversion ratio during deck building
Rationale: Enables element specialization at meaningful cost (total capacity reduction)
Alternative Considered: No conversion - rejected for limited deck customizationDecision: ~64 tile types per layer
Rationale: Chosen to be comfortably under realistic GPU and memory limits
Constraint: Leaves room for expansion without architectural changesDecision: Identical inputs must produce identical outputs
Rationale: Essential for fair PvP gameplay
Implementation: Integer-only mathematics, simultaneous single-read/single-write GPU passes with deterministic internal rules
⚠️ CHALLENGE: GPU thread execution order is not inherently deterministic - Addressed through simultaneous read/write pass architectureDecision: Fixed world size at initialization
Rationale: Avoids dynamic streaming complexity
Trade-off: Limits map variety for implementation simplicityDecision: Grid-based rule design interface planned
Rationale: Simplifies rule creation and prevents impossible shader compilation
Status: Design planned, implementation TBDDecision: Use containerized build for consistent results
Rationale: Ensures deterministic shader compilation across development environments
⚠️ STATUS: Implementation approach needs specification⚠️ Major Design Decisions Still Needed: Frame Rate Coordination: How to handle different update frequencies between physics (60 FPS) and reactions (potentially lower)? Rule Compilation Pipeline: Exact toolchain and optimization steps? World Size Limits: Performance testing needed to determine optimal map dimensions? Build System Integration: How rule compilation integrates with main build process? Spell System TBD: Number of Casting Slots/Pools: Using 4 as example, optimal count requires playtesting Spell Shape Primitives: Which geometric primitives to support for spell design Void Rune Effects: Powerful secret mechanic effects need design Single Element Rune Effects: Beyond mana recharge, additional effects TBD Curse System Implementation: Mechanics, stacking rules, balancing approach Spell Acquisition System: How players unlock/collect spells ]]></description><link>architecture/general/technical-decisions.html</link><guid isPermaLink="false">architecture/general/technical-decisions.md</guid><pubDate>Tue, 14 Oct 2025 23:52:00 GMT</pubDate></item><item><title><![CDATA[core-mechanics]]></title><description><![CDATA[Elimination: Last player standing wins. Players are eliminated when their avatar tile is destroyed.Duration: Unlimited match length - games end only when elimination occurs
Player Count: Variable player count, limited only by performance constraints
Real-Time Execution: Continuous simulation without traditional turnsNon-Turn-Based: Game runs continuously with different processes at different frequencies
Pre-Planning: Players queue actions in advance
Execution Timing: Player actions execute at regular intervals determined by game state
Dynamic Speed: Object movement speed controlled by time delays between tile position updates
Status Effects: Players can be slowed, frozen, or otherwise affected by spells and environmentPlayer → Spell → World → Player: Clear action consequence chain
Player casts spell
Spell affects world tiles and environment
World changes affect all players through environmental interactions
Player Tiles: Players exist as tiles on the object layer
Physics Only: Player avatars affected by physics (velocity, collisions, forces) but never transform into other tile types
Damage System: Players can take damage and be destroyed but maintain their tile type while alive
Movement: Players move using same physics system as other object layer tilesDamage Sources: Tiles can deal damage, apply slow effects, or other status conditions to players
Healing: Either no healing mechanics, or healing through specific terrain tiles
Regeneration Strategy: No health regeneration vs. tile-based healing zones (to be playtested)
Destruction: Players eliminated when health reaches zero, but tile type never changesPhysics-Driven: Maps generated through built-in physics simulation and tile reactions
Emergent Terrain: World evolves naturally through rule-based transformations
Dynamic Environment: Continuous world changes create evolving strategic opportunitiesStrategic Terrain: Different tile types provide tactical advantages and challenges
Reactive Tiles: Special tiles that explode, ignite, or transform when targeted by spells
Environmental Interactions: Terrain affects tactical gameplay
Spell-Terrain Synergy: Spells designed to interact meaningfully with terrain typesSize: To be determined through playtesting for optimal performance and gameplay balance
Performance Scaling: Map size limited by ability to maintain 60 FPS with active player countNo Scarcity: Unlimited mana flower regeneration - focus on timing and positioning over resource conservation
Mana Recharge: 3-turn recharge cycle provides natural pacing without creating resource pressureTile-Based Escalation: Environmental changes naturally create pressure and opportunities
No Regeneration Alternative: Potential no-healing system to ensure permanent consequences
Environmental Pressure: Reactive terrain and ongoing world changes prevent static positioningBalanced Design: Spells designed for diverse strategies
Situational Advantage: Different spells excel in different terrain and tactical situations
No Power Creep: Focus on interesting combinations rather than raw damage scaling
Terrain Understanding: Learning different tile type behaviors
Spell Combinations: Combining rune effects
Positioning: Tactical movement and area control
Timing: Execution of pre-planned actions at optimal moments
Environmental Prediction: Anticipating world changes and terrain evolution
See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="../architecture/systems/spells/spells" aria-label="../architecture/systems/spells/spells" data-tooltip-position="top" target="_self">Spell System</a> for complete spell mechanics.Element Mastery:
Understanding 26 elements and geometric opposition structure
Recognizing cancellation opportunities (complete, partial, Void)
Defensive counter-element selection against opponents
Resource Management:
Mana flower spending patterns with 3-turn recharge cycles
Action cooldown timing (cast/load/refresh decisions)
Refresh action strategic use (tempo cost for pool cycling)
Deck Construction:
Pre-match element focus vs diverse coverage decisions
Mana flower conversion optimization (2:1 trade-off)
Singleton format encourages spell variety strategies
Tactical Execution:
Slot/pool management (when to cast vs load)
Directional targeting precision
Rune overlap timing for combinations Rule Interactions: Complex behaviors arising from rule combinations
Adaptive Strategy: Changing world state requires flexible tactical adaptation
Risk/Reward: Curse system and aggressive positioning create choices
Long-term Planning: Pre-planning system rewards strategic foresight
Element Counter-Play: Geometric opposition creates natural counter-strategies
]]></description><link>gameplay/core-mechanics.html</link><guid isPermaLink="false">gameplay/core-mechanics.md</guid><pubDate>Tue, 14 Oct 2025 23:51:13 GMT</pubDate></item><item><title><![CDATA[performance]]></title><description><![CDATA[Optimization approaches and technical constraints for tile processing performance.⚠️ NEEDS DISCUSSION: Specific performance targets and constraints have not been established yet.General Goals:
Support many active tiles simultaneously
Performance should scale reasonably with world activity
⚠️ NOT IMPLEMENTED: Active region optimization was decided against - implementation deemed too complex for expected benefit. Team is planning for relatively few dormant areas instead.Purpose: Avoid processing static regions to maintain performance.~~Implementation:
Divide world into 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)
Track chunks with active tiles in GPU buffer
Shaders only process listed active chunks
Activity propagates to neighboring chunks automatically
Dormant regions have minimal GPU cost~~
~~Benefits:
Automatic scaling with activity level
Efficient memory bandwidth usage
Reduced compute shader dispatches~~
GPU Cache Optimization: Leverage 2D data access patterns for efficient memory readsBit-Packing: 32-bit tiles maximize cache line utilization
Tile Type (~6 bits): 64 possible types per layer
Velocity (16 bits): Movement vector for physics
Custom Data (10 bits): Health, timers, charges, etc.
Ping-Ponging: Dual texture approach prevents read-after-write hazardsGPU Workgroup Efficiency: 32×32 chunks align with GPU architectureMemory Layout: Textures use r32uint format for optimal GPU cache performanceParallel Processing: Each GPU thread handles one tile for maximum parallelization⚠️ POTENTIAL OPTIMIZATIONS: Additional GPU techniques
Memory Coalescing: Threads in a warp access consecutive memory addresses simultaneously for maximum bandwidth
⚠️ GUIDELINE: Minimize divergent branching
Structure algorithms so threads in the same warp follow similar execution paths
When early exits are necessary, group similar work patterns together to reduce warp divergence
Tile Types: ~64 per layer (chosen to be comfortably under realistic limits)
World Size: Fixed at initialization (no dynamic streaming)
Mana Types: 8 maximum (player state buffer constraint)
Spell Hand: Size TBD based on UI and gameplay needs⚠️ NEEDS DISCUSSION: Specific performance characteristics to be determined through testing
32×32 chunks chosen to balance GPU workgroup efficiency with memory overhead
GPU texture cache considerations
Parallel processing efficiency targets
⚠️ SUGGESTION: Potential optimization techniques for rule compilation:
Compile-time specialization for specific use cases
Dead code elimination for unused rule paths
Constant folding for pre-computed values
Loop unrolling for neighbor checks
Shader Generation: Move complex rule logic to build time
Asset Optimization: Texture and mesh preprocessing
⚠️ NEEDS DESIGN: Specific optimization pipeline implementation⚠️ SUGGESTION: Potential monitoring and validation approaches:
Automated benchmarks to prevent regressions
Frame timing and bottleneck profiling
Determinism validation across runs
⚠️ Major Unsolved Issues:
Frame rate coordination between different systems
GPU thread execution order determinism
Memory bandwidth optimization across modules
⚠️ SUGGESTION: Potential profiling capabilities to develop:
Frame timing monitoring for pipeline stages
GPU utilization tracking
Memory bandwidth analysis
Active region processing visualization
⚠️ SUGGESTION: Potential debugging tools:
Tile inspector for real-time data examination
Rule tracer for activation analysis
Determinism validation tools
]]></description><link>architecture/general/performance.html</link><guid isPermaLink="false">architecture/general/performance.md</guid><pubDate>Mon, 13 Oct 2025 23:15:21 GMT</pubDate></item><item><title><![CDATA[network-protocol]]></title><description><![CDATA[WebSocket-based communication protocol with optimized state synchronization and delta compression.WebSocket Connection: Persistent bidirectional communication
Message Format: Binary protocol with structured headers
Compression: LZ4 compression for large state updates
Reliability: Application-level acknowledgments and retransmission
Input Messages: Client actions (spell casts, movement)
State Updates: Server game state changes
Control Messages: Connection management and metadata
Heartbeat Messages: Connection health monitoring
interface NetworkMessage { type: MessageType; frameNumber: number; playerId: string; sequence: number; timestamp: number; checksum: number; payload: MessagePayload;
}
interface SpellCastInput { spellId: number; targetX: number; targetY: number; manaType: ManaType;
} interface MovementInput { direction: number; // 8-directional movement intensity: number; // 0-255 for analog input
} interface SpellSelectInput { spellIndex: number; handPosition: number;
}
interface TileDelta { x: number; y: number; layer: Layer; oldTile: number; // bit-packed tile data newTile: number; // bit-packed tile data
} interface PlayerUpdate { playerId: string; positionX: number; positionY: number; health: number; manaLevels: number[]; // array of mana amounts
} interface FullStateSnapshot { frameNumber: number; tileData: Uint32Array; // complete world state playerStates: PlayerUpdate[]; activeChunks: ChunkCoord[];
}
Change Detection: Only transmit modified tiles per frame
Run-Length Encoding: Compress sequences of identical tiles
Bit-Packing Efficiency: Leverage existing 32-bit tile format
Estimated Savings: 90% bandwidth reduction vs full state⚠️ NOT IMPLEMENTED: Active region system was decided against. Network optimization uses alternative strategies:
Spatial Compression: Group changes by geographic proximity
Change Detection: Only transmit modified tiles
Bandwidth Scaling: Optimized through efficient delta compression
LZ4 Algorithm: Fast compression/decompression for real-time use
Adaptive Compression: Skip compression for small messages
Dictionary Building: Maintain compression context across framesInput Messages: Send immediately on player action
State Deltas: Every frame (16.67ms at 60 FPS)
Full Snapshots: Every 60 frames (1 second) for recovery
Heartbeat: Every 5 seconds for connection monitoringSequence Numbers: Detect missing or duplicate messages
Acknowledgment System: Confirm receipt of critical updates
Retransmission: Resend lost messages with exponential backoff
Recovery Mode: Request full state snapshot on desyncCritical Updates: Player health, elimination, match state
High Priority: Direct player actions and immediate consequences
Medium Priority: Environmental changes and rule effects
Low Priority: Cosmetic updates and distant tile changes
Client Connection: WebSocket establishment
Authentication: Player credentials and session validation
Game Joining: Match assignment and initial state transfer
Synchronization: Frame alignment and latency measurement
Latency Measurement: Round-trip time calculation
Bandwidth Detection: Adaptive compression and update frequency
Connection Quality: Network stability monitoring
Fallback Modes: Reduced fidelity on poor connectionsGraceful Disconnect: Planned disconnection with state preservation
Timeout Detection: Automatic disconnection after communication failure
Reconnection: Resume gameplay with state synchronization
Ghost Mode: Temporary AI control during brief disconnectionsTarget Bandwidth: &lt;16MB per player per minute
Peak Optimization: Burst protection during high-activity periods
Regional Scaling: Reduced updates for distant regions
Predictive Filtering: Skip redundant state updatesMessage Batching: Combine multiple updates per frame
Predictive Transmission: Send likely state changes early
Compression Caching: Reuse compression dictionaries
Priority Queuing: Critical messages bypass normal queue// Efficient tile delta encoding
interface CompressedTileDelta { chunkId: number; // 16 bits - chunk identifier relativeTiles: number; // 10 bits - tiles changed in chunk deltaData: Uint8Array; // variable length - compressed changes
}
Input Sanitization: Validate all client inputs against game rules
Range Checking: Ensure coordinates and values within bounds
Rate Limiting: Prevent input flooding and spam
Checksum Verification: Detect message corruption or tamperingMessage Signing: Cryptographic signatures for critical messages
Sequence Validation: Detect replay attacks and message injection
Timing Verification: Validate message timestamps against server time
State Integrity: Server-side validation of all game state changesTLS Encryption: Secure WebSocket connections (WSS)
Session Management: Secure token-based authentication
DoS Protection: Rate limiting and connection throttling
IP Filtering: Geographic and reputation-based access controlThis protocol provides efficient, reliable communication optimized for Reaction's real-time gameplay requirements while maintaining competitive integrity.]]></description><link>architecture/systems/multiplayer/network-protocol.html</link><guid isPermaLink="false">architecture/systems/multiplayer/network-protocol.md</guid><pubDate>Mon, 13 Oct 2025 23:15:05 GMT</pubDate></item><item><title><![CDATA[multiplayer]]></title><description><![CDATA[Real-time PvP multiplayer architecture using authoritative servers with client-side prediction.The multiplayer system leverages Reaction's deterministic engine design to enable competitive real-time gameplay. An authoritative server runs the identical simulation while clients predict local actions to maintain responsive gameplay.Authoritative game simulation with GPU-accelerated processing identical to client engine.Local state prediction with rollback mechanisms for responsive gameplay despite network latency.WebSocket-based communication with optimized state synchronization and delta compression.Bandwidth optimization, server scaling, and latency management strategies.Input validation, state integrity, and cheat detection systems.Container orchestration, regional deployment, and horizontal scaling infrastructure.Core Engine Integration
Server runs headless version of identical simulation
Leverages existing GPU compute shaders for physics and reactions
Uses bit-packed tile format for efficient network transmission
Deterministic Design Benefits
Integer-only mathematics ensures identical client/server results
Simultaneous read/write GPU passes enable reliable rollback mechanisms
Active region system scales network bandwidth with activity level ⚠️ Active regions not implemented: Network optimization uses other strategies
WebGPU Compatibility
Server requires GPU-capable infrastructure
Compute shaders run identically on both client and server
Texture ping-ponging system adapted for network synchronization Core Networking: WebSocket protocol and basic state synchronization
Server Engine: Headless game engine with GPU compute capabilities
Client Prediction: Local state management with rollback
Performance: Bandwidth compression and server scaling
Security: Anti-cheat and input validation systems
Server Infrastructure
GPU-capable servers (NVIDIA T4 or equivalent)
WebGPU-compatible Node.js environment
16GB RAM per game instance (4-8 players)
Performance Targets
60 FPS authoritative simulation
&lt;50ms input processing latency
&lt;16MB bandwidth per player per minute
Support 100+ concurrent matches per server
This architecture provides competitive multiplayer performance while building on Reaction's existing deterministic engine design.]]></description><link>architecture/systems/multiplayer/multiplayer.html</link><guid isPermaLink="false">architecture/systems/multiplayer/multiplayer.md</guid><pubDate>Mon, 13 Oct 2025 23:14:50 GMT</pubDate></item><item><title><![CDATA[general]]></title><description><![CDATA[Core architectural concepts, design patterns, and system design documentation for Reaction v2.
<a class="internal-link" data-href="overview.md" href="architecture/general/overview.html" target="_self" rel="noopener nofollow"><strong></strong></a>System Overview - Complete architectural design and module relationships
<br><a class="internal-link" data-href="data-flow.md" href="architecture/general/data-flow.html" target="_self" rel="noopener nofollow"><strong></strong></a>Data Flow - Frame execution pipeline and module communication ⚠️ OUTDATED
<br><a class="internal-link" data-href="performance.md" href="architecture/general/performance.html" target="_self" rel="noopener nofollow"><strong></strong></a>Performance Strategy - Optimization approaches and technical constraints
<br><a class="internal-link" data-href="technical-decisions.md" href="architecture/general/technical-decisions.html" target="_self" rel="noopener nofollow"><strong></strong></a>Technical Decisions - Design choices and rationale <br><a class="internal-link" data-href="implementation-guide.md" href="architecture/general/implementation-guide.html" target="_self" rel="noopener nofollow"><strong></strong></a>Implementation Guide - Step-by-step implementation approach ⚠️ OUTDATED
<br><a class="internal-link" data-href="deterministic-execution.md" href="architecture/general/deterministic-execution.html" target="_self" rel="noopener nofollow"><strong></strong></a>Deterministic Execution - GPU determinism and cross-platform consistency ⚠️ PARTIALLY OUTDATED
<br><a class="internal-link" data-href="variable-timing.md" href="architecture/general/variable-timing.html" target="_self" rel="noopener nofollow"><strong></strong></a>Variable Timing System - Time slice scheduling and player action management ⚠️ PROPOSED
<br><a class="internal-link" data-href="state-management.md" href="architecture/general/state-management.html" target="_self" rel="noopener nofollow"><strong></strong></a>State Management - Snapshots, rollback, and multiplayer synchronization ⚠️ PROPOSED
<br><a class="internal-link" data-href="ghost-simulation.md" href="architecture/general/ghost-simulation.html" target="_self" rel="noopener nofollow"><strong></strong></a>Ghost Simulation - Predictive action visualization system ⚠️ PROPOSED
Modular Design: Modules with focused responsibilitiesWebGPU Processing: Physics, reactions, and rendering use GPU computeDeterministic Requirements: Identical inputs must produce identical outputs for PvP through simultaneous single-read/single-write GPU passesActive Region System: Process only chunks with changing tiles ⚠️ NOT IMPLEMENTED: Active region optimization was decided against⚠️ Unsolved Issues Requiring Design Work:
Frame rate coordination between physics, reactions, and rendering systems
GPU thread execution determinism guarantees (current approach: simultaneous read/write passes)
Specific rule compilation pipeline implementation
]]></description><link>architecture/general/general.html</link><guid isPermaLink="false">architecture/general/general.md</guid><pubDate>Mon, 13 Oct 2025 23:11:11 GMT</pubDate></item><item><title><![CDATA[architecture]]></title><description><![CDATA[High-level system design, technical decisions, and performance considerations for Reaction v2.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/overview.html" data-href="overview" aria-label="overview" data-tooltip-position="top" target="_self">System Overview</a> - Complete architectural design and module relationships
<br><a class="internal-link" data-href="general/general.md" href="architecture/general/general.html" target="_self" rel="noopener nofollow"><strong></strong></a>General Architecture - Core architectural concepts and design patterns <br><a class="internal-link" data-href="systems/systems.md" href="architecture/systems/systems.html" target="_self" rel="noopener nofollow"><strong></strong></a>Systems - Individual system modules and implementations
Modular Design: Modules with focused responsibilitiesWebGPU Processing: Physics, reactions, and rendering use GPU computeDeterministic Requirements: Identical inputs must produce identical outputs for PvP through simultaneous single-read/single-write GPU passesActive Region System: Process only chunks with changing tiles ⚠️ NOT IMPLEMENTED: Active region optimization was decided against⚠️ Unsolved Issues Requiring Design Work:
Frame rate coordination between physics, reactions, and rendering systems
GPU thread execution determinism guarantees (current approach: simultaneous read/write passes)
Specific rule compilation pipeline implementation Tile Storage: 4 layers (Ground, Object, Air, Rune) with bit-packed 32-bit tiles
Chunk Size: 32×32 tiles (balances GPU workgroup efficiency with memory overhead) ⚠️ Active region system not implemented
Processing Order: Input → Physics → Runes → Reactions → Render
Communication: Core Engine coordinates data flow between modules
]]></description><link>architecture/architecture.html</link><guid isPermaLink="false">architecture/architecture.md</guid><pubDate>Mon, 13 Oct 2025 23:10:55 GMT</pubDate></item><item><title><![CDATA[deterministic-execution]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed deterministic execution approach for GPU-accelerated physics and reactions. This system solves the fundamental challenge of achieving identical results across different hardware for competitive multiplayer.⚠️ CURRENT APPROACH: The actual determinism strategy being used is simultaneous single-read/single-write GPU passes with deterministic internal rules, NOT the spatial ordering strategy described below. The spatial ordering and active region approaches have been superseded.Core Issue: GPU thread execution order within workgroups is not inherently deterministic.Impact:
Non-deterministic collision resolution between tiles
Inconsistent force application results
Different outcomes on different hardware
Breaks competitive multiplayer requirements
Criticality: Essential for fair PvP gameplay and replay capability.⚠️ NOTE: The current architecture achieves determinism through simultaneous single-read and single-write GPU passes, with all operations happening at the same time using deterministic internal rules. This is NOT the spatial ordering strategy described in the following section.⚠️ OUTDATED: The following spatial ordering strategy is NOT being used in the current architecture.Chunk-Level Ordering: Process 32×32 chunks in strict spatial sequence (top-left to bottom-right).Tile-Level Ordering: Within each chunk, process tiles in deterministic spatial order.Player-Level Ordering: Process players in consistent ID-based sequence.// Deterministic tile processing within chunk
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in; void main() { // Map thread to deterministic tile position ivec2 chunkPos = getChunkPosition(); ivec2 localPos = ivec2(gl_LocalInvocationID.xy); ivec2 tilePos = chunkPos * 32 + localPos * 4; // Process 4 tiles per thread in spatial order for (int i = 0; i &lt; 4; i++) { ivec2 currentTile = tilePos + ivec2(i % 2, i / 2); processTileDeterministic(currentTile); }
}
Precision: 16.16 fixed-point format (16 bits integer, 16 bits fractional).Operations: All calculations use integer arithmetic to prevent floating-point drift.Cross-Platform Consistency: Identical results regardless of GPU floating-point implementation.class DeterministicMath { static readonly FIXED_POINT_SCALE = 65536; // 2^16 // Deterministic multiplication static multiply(a: number, b: number): number { return Math.floor((a * b) / this.FIXED_POINT_SCALE); } // Deterministic collision detection static checkCollision(pos1: Point, pos2: Point, radius: number): boolean { const dx = pos1.x - pos2.x; const dy = pos1.y - pos2.y; const distanceSquared = dx * dx + dy * dy; const radiusSquared = radius * radius; return distanceSquared &lt;= radiusSquared; } // Deterministic force resolution static resolveCollision(tile1: TileState, tile2: TileState): CollisionResult { // Use consistent tie-breaking rules const primaryTile = tile1.id &lt; tile2.id ? tile1 : tile2; const secondaryTile = tile1.id &lt; tile2.id ? tile2 : tile1; return this.calculateForces(primaryTile, secondaryTile); }
}
Execution Phases: Use compute barriers to enforce processing order between dependent operations.Memory Barriers: Ensure texture writes complete before subsequent reads.Workgroup Synchronization: Coordinate processing within and between workgroups.Read-Write Separation: Maintain existing texture ping-ponging for race condition prevention.Deterministic Swapping: Ensure texture role swapping occurs at consistent points.State Consistency: Verify texture state consistency across deterministic processing.Replay Tests: Identical input sequences must produce identical outputs.Hardware Variation Testing: Validate consistency across different GPU architectures.Stress Testing: Verify determinism under high load and complex scenarios.class DeterminismValidator { private frameChecksums = new Map&lt;number, string&gt;(); validateFrame(frameNumber: number, gameState: GameState): boolean { const checksum = this.calculateStateChecksum(gameState); const expectedChecksum = this.frameChecksums.get(frameNumber); if (expectedChecksum &amp;&amp; expectedChecksum !== checksum) { console.error(`Determinism failure at frame ${frameNumber}`); return false; } this.frameChecksums.set(frameNumber, checksum); return true; } private calculateStateChecksum(state: GameState): string { // Create deterministic hash of all relevant game state const stateData = this.serializeGameState(state); return this.deterministicHash(stateData); }
}
Determinism-First Design: Consider determinism impact of all changes.Validation Requirements: Test determinism before and after modifications.Code Review Focus: Explicit review of determinism implications.Documentation: Document assumptions about execution order and state dependencies.Overhead Analysis: Spatial ordering adds ~5-10% GPU processing overhead.Optimization Opportunities: Maintain determinism while optimizing memory access patterns.Fallback Strategies: ⚠️ NEEDS DISCUSSION - CPU fallback for determinism-critical operations if GPU determinism proves insufficient.Hardware Differences: Test across NVIDIA, AMD, and Intel GPU architectures.Driver Updates: Establish testing protocol for graphics driver changes.Compatibility Matrix: Maintain supported hardware and driver combinations.Optimization Constraints: Some GPU optimizations may break determinism.Testing Requirements: Extensive validation needed for any physics changes.Quality Assurance: Determinism testing integrated into CI/CD pipeline.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Time slice scheduling integration
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/performance.html" data-href="performance" aria-label="performance" data-tooltip-position="top" target="_self">Performance Strategy</a> - Optimization approaches with determinism constraints
⚠️ NEEDS IMPLEMENTATION: GPU compute shader templates for deterministic processing
Cross-platform validation test suite
Performance benchmarking of spatial ordering overhead
]]></description><link>architecture/general/deterministic-execution.html</link><guid isPermaLink="false">architecture/general/deterministic-execution.md</guid><pubDate>Mon, 13 Oct 2025 23:10:27 GMT</pubDate></item><item><title><![CDATA[implementation-guide]]></title><description><![CDATA[⚠️ OUTDATED IMPLEMENTATION PLAN: This document describes the implementation approach for an outdated Deterministic Time-Sliced Execution pipeline that is no longer being pursued. The current architecture uses simultaneous single-read/single-write GPU passes for determinism, does not use spatial ordering, and has decided against the active region optimization system.⚠️ PROPOSED IMPLEMENTATION PLAN: This document outlines the suggested implementation approach for the Deterministic Time-Sliced Execution pipeline. All timelines and priorities should be validated with the team.Goal: Establish deterministic frame processing with time slicing.Components:
DeterministicTimeSlicedPipeline - Main pipeline class
TimeSliceScheduler - Variable timing management DeterministicMath - Integer-only math library
StateSnapshotManager - Frame-based state capture
Success Criteria: 60 FPS deterministic execution with variable player action timing.Estimated Complexity: High - foundational architecture changes required.Goal: Achieve consistent GPU processing across platforms.Components:
SpatialOrderingStrategy - Deterministic tile processing order
DeterministicGPUProcessor - GPU compute shader coordination
FixedPointMath - GPU shader math library
DeterminismValidator - Cross-platform testing framework
Success Criteria: Identical results across different GPU hardware.Estimated Complexity: Very High - requires low-level GPU programming expertise.Goal: Unified state system for single-player and multiplayer.Components:
UnifiedGameEngine - Mode-agnostic game engine
RollbackManager - State restoration and replay
DeltaCompressor - Network-efficient state compression
ClientPredictionManager - Multiplayer prediction integration
Success Criteria: Seamless transition between single-player and multiplayer modes.Estimated Complexity: Medium - builds on established state management patterns.Goal: Predictive action visualization for player feedback.Components:
GhostSimulator - Lightweight prediction engine
GhostCacheManager - Performance optimization
GhostRenderer - Visual representation system AdaptiveComplexityManager - Performance scaling
Success Criteria: Clear action previews without performance impact.Estimated Complexity: Medium - primarily feature development on stable foundation.GPU Determinism: Cross-platform consistency may require extensive hardware testing.Performance Impact: Time slicing overhead needs careful optimization.Multiplayer Synchronization: Complex integration with existing network protocol.Incremental Development: Implement and validate each component independently.Performance Monitoring: Continuous benchmarking throughout development.Fallback Plans: CPU-based fallbacks for problematic GPU determinism cases.Texture Management: Adapt ping-ponging system for time-sliced execution.Active Regions: Integrate chunk processing with spatial ordering.API Changes: Update Core Engine API for new pipeline integration.Deterministic Processing: Replace existing physics with spatial ordering approach.Time Slice Integration: Adapt physics updates to variable frequency execution.Integer Mathematics: Convert physics calculations to fixed-point arithmetic.Action Scheduling: Replace immediate execution with time-slice scheduling.Mana Management: Implement separate timing system for mana recharge.Queue Management: Add 3-action lookahead system with ghost predictions.Automated Validation: CI/CD integration for determinism regression testing.Cross-Platform Testing: Validation across different GPU architectures.Performance Benchmarking: Continuous monitoring of pipeline overhead.Network Simulation: Test under various latency and packet loss conditions.Prediction Accuracy: Monitor client prediction success rates.Synchronization Validation: Ensure frame-perfect client-server alignment.Documentation: All new components require comprehensive documentation.Testing: Unit tests for deterministic components, integration tests for pipeline.Performance: Benchmark all changes against baseline performance metrics.Architecture Reviews: Major pipeline changes require team architectural review.Implementation Discussion: Technical details should be validated before implementation.Progress Tracking: Regular updates on implementation progress and blockers.
Frame Rate: Maintain 60 FPS with up to 8 players
Determinism: 100% consistency across identical inputs Latency: &lt;50ms total input-to-response latency in multiplayer
Memory: &lt;20% increase in memory usage for state management Cross-Platform: Identical results on all supported GPU architectures
Network Efficiency: &lt;16MB bandwidth per player per minute
User Experience: Smooth ghost predictions for all player actions cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Complete pipeline specification
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/deterministic-execution.html" data-href="deterministic-execution" aria-label="deterministic-execution" data-tooltip-position="top" target="_self">Deterministic Execution</a> - GPU determinism implementation
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Time slice scheduling details
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> - Unified state system architecture
⚠️ NEEDS TEAM VALIDATION:
Implementation timeline and resource allocation
Technical risk tolerance and fallback strategies Performance targets and quality requirements
Integration approach with existing codebase
]]></description><link>architecture/general/implementation-guide.html</link><guid isPermaLink="false">architecture/general/implementation-guide.md</guid><pubDate>Mon, 13 Oct 2025 23:10:01 GMT</pubDate></item><item><title><![CDATA[active-regions]]></title><description><![CDATA[Chunk-based processing optimization to avoid processing static regions.Purpose: Avoid processing static regions to maintain performance.Core Characteristic: Automatic scaling with activity level rather than world size.
Chunk Size: 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)
World Organization: Divide entire world into fixed chunk grid
Chunk Coordinates: Each chunk identified by (chunk_x, chunk_y) coordinates Active Chunk Buffer: GPU buffer maintains list of chunks with active tiles
Shader Processing: Shaders only process tiles in listed active chunks
Dynamic Updates: Chunks added/removed from active list based on tile changes Neighbor Activation: Activity automatically propagates to neighboring chunks
Movement Spreading: Moving tiles mark their destination chunks as active
Collision Effects: Collisions spread activity to neighboring regions
Gradual Decay: Activity in stable regions decays over time
@compute @workgroup_size(8, 8)
fn process_active_chunks(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let chunk_coord = active_chunks[workgroup_id.x]; let local_coord = global_id.xy; let world_coord = chunk_coord * 32u + local_coord; // Process only tiles in active chunks if (world_coord.x &lt; world_size.x &amp;&amp; world_coord.y &lt; world_size.y) { process_tile(world_coord); }
}
GPU Alignment: 32×32 chunks align well with GPU workgroup sizes
Memory Coalescing: Chunk-based processing improves memory access patterns
Thread Utilization: Reduces wasted GPU threads on empty regions
Activity-Based Cost: Processing cost scales with active tiles, not world size
Dormant Regions: Static areas have minimal GPU cost
Memory Access: Reduced texture memory accesses in inactive regions
Active Chunk Buffer: Small GPU buffer storing active chunk coordinates
Tracking Data: Minimal per-chunk metadata for activity state
Negligible Cost: Buffer size insignificant compared to texture memory
Tile Movement: Moving tiles activate their current and destination chunks
Spell Casting: Rune placement activates target chunks
Environmental Changes: Rule transformations mark chunks active
Force Application: Physics forces spread activation
⚠️ NEEDS DESIGN: Specific strategy for marking chunks inactive
Potential approaches: Timer-based decay, change detection, activity counters
Challenge: Balance between responsiveness and performance
Chunk Boundaries: Ensure proper handling of tiles affecting multiple chunks
Large Effects: Spells or explosions affecting many chunks simultaneously
Performance Spikes: Sudden activation of many dormant regions
Movement Processing: Physics updates active chunk list based on tile movement
Collision Detection: Collision effects activate neighboring chunks Rule Processing: Environmental transformations mark affected chunks active
Pattern Matching: Large-scale patterns may activate multiple chunks Rune Placement: Spell casting activates target chunks immediately
Area Effects: Large spells properly handle multi-chunk activation
⚠️ NEEDS SPECIFICATION: Detailed implementation approach for:
Active chunk buffer data structure
GPU buffer update mechanisms Integration with existing texture ping-ponging
Performance monitoring and tuning capabilities
]]></description><link>architecture/systems/core/active-regions.html</link><guid isPermaLink="false">architecture/systems/core/active-regions.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[core]]></title><description><![CDATA[Central coordination and tile data management for the Reaction v2 game engine.The Core Engine coordinates data flow between CPU spell logic and GPU simulation systems while maintaining high performance and deterministic execution.Key Challenge: Synchronize three different processing systems (CPU spells, GPU physics, GPU reactions) without race conditions or performance bottlenecks.
Bit-packed tile storage across 4 layers (Ground, Object, Air, Rune)
GPU texture management with ping-ponging for race-condition prevention Active region optimization using 32×32 chunks
Frame execution pipeline coordination <a class="internal-link" data-href="tile-storage.md" href="architecture/systems/core/tile-storage.html" target="_self" rel="noopener nofollow"><strong></strong></a>Tile Storage System - Bit-packing format and layer organization
<br><a class="internal-link" data-href="texture-management.md" href="architecture/systems/core/texture-management.html" target="_self" rel="noopener nofollow"><strong></strong></a>Texture Management - GPU texture coordination and ping-ponging
<br><a class="internal-link" data-href="active-regions.md" href="architecture/systems/core/active-regions.html" target="_self" rel="noopener nofollow"><strong></strong></a>Active Regions - Chunk-based processing optimization
<br><a class="internal-link" data-href="api-reference.md" href="architecture/systems/core/api-reference.html" target="_self" rel="noopener nofollow"><strong></strong></a>API Reference - Classes and integration points Ground Layer: Terrain foundation (dirt, stone, water)
Object Layer: Interactive entities (rocks, trees, creatures, players)
Air Layer: Gases and effects (fire, smoke, magic) Rune Layer: Spell-placed magical effects (temporary) Active Region System: Only process chunks with changing tiles
Texture Ping-Ponging: Prevents GPU read-after-write hazards
Bit-Packed Storage: 32-bit tile representation
Chunk-Based Processing: 32×32 tile regions Spell System: Writes rune data to rune layer textures
Physics Engine: Reads/writes velocity data via texture pairs
Reaction Engine: Processes transformation rules on tile data Renderer: Provides read-only access to current tile states for display
Game Logic: Exposes tile query API for validation and state checking WebGPU API: Required for texture management and GPU compute coordination
]]></description><link>architecture/systems/core/core.html</link><guid isPermaLink="false">architecture/systems/core/core.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[api-reference]]></title><description><![CDATA[Classes, interfaces, and integration points for the Core Engine system.⚠️ STATUS: API design has not been established yet. The following are suggestions for future design work.⚠️ SUGGESTION: Manages texture allocation and bit-packing operations.Potential Responsibilities:
Bit-packing and unpacking of tile data
Texture allocation and memory management
Layer-specific data access patterns
⚠️ NEEDS DESIGN: Detailed method signatures and data structuresHandles ping-ponging and GPU synchronization.Responsibilities:
Texture pair management for each layer
Ping-pong switching between frames
GPU resource lifecycle management
Synchronization barrier coordination
⚠️ NEEDS DESIGN: WebGPU integration patterns and error handlingCoordinates frame execution pipeline across all modules.Responsibilities:
Frame timing and execution order
Module coordination and communication
Performance monitoring and bottleneck detection
⚠️ NEEDS SPECIFICATION: Integration with different module update frequenciesOptimizes chunk-based processing across GPU modules.Responsibilities:
Active chunk list management
Activity propagation logic
GPU buffer updates for active regions
Performance scaling based on activity
⚠️ NEEDS SPECIFICATION: Activity detection and decay algorithmsRune Placement API:// Preliminary interface - subject to change
interface RunePlacementAPI { placeRune(position: TileCoord, rune: RuneData): void; removeRune(position: TileCoord): void; queryRune(position: TileCoord): RuneData | null;
}
Velocity Management API:// Preliminary interface - subject to change
interface VelocityAPI { setVelocity(position: TileCoord, velocity: Vector2): void; getVelocity(position: TileCoord): Vector2; applyForce(position: TileCoord, force: Vector2): void;
}
Tile State API:// Preliminary interface - subject to change interface TileStateAPI { getTile(position: TileCoord, layer: LayerType): TileData; setTile(position: TileCoord, layer: LayerType, data: TileData): void; queryNeighborhood(center: TileCoord, radius: number): TileData[];
}
Read-Only Display API:// Preliminary interface - subject to change
interface DisplayAPI { getCurrentTileState(position: TileCoord): LayeredTileData; getVisibleRegion(viewport: Rectangle): TileData[]; subscribeToChanges(callback: (changes: TileChange[]) =&gt; void): void;
}
⚠️ NEEDS FINALIZATION: Specific bit allocation during implementation// Preliminary structure - bit allocation TBD
interface TileData { type: number; // ~6 bits - tile type identifier velocity: Vector2; // 16 bits - movement vector (signed) customData: number; // ~10 bits - health, timers, charges
}
enum LayerType { Ground = 0, // Terrain foundation Object = 1, // Interactive entities Air = 2, // Gases and effects Rune = 3 // Spell-placed effects
}
interface TileCoord { x: number; y: number;
} interface ChunkCoord { chunkX: number; chunkY: number;
}
⚠️ NEEDS DESIGN: Comprehensive error handling strategy for:
GPU resource allocation failures
WebGPU device lost scenarios Texture memory exhaustion
Invalid tile coordinate access
Synchronization failures
⚠️ NEEDS IMPLEMENTATION: Built-in profiling capabilities for:
Frame timing breakdown by module
GPU utilization and memory bandwidth
Active region processing efficiency
Texture ping-pong overhead measurement WebGPU API: Core dependency for all GPU operations
TypeScript: Type safety and development experience Integration with all other game modules
Shared type definitions across the codebase
Common utility functions and error types
]]></description><link>architecture/systems/core/api-reference.html</link><guid isPermaLink="false">architecture/systems/core/api-reference.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[tile-storage]]></title><description><![CDATA[Problem: GPU shaders need packed data, but game logic needs flexible representations.Solution: Bit-packed 32-bit tiles stored in GPU textures.
Ground Layer: Terrain foundation (dirt, stone, water)
Object Layer: Interactive entities (rocks, trees, creatures)
Air Layer: Gases and effects (fire, smoke, magic) Rune Layer: Spell-placed magical effects (temporary)
Note: Specific bit allocation TBD during implementation. Approximate layout:
Tile Type (~6 bits, chosen for comfortable headroom)
Velocity X/Y (signed values for movement)
Custom Data (remaining bits for health, timers, charges)
Texture Ping-Ponging: Each layer uses paired textures (layer_A, layer_B) enabling GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards.Memory Layout: Textures use r32uint format for optimal GPU cache performance.Purpose: Avoid processing static regions to maintain performance.Implementation:
Divide world into 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)
Track chunks with active tiles in GPU buffer
Shaders only process listed active chunks
Activity propagates to neighboring chunks automatically
Dormant regions have minimal GPU cost TileStorage: Manages texture allocation and bit-packing
TextureManager: Handles ping-ponging and synchronization
GameLoop: Coordinates frame execution pipeline
ActiveRegionTracker: Optimizes chunk-based processing Spell System: Writes rune data to rune layer textures
Physics Engine: Reads/writes velocity data via texture pairs
Reaction Engine: Processes transformation rules on tile data
Renderer: Reads current tile states for display
]]></description><link>architecture/systems/core/tile-storage.html</link><guid isPermaLink="false">architecture/systems/core/tile-storage.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[gpu]]></title><description><![CDATA[Shared WebGPU resource management and coordination for all GPU-accelerated systems.The GPU Manager System manages the WebGPU instance, device initialization, and resource sharing across all systems that require GPU computation or rendering.Key Challenge: Coordinate GPU resource usage across multiple systems (Physics, Reactions, Renderer) while maintaining performance and preventing resource conflicts.
WebGPU device initialization and capability detection
GPU resource allocation and memory management
Compute pipeline coordination between systems
Error handling and recovery for GPU operations
Performance monitoring and resource utilization tracking WebGPU Device: Single device instance shared across all systems
Buffer Pools: Reusable buffer allocation for different data types
Texture Management: Coordinate texture creation and lifecycle
Compute Queue: Prioritized command queue for GPU operations Physics System: Provides compute shaders for collision and movement
Reactions System: Manages rule compilation and execution shaders Renderer: Coordinates rendering pipeline and display
Core System: Integrates with texture ping-ponging and memory management Automatic Fallback: Handle WebGPU unavailability gracefully
Capability Detection: Query and adapt to GPU limitations
Error Recovery: Robust handling of GPU context loss
Performance Profiling: Built-in GPU timing and resource monitoring Allocation Tracking: Monitor buffer and texture usage across systems
Memory Optimization: Efficient sharing and reuse of GPU resources
Priority Management: Coordinate competing GPU workloads
Synchronization: Ensure proper ordering of GPU operations Device Setup: Initialize WebGPU device with required features
System Registration: Allow systems to register their GPU requirements
Resource Allocation: Provide standardized buffer/texture allocation Command Submission: Centralized GPU command queue management
Resource Sharing: Safe sharing of buffers and textures between systems
Performance Monitoring: Real-time GPU utilization reporting WebGPU API: Required for all GPU operations
Browser/Platform: WebGPU support and capabilities
]]></description><link>architecture/systems/gpu/gpu.html</link><guid isPermaLink="false">architecture/systems/gpu/gpu.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[v1-data-strategies]]></title><description><![CDATA[This document captures data organization and packing techniques from V1 to inform V2's bit-packed tile system design. V1 demonstrated sophisticated GPU-optimized data structures that V2 developers should understand when designing the core engine's tile storage.Source: Analysis of V1 data structures (src/rules/rules.ts, src/core/types.ts, src/graphics/shaders/reaction.wgsl)
Status: Reference material for V2 data architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 data structures and hasn't been reviewed by the team.V1 Architecture: Rules stored as packed data in 128×128 GPU textureTexture format: r32uint (32-bit unsigned integers)
Total capacity: 16,384 × 32 bits = 64KB rule storage
Organization: 4 u32s horizontally per tile type, 16 vertically per reaction
Spatial Organization Pattern:X-axis: tile_type * 4 + data_column (0-3)
Y-axis: reaction_index * 16 + condition_index (0-15)
Data access: textureLoad(rules, vec2u(x_coord, y_coord))
Personal Assessment: This layout optimized GPU cache access for spatially-related rule queries.My Interpretation: The 4×16 block per reaction ensured related data stayed within GPU cache lines.V1 Condition Data Format (9 bits per leaf condition):Bit allocation:
- Tile type: 5 bits (0-31, accommodating enum value 20 for sand)
- Direction: 3 bits (8 compass directions) - Distance: 1 bit (1 or 2 tiles away) Packing formula: (tile_type &lt;&lt; 4) | (direction &lt;&lt; 1) | distance_bit
Personal Observation: This encoding maximized information density while staying within GPU bit manipulation capabilities.V1 Internal Node Encoding (2 bits per operator):Operator types: AND=0, OR=1, NOR=2, NAND=3
Packed format: 7 operators × 2 bits = 14 bits total
Storage: Combined with condition value in single u32
My Assessment: This allowed complex logical trees in minimal memory.V1 Reaction Block Format (4 u32s × 16 conditions):u32[0]: (modes &lt;&lt; 15) | (value &lt;&lt; 10) | (bias &lt;&lt; 5) | result_tile
u32[1]: leaf_conditions[0,1,2] packed as 3×9 bits + padding
u32[2]: leaf_conditions[3,4,5] packed as 3×9 bits + padding u32[3]: leaf_conditions[6,7,8] packed as 3×9 bits + padding
Personal Note: This distributed related data across multiple texture coordinates while maintaining efficient access.Packed Leaf Storage (3 conditions per u32):Bit layout per u32: [condition2][condition1][condition0][padding]
Bit offsets: 0, 9, 18 bits (LSB-first packing)
Extraction: (packed_data &gt;&gt; bit_offset) &amp; 0b111111111
My Interpretation: This maximized data density while allowing parallel condition evaluation.Contributor: Claude Status: Individual analysis of data flowPersonal Addition: These data access observations haven't been discussed with the team.V1 Rule Loading Strategy: Batch pre-fetch for condition evaluationRule queries per tile:
- Base reaction data: 1 texture read (bias, result_tile, modes)
- Leaf condition data: 3 texture reads (chunks 0-2, 3-5, 6-8)
- Total per condition: 4 texture reads maximum
Personal Assessment: This minimized GPU memory bandwidth by batching related reads.Cache-Friendly Access Pattern:Spatial locality: Consecutive X coordinates for condition chunks
Temporal locality: All rule data for one condition read together
Memory coalescing: Adjacent GPU threads access adjacent texture coordinates
My Interpretation: V1 was designed around GPU memory hierarchy optimization.V1 Initialization Approach: Pre-populate with "do nothing" defaultsDefault leaf value: tile=31, direction=0, distance=1 (encoded as 496)
Default packed chunk: 3 leaves = 130,277,872
Default condition modes: value=0, modes=0 (AND tree)
Personal Observation: This eliminated special case handling during rule evaluation.Bounds Safety Pattern:Out-of-bounds behavior: Default values ensure safe evaluation
Missing rules: "Do nothing" transformation (tile unchanged)
Invalid data: Graceful degradation rather than crashes
My Assessment: This defensive programming approach ensured robust GPU execution.Contributor: Claude Status: Individual analysis needing validationPersonal Addition: These efficiency observations need team discussion for V2 design.V1 Rule Capacity (calculated from observed limits):Maximum tile types: 32 (5-bit encoding)
Maximum reactions per type: 8
Maximum conditions per reaction: 16
Maximum tree complexity: 7 internal nodes + 8 leaves per condition
Storage Efficiency:Bits per condition: 32 × 4 = 128 bits
Information density: ~9 bits condition data + 14 bits modes + 10 bits scoring
Utilization: ~33 bits useful data / 128 bits storage ≈ 26% efficiency
Personal Assessment: V1 prioritized access speed over storage efficiency.My Interpretation: The 74% "waste" provided padding for GPU cache alignment and simplified addressing.V1 Memory Bandwidth Usage (estimated):Texture reads per tile evaluation:
- Rule base data: 1 × 32 bits = 32 bits
- Condition chunks: 3 × 32 bits = 96 bits - Shared cache reads: ~144 × 32 bits = 4,608 bits (amortized across workgroup)
Personal Calculation: ~128 bits rule data + ~72 bits shared cache per tileMy Assessment: V1's bandwidth usage was reasonable for the computational complexity achieved.V1 Scaling Limitations (observed):Rule texture size: Fixed 128×128 (no dynamic scaling)
Tile type limit: 32 types maximum (5-bit field)
Reaction complexity: 16 conditions maximum per reaction
Memory usage: Linear with rule complexity
Personal Concern: V1's fixed limits might not scale to V2's ambitions.Research Questions:
How do V1's limits compare to V2's requirements?
Should V2 use similar fixed-size allocations or dynamic scaling?
Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Approach: Complex multi-level packing with specialized extraction
V2 Planned: Bit-packed tiles with ~6 bits type + velocity + custom dataPersonal Questions:
Should V2 use V1's sophisticated bit manipulation techniques?
How will V2's 4-layer system affect packing complexity?
Will V2's real-time requirements allow V1-style complex unpacking?
My Assessment: V2 might benefit from simpler packing schemes than V1's intricate system.V1 Evidence: GPU texture storage with cache-optimized layout
V2 Plans: Texture ping-ponging with active region optimizationCompatibility Questions:
Can V2's active regions use V1's texture organization principles?
Should V2 pre-allocate like V1 or use dynamic allocation?
How do V2's performance targets compare to V1's memory usage patterns?
Team Discussion Needed: Memory allocation strategy for V2's different requirements.V1 Approach: Maximum density through complex bit manipulation
V2 Considerations: Balance between efficiency and implementation complexityPersonal Assessment: V1's approach was sophisticated but complex to implement and debug.Research Needed: Whether V2's requirements justify V1-level complexity.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific data design considerations for V2.V1 Evidence: Complex packing achieved high data density and good GPU performance
V2 Trade-offs: Implementation complexity vs memory/performance benefitsResearch Questions:
What are V2's memory constraints compared to V1?
How important is V1-level data density for V2's goals?
Should V2 prioritize development simplicity or runtime efficiency?
Team Discussion Needed: Performance requirements vs implementation complexity balance.V1 Success: Texture-based storage with spatial organization
V2 Considerations: How to adapt V1's principles to V2's 4-layer systemDesign Questions:
Should V2 layers share V1's texture organization approach?
How do V2's physics requirements affect data layout needs?
Will V2's active region system benefit from V1's spatial locality patterns?
Personal Assessment: V2 should consider adapting V1's spatial organization principles.V1 Limitations: Fixed sizes and hardcoded limits
V2 Opportunities: More flexible systems while preserving V1's efficiencyResearch Areas:
Dynamic data allocation vs V1's pre-allocation approach
Configurable complexity limits vs V1's hardcoded maximums
Runtime data modification vs V1's compile-time rule baking
Team Input Needed: V2's flexibility requirements vs performance constraints.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These data architecture recommendations need team review before consideration.
Spatial data organization for GPU cache efficiency
Batch data access to minimize memory bandwidth
Default value strategies for robust error handling
Bit-level packing where density justifies complexity Layer-aware organization for V2's 4-layer tile system
Active region integration with V1's spatial locality principles
Flexible scaling beyond V1's fixed limits
Simplified packing for easier development while preserving core efficiency Dynamic allocation instead of V1's fixed texture sizes
Configurable complexity instead of hardcoded limits
Development tools for debugging complex data structures
Performance monitoring for data access pattern optimization
Status: All recommendations need team evaluation and data architecture planning.Personal Suggestions (not discussed with team):
Prototype V2 bit-packing using lessons from V1's techniques
Benchmark data access patterns comparing V1 approaches with V2 requirements Design data validation tools to avoid V1's debugging complexity
Plan scalability testing for V2's data structures under various load scenarios
Status: All suggestions need team review and core engine architecture planning.]]></description><link>legacy/v1-data-strategies.html</link><guid isPermaLink="false">legacy/v1-data-strategies.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[v1-gpu-patterns]]></title><description><![CDATA[This document captures GPU optimization strategies from V1 to inform V2 compute shader design. V1's reaction compute shader contained sophisticated optimization patterns that V2 developers should understand when designing the core engine's GPU architecture.Source: Analysis of V1 compute shader (src/graphics/shaders/reaction.wgsl)
Status: Reference material for V2 GPU architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 GPU code and hasn't been reviewed by the team.V1 Pattern Observed: Sophisticated neighborhood caching systemWorkgroup size: 8×8 threads (64 total)
Cache dimensions: 12×12 tiles (144 total)
Border padding: 2 tiles in each direction
Memory layout: array&lt;array&lt;u32, 12&gt;, 12&gt;
Caching Algorithm:
Each thread loads multiple cache pixels (144 pixels ÷ 64 threads = ~2.25 pixels per thread)
Linear cache index distribution across threads
Wrap-around coordinate calculation for world boundaries
Workgroup barrier synchronization before shared memory reads
Personal Assessment: This eliminated redundant texture reads for neighbor checks, likely providing significant performance benefits.My Interpretation: The 2-tile border allowed checking neighbors at distance 1 and 2 without additional texture fetches.V1 Coordinate Calculation Pattern:Global origin: workgroup_id * workgroup_size - cache_offset
Linear thread mapping: local_id.y * workgroup_size_x + local_id.x Wrap-around handling: (coord % tex_dims + tex_dims) % tex_dims
Personal Observation: This avoided branching and handled torus world topology efficiently.Cache Access Pattern:Cache position: local_coordinate + cache_offset + relative_neighbor_offset
No bounds checking: Relied on cache being large enough for all valid accesses
My Assessment: This trusted the cache dimensions to handle all possible neighbor accesses within the 2-tile radius.V1 Pattern: Dual texture approach for race condition prevention
Input texture: Read-only during compute pass
Output texture: Write-only during compute pass Swap textures between frames
Personal Note: This matches V2's planned ping-ponging strategy, validating the approach.Contributor: Claude Status: Individual analysis of GPU optimizationPersonal Addition: These observations from V1's data access patterns haven't been discussed with the team.V1 Approach: Minimize texture reads through strategic batchingRule data chunks: 3 texture reads for 9 leaf conditions (3 conditions per u32)
Chunk storage: array&lt;u32, 3&gt; for indexed access
Pre-computation: All rule data loaded before tree evaluation
Personal Interpretation: This reduced GPU memory bandwidth usage by batching related data.My Assessment: V2's rule compilation should consider similar data locality optimization.V1 Pattern: Efficient tree traversal without recursionNode results array: Fixed-size array for all tree nodes
Bottom-up evaluation: Leaves first (indices 7-15), then internal nodes (6 down to 0)
Loop-based traversal: Avoided GPU recursion limitations
Personal Note: This was a clever solution to GPU architectural constraints.My Concern: V2's JSON compilation needs similar tree evaluation efficiency.V1 Optimization: Early exit on symmetry successSymmetry loop: 8 iterations (rotations and reflections)
Early termination: Break immediately when any symmetry evaluates true
Result aggregation: OR operation across all symmetries
Personal Assessment: This reduced unnecessary computation when patterns matched early.What I Don't Know: Whether V2's compiled rules will include similar short-circuit optimizations.Contributor: Claude Status: Individual analysis of GPU synchronizationPersonal Addition: These synchronization observations need team consideration for V2.V1 Processing Phases:
Cache Loading Phase: All threads cooperatively load neighborhood data
Synchronization Barrier: workgroupBarrier() ensures cache completion
Independent Processing Phase: Each thread processes its assigned tile
Personal Observation: Clear separation between cooperative and independent work.My Interpretation: This maximized GPU efficiency by aligning with hardware capabilities.V1 Cache Loading Strategy:Work distribution: (cache_pixels + num_threads - 1) / num_threads // Ceiling division
Load balancing: Each thread loads 0-3 cache pixels depending on position
Bounds checking: Prevents threads from loading beyond cache dimensions
Personal Assessment: This ensured even work distribution across the workgroup.My Note: V2 should consider similar load balancing for any cooperative operations.V1 Synchronization Points:
Single workgroupBarrier() after cache loading
No additional barriers during tree evaluation
Independent tile processing without cross-thread communication
Personal Interpretation: Minimal synchronization overhead while ensuring data consistency.Personal Question: Will V2's active region system require additional synchronization?Contributor: Claude Status: Individual assessment needing team discussionPersonal Addition: These performance observations haven't been validated with actual measurements.V1 Work per Tile:
Reaction evaluation: Up to 8 reactions per tile type
Condition evaluation: Up to 16 conditions per reaction Symmetry testing: 8 geometric transformations per condition
Tree traversal: 7 internal nodes + 8 leaf evaluations
Personal Calculation: Worst case ~8×16×8×15 = 15,360 operations per tileMy Assessment: This suggests V1 could handle very complex environmental behaviors, but at computational cost.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations.V1 Memory Footprint per Workgroup:
Shared cache: 144 × 32-bit = 576 bytes
Node results array: 16 × 1-bit = 2 bytes (negligible)
Rule data cache: 3 × 32-bit = 12 bytes per condition
Personal Note: Shared memory usage was well within typical GPU limits.What I Don't Know: How V2's bit-packed tile format will affect memory access patterns.V1 Texture Access Patterns:
Input texture reads: 1 per cache pixel (coalesced across workgroup)
Rules texture reads: 4 per tile (base + 3 condition chunks)
Output texture writes: 1 per tile
Neighbor access: From cache (no additional texture reads)
Personal Assessment: Well-optimized memory access pattern with minimal bandwidth waste.My Concern: V2's 4-layer system may increase memory bandwidth requirements.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific GPU architecture considerations for V2.V1 Evidence: 8×8 workgroups with 12×12 cache worked well for 2-tile radius operationsResearch Questions for V2:
Should V2 use similar workgroup dimensions?
How does V2's active region system (32×32 chunks) align with workgroup sizes?
Will V2's tile operations require different neighbor access patterns?
Team Discussion Needed: Workgroup sizing based on V2's specific requirements.V1 Strategy: Heavy use of workgroup shared memory for cachingV2 Considerations:
Does V2's 4-layer system benefit from similar caching?
Should V2 cache active region metadata in shared memory?
How do V2's bit-packed tiles affect cache efficiency?
Research Needed: Performance testing of V2 memory access patterns.V1 Evidence: Minimal synchronization (single barrier) provided good performanceV2 Questions:
Will V2's physics integration require additional synchronization?
Does V2's active region updating need workgroup coordination?
Should V2 pipeline different processing phases differently?
Personal Assessment: V2 may need more complex synchronization than V1.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These design recommendations need team review before consideration.
Workgroup shared memory caching for neighbor access optimization
Phase-based processing with clear synchronization points Early exit optimizations where applicable
Texture ping-ponging (already planned for V2) Scale caching strategy for V2's 4-layer tile system
Integrate active region optimization with V1's workgroup patterns
Consider rule compilation targeting similar GPU optimization patterns Complexity vs Performance: V1 handled very complex rules - should V2 target similar capability?
Memory vs Computation: V1 used memory to reduce computation - is this optimal for V2?
Synchronization Overhead: Will V2's additional systems require more GPU barriers?
Status: All recommendations need team evaluation and design discussion.Personal Suggestions (not discussed with team):
Prototype V2 compute shaders using V1 optimization patterns as starting point
Benchmark memory access patterns for V2's bit-packed 4-layer system
Design active region processing to leverage V1's workgroup coordination strategies
Test synchronization requirements for V2's multi-system integration
Status: All suggestions need team review and implementation planning.]]></description><link>legacy/v1-gpu-patterns.html</link><guid isPermaLink="false">legacy/v1-gpu-patterns.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[v1-reference]]></title><description><![CDATA[This document captures fundamental concepts and mathematical algorithms from the V1 rules engine to inform V2 development. V1 contained sophisticated rule evaluation systems that V2 developers should understand when designing the JSON compilation pipeline.Source: Analysis of V1 legacy codebase (archived)
Status: Reference material for V2 design considerationContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 code and hasn't been reviewed by the team.V1 Approach: Rules were evaluated across 8 geometric transformations (4 rotations × 2 reflections) to create symmetric environmental behaviors.Mathematical Pattern Observed:Rotation calculation: (symmetry &gt;&gt; 1u) &lt;&lt; 1u // Even number rotations
Reflection: select(1, -1, (symmetry &amp; 1u) != 0u) // Flip on odd symmetries
Final position: scale * flip * base_direction_vector
My Assessment: This created natural-looking environmental effects where fire spreading, water flow, etc. worked consistently in all directions.Personal Concern: V2's JSON compilation needs to handle similar geometric transformations or environmental effects may look artificial.V1 Pattern: Complex conditions organized as binary trees with packed evaluation:
7 internal nodes (operators: AND, OR, NOR, NAND)
8 leaf nodes (spatial conditions)
Bottom-up evaluation from leaves to root
Data Packing Observed:
Internal node modes: 2 bits each, packed into 14 bits total
Leaf conditions: 9 bits each (5-bit tile type, 3-bit direction, 1-bit distance)
Evaluation results: Boolean array with indices mapping to tree structure
My Interpretation: This allowed arbitrarily complex logical conditions while maintaining GPU efficiency.Personal Question: How will V2's JSON compilation achieve similar complexity without runtime memory overhead?V1 Bias System:
Base reaction bias: signed 5-bit value (-16 to +15)
Condition contributions: signed values added when conditions met
Winning rule: highest total score after all conditions evaluated
Personal Observation: This created emergent behaviors where multiple environmental effects competed naturally (e.g., fire spreading vs water extinguishing).What I Don't Know: Whether V2's competitive scoring will replicate this mathematical sophistication.Contributor: Claude Status: Individual analysis of compute shaderPersonal Addition: These observations from V1's GPU implementation haven't been discussed with the team.V1 Pattern: 12×12 shared memory cache for 8×8 workgroup with 2-tile border
Each thread loads multiple cache pixels to fill neighborhood
Workgroup barrier synchronization before condition evaluation
Eliminates redundant texture reads for neighbor checks
My Assessment: This optimization was sophisticated and likely provided significant performance benefits.Personal Concern: V2 GPU shader design should consider similar caching strategies.V1 Approach: Pre-computed direction offset arrays with wrap-around handlingDirection offsets: 8 compass directions as vec2i
Wrap-around: (global_coord % tex_dims + tex_dims) % tex_dims
Cache position: local_coord + cache_offset + relative_position
Personal Note: This handled world boundaries elegantly while maintaining cache efficiency.V1 Pattern: Batch-loaded rule data chunks before evaluation
3 texture reads for all 9 possible leaf conditions
Stored in array for indexed access during tree evaluation
Minimized GPU texture bandwidth usage
My Interpretation: This was a carefully optimized memory access pattern.Contributor: Claude Status: Questions identified from V1 analysisPersonal Assessment: These issues need team discussion based on V1 complexity:Question: How will V2's JSON compilation handle the mathematical sophistication of V1's binary tree evaluation and 8-fold symmetry?V1 Evidence: Rules could express conditions like "fire spreads if 2+ fire neighbors AND no water within 2 tiles AND not in NW/NE corners"My Concern: V2 JSON format may need significant complexity to match V1 expressiveness.Question: Will V2 replicate V1's shared memory optimizations or use different strategies?V1 Evidence: Complex workgroup coordination and cache management in compute shaderPersonal Assessment: V2 might benefit from studying V1's memory access patterns before designing new shaders.Question: How will V2 ensure deterministic evaluation order that V1 achieved?V1 Evidence: Strict tile-by-tile processing with consistent neighbor checking orderWhat I Don't Know: Whether V2's approach will maintain this level of determinism.Identified by: Claude Status: Team input neededPersonal Assessment: V1 performance characteristics need measurement, but patterns suggest optimization priorities.
128×128 texture for rules (16,384 × 32-bit values = 64KB rule storage)
Workgroup shared memory: 144 × 32-bit values per workgroup
Dual texture ping-ponging: 2× map memory usage
My Interpretation: V1 traded memory for computational efficiency.Research Needed: Actual performance measurements and comparison with V2 targets.
8 symmetry evaluations per condition
Binary tree evaluation with up to 7 internal nodes
16 conditions maximum per reaction
8 reactions maximum per tile type
Personal Note: This suggests V1 could handle very complex environmental behaviors.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations for simplicity.Personal Recommendations (not discussed with team):
Study V1's mathematical patterns before finalizing JSON compilation approach
Consider V1's GPU optimization strategies for V2 shader architecture Evaluate whether V2 competitive scoring can achieve V1's sophistication
Plan for complexity testing to ensure V2 can handle intricate environmental behaviors
Status: All recommendations need team review and discussion.]]></description><link>legacy/v1-reference.html</link><guid isPermaLink="false">legacy/v1-reference.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[v1-visual-effects]]></title><description><![CDATA[This document captures visual rendering techniques from V1 to inform V2 renderer design. V1's render shader contained sophisticated visual effects that created distinct, animated appearances for different tile types.Source: Analysis of V1 render shader (src/graphics/shaders/render.wgsl)
Status: Reference material for V2 visual design decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 rendering code and hasn't been reviewed by the team.V1 Water Effect: Complex wave system using multiple sine functionsWave components (observed):
- Wave 1: sin(worldUV.x * 3.2 + time * 1.03) * 0.5 (primary horizontal)
- Wave 2: sin(worldUV.y * 14.0 - time * 1.3) * 0.25 (vertical fine)
- Wave 3: sin(worldUV.y * 8.3 + time * 1.5) * 0.25 (vertical medium)
- Wave 4: sin((worldUV.x + worldUV.y) * 13.7 - time * 0.8) * 0.15 (diagonal)
- Wave 5: sin((2.43 * worldUV.x + 3.0 * worldUV.y) * 15.5 - time * 1.2) * 0.12 (complex)
- Wave 6: sin((worldUV.x - 1.3 * worldUV.y) * 16.7 - time * 0.7) * 0.1 (counter-diagonal)
Personal Assessment: This created realistic water movement with multiple overlapping wave patterns.Color Blending System:Base colors: Deep blue (#0099CC) to cyan (#33CCFF)
Height mapping: Wave height influences color interpolation
Highlight system: White foam on wave peaks using smoothstep
My Interpretation: The multi-wave approach created natural-looking water with depth variation.Personal Note: V2 should consider similar layered animation techniques for environmental immersion.V1 Grass Blade Technique: Individual blade rendering within each tileBlade positioning: Offset by sine(time + worldUV.y * 2) for wind effect
Blade dimensions: Triangle-based blade shapes with height variation
Dual blade system: Two offset blade patterns per tile for density
Blade Generation Algorithm:Blade coordinate mapping: (worldUV * 10) % 1 for repeating pattern
Blade shape: 1 - abs(bladepos.x - 0.5) * 2 (triangle profile)
Height variation: bladepos.y-based cutting for blade tips
Wind animation: X-offset by sine function creates swaying
Personal Assessment: This created convincing grass appearance at the tile level.Color System:Base colors: Dark green (#1A4D33) to bright green (#19FF19)
Height-based mixing: Taller blade portions lighter
Highlight integration: White highlights on blade tips
My Interpretation: The procedural approach provided detailed grass without requiring texture assets.V1 Lava Effect: Similar wave system to water but with different parametersWave pattern: Subset of water waves (4 components instead of 6)
Color palette: Orange-red (#FF3300) to yellow-orange (#FFCC80)
Highlight system: Pink-magenta highlights (#FF80FF) on wave peaks
Personal Observation: Lava reused water's animation framework with different visual parameters.My Assessment: This suggests V2 could use unified animation systems with material-specific parameters.V1 Noise Functions: Multiple noise layers for various effectsBasic Perlin: Standard 2D Perlin noise with gradient interpolation
Fractal Brownian Motion (FBM): 4 octaves of layered noise
Hash function: Deterministic pseudo-random for gradient generation
Noise Applications Observed:
Mountain height maps with contour effects
Terrain distortion for organic tile boundaries
Texture variation within tile types
Personal Note: V2 should consider noise as a fundamental rendering primitive.V1 Distortion System: World UV coordinates modified by noiseDistortion calculation: Perlin noise at multiple scales
Application: UV += distortion_vector before tile sampling
Effect: Organic, non-grid-aligned visual boundaries
Personal Assessment: This helped disguise the underlying grid structure.Tile Edge Softening:Distance calculation: max(abs(tileUV.x-0.5), abs(tileUV.y-0.5)) * 2 - 0.2
Falloff function: 1 - pow(square_dist, 6.0)
Application: Multiply final color by falloff
My Interpretation: This created soft tile boundaries and visual cohesion.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These material observations need team consideration for V2 visual design.V1 Material Definitions:
Water: Blue spectrum with white foam highlights
Lava: Orange-red spectrum with magenta highlights
Magic: Purple-green spectrum (similar animation to water)
Grass: Green spectrum with procedural blade geometry
Void: Animated mountain texture with brown/purple palette
Personal Observation: Each material had distinct color relationships and animation characteristics.My Assessment: V2 should define similar material systems for consistent visual identity.V1 Color Blend Patterns:Height-based interpolation: mix(deepColor, lightColor, height_factor)
Highlight overlays: mix(baseColor, highlightColor, highlight_strength)
Time-based variation: Colors influenced by animation state
Personal Note: This created natural-looking material variation without texture sampling.Material Property System (inferred):
Base color ranges per material type
Animation amplitude and frequency per material
Highlight color and trigger thresholds per material
My Interpretation: V2 could benefit from similar parameterized material systems.V1 Shader Efficiency Patterns:
Switch statement for tile type selection (GPU-friendly branching)
Shared mathematical functions across material types
Single-pass rendering with material-specific logic branches
Personal Assessment: V1 balanced visual complexity with rendering performance.Mathematical Function Reuse:
Perlin noise used across multiple material types
Wave functions shared between water, lava, and magic
Color interpolation patterns repeated across materials
My Note: V2 should consider similar function reuse for consistency and performance.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Evidence: Complex mathematical calculations per pixel (6-wave water system, procedural grass, multi-octave noise)Personal Questions for V2:
Should V2 target similar visual complexity?
How will V2's 4-layer system affect rendering performance?
Will V2 support material-specific animation systems?
Research Needed: Performance testing of V1-style effects with V2's architecture.V1 Approach: Hardcoded material properties in shader switch statementsV2 Considerations:
Should V2 use similar hardcoded materials or data-driven systems?
How do V2's layers interact visually (transparency, blending)?
Will V2 support runtime material customization?
Personal Assessment: V2 might benefit from more flexible material systems than V1's hardcoded approach.V1 Time Usage: Global time parameter for synchronized animations across all tilesV2 Questions:
How will V2 handle time synchronization across distributed processing?
Should V2 support per-tile animation offsets for variety?
Will V2's physics system affect visual animation timing?
Team Discussion Needed: Integration between V2's physics timing and visual animation.Identified by: Claude Status: Team input neededPersonal Assessment: V1's visual complexity suggests performance considerations for V2.V1 Per-Pixel Calculations (observed):
Water: 6 sine function evaluations + color interpolation
Grass: Blade geometry generation + multiple conditional branches
Noise: 4-octave fractal calculation + hash function evaluations
Personal Calculation: Potentially 10-20 mathematical operations per pixel for complex materialsResearch Questions:
What are V2's target performance characteristics?
Should V2 support multiple detail levels for different devices?
How does V1's performance compare to V2's goals?
Team Discussion Needed: Visual quality vs performance trade-offs for V2.V1 Approach: Procedural generation without texture assets
No texture memory usage for material appearance
All effects generated mathematically in shader
Time and UV coordinates as only inputs
V2 Implications:
Should V2 continue the fully-procedural approach?
How do V2's bit-packed tiles affect rendering pipeline?
Will V2's 4-layer system require additional rendering passes?
Personal Assessment: V1's procedural approach was memory-efficient but computationally intensive.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These visual design recommendations need team review before consideration.
Multi-wave animation systems for natural-looking environmental movement
Procedural material generation for memory efficiency
Perlin noise integration for organic visual variation
Material-specific color palettes for visual distinction Layer-aware rendering for V2's 4-layer tile system
Material property systems for easier customization than V1's hardcoded approach
Performance scaling for different device capabilities
Animation synchronization with V2's physics and reaction systems Visual complexity scaling - V1 effects were computationally expensive
Material variety - V1 had limited material types compared to V2's ambitions
Layer interaction - V1 was single-layer, V2 needs multi-layer visual compositing
Status: All recommendations need team evaluation and visual design discussion.Personal Suggestions (not discussed with team):
Prototype V2 materials using V1 techniques as starting point
Test rendering performance with V2's 4-layer system and V1-style effects
Design material property systems that provide V1's visual quality with more flexibility
Plan animation integration with V2's physics and reaction timing
Status: All suggestions need team review and renderer architecture planning.]]></description><link>legacy/v1-visual-effects.html</link><guid isPermaLink="false">legacy/v1-visual-effects.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[Reaction v2 is a complete reimagining of the original Reaction game, featuring GPU-accelerated physics, deterministic gameplay, and a powerful spell crafting system where players cast spells that place magical runes, transforming terrain through physics-based rule systems.We're currently in the architecture design phase, focusing on creating robust system designs before moving to implementation.
Real-time PvP Combat - Fast-paced multiplayer battles on grid-based terrain
Spell Crafting System - Create custom spell combinations using magical runes
Rule-based Physics - Dynamic terrain transformation through deterministic physics
GPU Acceleration - High-performance rendering and physics calculations
Deterministic Gameplay - Consistent game state across all clients for competitive play cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/architecture.html" data-href="architecture/architecture" aria-label="architecture/architecture" data-tooltip-position="top" target="_self">Architecture</a> - System design and technical approach
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="development/development.html" data-href="development/development" aria-label="development/development" data-tooltip-position="top" target="_self">Development</a> - Setup, workflow, and development processes
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="gameplay/gameplay.html" data-href="gameplay/gameplay" aria-label="gameplay/gameplay" data-tooltip-position="top" target="_self">Gameplay</a> - Core game mechanics and design philosophy <br>cross-reference<a rel="noopener nofollow" class="internal-link" href="legacy/legacy.html" data-href="legacy/legacy" aria-label="legacy/legacy" data-tooltip-position="top" target="_self">Legacy V1 Analysis</a> - V1 system concepts for V2 development reference <br>Development Setup: See cross-reference<a rel="noopener nofollow" class="internal-link" href="development/getting-started.html" data-href="development/getting-started" aria-label="development/getting-started" data-tooltip-position="top" target="_self">Getting Started Guide</a>
<br>Architecture Overview: Read cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/overview.html" data-href="architecture/general/overview" aria-label="architecture/general/overview" data-tooltip-position="top" target="_self">System Overview</a>
<br>Development Principles: Review cross-reference<a rel="noopener nofollow" class="internal-link" href="development/development_principles.html" data-href="development/DEVELOPMENT_PRINCIPLES" aria-label="development/DEVELOPMENT_PRINCIPLES" data-tooltip-position="top" target="_self">Core Principles</a>
npm run dev # Start development server
npm run test # Run test suite
npm run build # Create production build /docs - Documentation source (Markdown)
/src - Source code
/tests - Test suites
/build - Build outputs (gitignored) <br><a data-tooltip-position="top" aria-label="https://github.com/FireToDust/Reaction-Web" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/FireToDust/Reaction-Web" target="_self">GitHub Repository</a>
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="development/building-documentation.html" data-href="development/building-documentation" aria-label="development/building-documentation" data-tooltip-position="top" target="_self">Building Documentation</a>
<br><a data-tooltip-position="top" aria-label="docs" data-href="docs" href="docs.html" class="internal-link" target="_self" rel="noopener nofollow">Full Documentation Index</a>
For detailed documentation, explore the links above or browse the documentation tree.]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[tasklist]]></title><description><![CDATA[Automatically generated task list from all TODO items found in the documentation using Dataview.Status Overview All TODO Items
<a data-tooltip-position="top" aria-label="architecture/systems/config/config.md" data-href="architecture/systems/config/config.md" href="architecture/systems/config/config.html" class="internal-link" target="_self" rel="noopener nofollow">config</a>: Define configuration system architectureDocument configuration file formatsAdd runtime configuration managementDocument environment-specific settings<br><a data-tooltip-position="top" aria-label="docs.md" data-href="docs.md" href="docs.html" class="internal-link" target="_self" rel="noopener nofollow">docs</a>: Complete main documentation indexAdd project overview sectionAdd getting started quick links<br><a data-tooltip-position="top" aria-label="architecture/general/ghost-simulation.md" data-href="architecture/general/ghost-simulation.md" href="architecture/general/ghost-simulation.html" class="internal-link" target="_self" rel="noopener nofollow">ghost-simulation</a>: NEEDS IMPLEMENTATION: Performance benchmarking of different complexity levelsNEEDS IMPLEMENTATION: User experience testing of ghost feedback effectivenessNEEDS IMPLEMENTATION: Integration testing with action queue and timing systems<br><a data-tooltip-position="top" aria-label="architecture/general/state-management.md" data-href="architecture/general/state-management.md" href="architecture/general/state-management.html" class="internal-link" target="_self" rel="noopener nofollow">state-management</a>: NEEDS IMPLEMENTATION: Performance benchmarking of snapshot creation overheadNEEDS IMPLEMENTATION: Network bandwidth testing with delta compressionNEEDS IMPLEMENTATION: Cross-platform determinism validation suite<br><a data-tooltip-position="top" aria-label="architecture/systems/ui/ui.md" data-href="architecture/systems/ui/ui.md" href="architecture/systems/ui/ui.html" class="internal-link" target="_self" rel="noopener nofollow">ui</a>: Define UI system architectureDocument component hierarchyAdd interaction patternsDocument accessibility requirements<br><a data-tooltip-position="top" aria-label="architecture/general/variable-timing.md" data-href="architecture/general/variable-timing.md" href="architecture/general/variable-timing.html" class="internal-link" target="_self" rel="noopener nofollow">variable-timing</a>: NEEDS IMPLEMENTATION: Detailed performance benchmarking of time slice overheadNEEDS IMPLEMENTATION: Integration testing with existing Core Engine texture managementNEEDS IMPLEMENTATION: Multiplayer synchronization validation
All Warnings
<br><a data-tooltip-position="top" aria-label="architecture/general/data-flow.md" data-href="architecture/general/data-flow.md" href="architecture/general/data-flow.html" class="internal-link" target="_self" rel="noopener nofollow">data-flow</a>: OUTDATED DOCUMENT: Physics system has been updated and this document no longer reflects current architectural directionNEEDS TEAM DISCUSSION: Optimal time slice count (8 vs 4 vs 16)NEEDS TEAM DISCUSSION: Performance impact of deterministic GPU orderingNEEDS TEAM DISCUSSION: Ghost simulation complexity vs performance trade-offs<br><a data-tooltip-position="top" aria-label="architecture/general/ghost-simulation.md" data-href="architecture/general/ghost-simulation.md" href="architecture/general/ghost-simulation.html" class="internal-link" target="_self" rel="noopener nofollow">ghost-simulation</a>: PROPOSED SYSTEM: Predictive action visualization system shows players their queued actionsNEEDS TEAM DISCUSSION: Default simulation complexity level (minimal/basic/detailed)NEEDS TEAM DISCUSSION: Ghost prediction accuracy vs performance trade-offsNEEDS TEAM DISCUSSION: Visual design for ghost representation (transparency, colors, indicators)<br><a data-tooltip-position="top" aria-label="architecture/general/state-management.md" data-href="architecture/general/state-management.md" href="architecture/general/state-management.html" class="internal-link" target="_self" rel="noopener nofollow">state-management</a>: PROPOSED SYSTEM: Unified state management approach serves both single-player and multiplayerNEEDS TEAM DISCUSSION: Snapshot retention policy (current proposal: 5 seconds)NEEDS TEAM DISCUSSION: Delta compression vs full snapshot frequency (current proposal: every 60 frames)NEEDS TEAM DISCUSSION: Rollback window limits for client prediction<br><a data-tooltip-position="top" aria-label="architecture/general/variable-timing.md" data-href="architecture/general/variable-timing.md" href="architecture/general/variable-timing.html" class="internal-link" target="_self" rel="noopener nofollow">variable-timing</a>: PROPOSED SYSTEM: Time slice scheduling system enables variable player action timingNEEDS TEAM DISCUSSION: Optimal slice count (current proposal: 8 slices per frame)NEEDS TEAM DISCUSSION: Speed multiplier ranges (current proposal: 0.1x to 10x)NEEDS TEAM DISCUSSION: Ghost prediction complexity vs performance trade-offs
Files by Status Implementation Tasks
Dataview: No results to show for list query.
Testing Tasks
Dataview: No results to show for list query.
Discussion Items
Dataview: No results to show for list query.
Research Items
Dataview: No results to show for list query.
Documentation Tasks
Dataview: No results to show for list query.
Review Tasks
Dataview: No results to show for list query.
Proposed Systems
Dataview: No results to show for list query.
Outdated Documents
Dataview: No results to show for list query.
Breaking Changes
Dataview: No results to show for list query.
Performance Concerns
Dataview: No results to show for list query.
Security Concerns
Dataview: No results to show for list query.
Technical Debt
Dataview: No results to show for list query.
Stub Files Proposed Documents Outdated Documents <br>Note: This page automatically aggregates todos, warnings, and status information from frontmatter metadata across all documentation files. For complete documentation on how to use frontmatter fields (status, tags, todo categories, warning types) and integration with the documentation structure, see cross-reference<a rel="noopener nofollow" class="internal-link" href="development/documentation_structure.html#Frontmatter Metadata" data-href="DOCUMENTATION_STRUCTURE#Frontmatter Metadata" aria-label="DOCUMENTATION_STRUCTURE > Frontmatter Metadata" data-tooltip-position="top" target="_self">Frontmatter Metadata Documentation</a>.]]></description><link>development/tasklist.html</link><guid isPermaLink="false">development/tasklist.md</guid><pubDate>Mon, 13 Oct 2025 20:42:43 GMT</pubDate></item><item><title><![CDATA[DOCUMENTATION_STRUCTURE]]></title><description><![CDATA[Documentation should function as a navigational search tree where each level provides just enough information to guide readers to the right destination.Parent nodes are signposts, not encyclopedias
Overview documents help readers navigate to specifics
Include enough detail to make informed navigation choices
Avoid comprehensive coverage at high levels
No redundant information
Each piece of information has one authoritative location
Link to sources rather than copying content
Update links when information moves
Hierarchical information flow
Overview → Category → Implementation Details
General concepts → Specific examples
Architecture → Component details
Overview Documents
List what's covered and where to find it
Provide context for understanding relationships
Include links to detailed documentation
Don't duplicate content from linked pages
Category Documents
Explain concepts specific to that category
Direct readers to implementation details
Show how pieces relate within the category
Link to related categories when relevant
Detail Documents
Contain complete implementation information
Reference but don't duplicate architectural context
Link back to parent concepts when helpful
Focus on specific, actionable content
Top-Down Discovery
Start with high-level goals or concepts
Follow links to increasingly specific information
Each level adds detail without repeating previous levels
Cross-ReferencingThe documentation uses two types of links to distinguish hierarchical structure from references:Regular Links - Use standard wiki-link syntax for direct parent-child relationships:[[child-document|Display Name]]
Cross-Reference Links - Use cross-reference syntax for non-hierarchical links:[cross-reference:: [[other-document|Display Name]]]
When to use cross-reference syntax:
Linking to files that are NOT direct children of the current document
Referencing related concepts at the same level or in different branches
Linking to authoritative sources for shared information
Any link that represents a reference rather than a structural parent-child relationship
Purpose: The cross-reference syntax allows Obsidian's graph view to filter out reference links, displaying only the hierarchical documentation tree structure. This makes it easier to visualize and maintain the documentation organization.Guidelines:
Use regular links to show "this document contains these sub-topics"
Use cross-reference links to show "see this other document for more information"
Avoid circular documentation dependencies regardless of link type
Maintenance
When information changes, update it in one place
Check that navigation paths remain clear
Remove or redirect broken internal links
Ensure new content fits the existing hierarchy
Documentation files use YAML frontmatter to track document status, categorization, and task management. This metadata integrates with Dataview for automated task tracking and status monitoring.Tracks document lifecycle and implementation state:
stub - Placeholder document that needs content
draft - Being actively written, incomplete
proposed - Complete proposal awaiting team approval
approved - Approved design ready for implementation
implemented - Code exists matching this documentation
outdated - Document needs updating to match current state
deprecated - Obsolete but kept for historical reference
Example:---
status: proposed
---
Categorizes document type for filtering and organization:
Navigation - Index, overview, or parent pages
Architecture - System architecture and design
Implementation - Detailed implementation specifications
Reference - API references, data formats, constants
Development - Development process and workflow
Testing - Testing strategies and requirements
Performance - Performance analysis and optimization
Security - Security considerations and requirements
Multiplayer - Multiplayer-specific systems
Legacy - Version 1 reference material
TaskList - Special: automated task aggregator pages
Example:---
tags: - Architecture - Performance
---
Task tracking with subcategories using tagged items. Each todo item can have an optional [category] tag at the start:Categories:
[implementation] - Code needs to be written
[testing] - Tests need to be written
[discussion] - Requires team discussion/decision
[research] - Requires investigation or research
[documentation] - Documentation needs to be written
[review] - Needs code or design review
(no tag) - General uncategorized task
Example:---
todo: - "[implementation] Detailed performance benchmarking of time slice overhead" - "[testing] Cross-platform determinism validation suite" - "[discussion] Optimal slice count (current proposal: 8 slices)" - "[research] Alternative scheduling algorithms" - "[documentation] Complete API reference section" - "General task without category"
---
Tracks concerns, proposals, and issues requiring attention. Each warning can have an optional [type] tag:Types:
[proposed] - Proposed system or architectural decision
[outdated] - Content is outdated and needs updating
[breaking] - Breaking change to existing implementations
[performance] - Performance concern or bottleneck
[security] - Security concern or vulnerability
[debt] - Technical debt that should be addressed
(no tag) - General warning
Example:---
warnings: - "[proposed] Time slice scheduling system enables variable timing" - "[performance] High memory usage with 300 snapshot buffer" - "[breaking] API changes required for state management" - "[debt] Inefficient memory allocation in snapshot system"
---
---
status: proposed
tags: - Architecture - Multiplayer
todo: - "[implementation] Performance benchmarking of snapshot creation" - "[testing] Network bandwidth testing with delta compression" - "[discussion] Snapshot retention policy (current: 5 seconds)"
warnings: - "[proposed] Unified state management serves single and multiplayer" - "[performance] Snapshot creation overhead needs measurement"
---
The subcategorized todo and warning items allow Dataview queries to filter by specific types. See cross-reference<a rel="noopener nofollow" class="internal-link" href="development/tasklist.html" data-href="tasklist" aria-label="tasklist" data-tooltip-position="top" target="_self">Task List</a> for automated queries that collect and organize these items across all documentation.
Use status to track document maturity through its lifecycle
Apply tags for broad categorization (multiple tags allowed)
Subcategorize todo items to help with task filtering and prioritization
Subcategorize warnings to identify types of concerns at a glance
Update status as documents progress from draft → proposed → approved → implemented
Mark documents as outdated when code diverges from documentation
The goal is that readers can efficiently find exactly what they need without encountering duplicate or outdated information.]]></description><link>development/documentation_structure.html</link><guid isPermaLink="false">development/DOCUMENTATION_STRUCTURE.md</guid><pubDate>Mon, 13 Oct 2025 19:47:30 GMT</pubDate></item><item><title><![CDATA[development]]></title><description><![CDATA[Setup, workflow, and development processes for Reaction v2.
<a class="internal-link" data-href="getting-started.md" href="development/getting-started.html" target="_self" rel="noopener nofollow"><strong></strong></a>Getting Started - Project setup and first build
<br><a class="internal-link" data-href="DEVELOPMENT_PRINCIPLES.md" href="development/development_principles.html" target="_self" rel="noopener nofollow"><strong></strong></a>Development Principles - Core values and guidelines for contributors
<br><a class="internal-link" data-href="DOCUMENTATION_STRUCTURE.md" href="development/documentation_structure.html" target="_self" rel="noopener nofollow"><strong></strong></a>Documentation Structure - How to organize and navigate documentation
<br><a class="internal-link" data-href="building-documentation.md" href="development/building-documentation.html" target="_self" rel="noopener nofollow"><strong></strong></a>Building Documentation - Export and deploy documentation to GitHub Pages <br><a class="internal-link" data-href="tasklist.md" href="development/tasklist.html" target="_self" rel="noopener nofollow"><strong></strong></a>Task List - Auto-generated TODO items, warnings, and documentation status
npm install
npm run dev # Development server
npm run test # Test suite npm run build # Production build
npm run lint # ESLint
npm run format # Prettier Core types: src/core/types.ts
Spell types: src/spell-system/types.ts
Documentation: docs/
Architecture: docs/architecture/
<br>See <a class="internal-link" data-href="DEVELOPMENT_PRINCIPLES.md" href="development/development_principles.html" target="_self" rel="noopener nofollow">Development Principles</a> for core values and <a class="internal-link" data-href="DOCUMENTATION_STRUCTURE.md" href="development/documentation_structure.html" target="_self" rel="noopener nofollow">Documentation Structure</a> for information organization guidelines.]]></description><link>development/development.html</link><guid isPermaLink="false">development/development.md</guid><pubDate>Mon, 13 Oct 2025 19:22:09 GMT</pubDate></item><item><title><![CDATA[legacy]]></title><description><![CDATA[Analysis of V1 system concepts and algorithms to inform V2 development decisions.
<a class="internal-link" data-href="v1-reference.md" href="legacy/v1-reference.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Rules Engine Reference - Mathematical algorithms and GPU optimization from rules system
<br><a class="internal-link" data-href="v1-environmental-examples.md" href="legacy/v1-environmental-examples.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Environmental Examples - Terrain interaction patterns and emergent behaviors
<br><a class="internal-link" data-href="v1-gpu-patterns.md" href="legacy/v1-gpu-patterns.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 GPU Optimization Patterns - Compute shader strategies and memory management
<br><a class="internal-link" data-href="v1-visual-effects.md" href="legacy/v1-visual-effects.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Visual Effects - Rendering techniques and material systems
<br><a class="internal-link" data-href="v1-data-strategies.md" href="legacy/v1-data-strategies.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Data Packing Strategies - Data organization and bit-packing techniques
Reference material extracted from V1 codebase to ensure V2 developers understand the complexity and sophistication of systems being replaced. ]]></description><link>legacy/legacy.html</link><guid isPermaLink="false">legacy/legacy.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[v1-environmental-examples]]></title><description><![CDATA[This document captures environmental interaction patterns from V1 to inform V2 rule design. These examples demonstrate the complexity and emergent behaviors that V2's JSON compilation system should be capable of expressing.Source: Analysis of V1 game logic examples (src/game.ts lines 48-158)
Status: Reference patterns for V2 rule creationContributor: Claude Status: Individual analysis of V1 examplesPersonal Addition: This analysis of V1's environmental behaviors hasn't been discussed with the team.V1 Pattern Observed: Complex water behavior through multiple condition typesWater Flow Detection:Condition: Water north (distance 1) AND Water north (distance 2) AND NOT (Water northwest OR Water northeast)
Personal Interpretation: This created directional water flow by detecting "channels" without side branching.Water Pooling Detection:Condition: (Water north distance 1 OR 2) AND (Water east distance 1 OR 2) AND (Water south distance 1 OR 2)
My Assessment: This detected water collecting in corners or depressions.Water Pressure/Volume Detection:Condition: Water north AND Water east AND Water northeast AND (Water northwest OR Water southeast)
Personal Note: This seemed to detect "enough water pressure" for certain transformations.V1 Grass-to-Mud Pattern:
Trigger: Close to water (bias: +4, total reaction bias: -3)
Result: Net positive when water adjacent
Behavior: Grass becomes mud near water sources
V1 Mud-to-Water Pattern:
Multiple conditions: Water flow (+2), surrounded by water (+2), close to water (+5), close to sand (+2)
Base bias: -6 (requires multiple conditions to trigger)
Behavior: Mud liquefies under water pressure
V1 Mud-to-Grass Recovery:
Negative conditions: Close to water (-2), kind of close to water (-1), close to mud (-1)
Base bias: +2
Behavior: Mud dries to grass when water recedes
Personal Observation: This created realistic seasonal or drought cycles in terrain.V1 Water-to-Sand Pattern:
Negative scoring: All water-related conditions had negative values
Base bias: -1
Interpretation: Water became sand only when "water pressure" was low
V1 Sand-to-Water Pattern:
Condition: Surrounded by water (+2)
Base bias: -1
Behavior: Sand eroded when completely surrounded
V1 Sand-to-Grass Colonization:
Condition: Lots of grass nearby (+3)
Base bias: -2
Behavior: Vegetation gradually reclaimed sandy areas
Personal Assessment: This created believable geological processes.V1 Lava Spread Pattern:Condition: Lava northwest AND Lava northeast AND Lava north Pattern: Required 3 adjacent lava tiles in a row formation
Target: Grass tiles (turning them to lava)
Base bias: -1 (requiring the specific pattern to overcome)
Personal Interpretation: This created lava "fronts" that advanced in lines rather than randomly.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These behavioral observations need team discussion for V2 design.Multiple Transformations per Tile Type: V1 allowed each tile type to have multiple possible reactions with different conditions.Example - Grass Tile Transformations:
Grass → Mud (when near water)
Grass → Lava (when in lava line formation) Grass → Sand (when conditions met - though this was commented out)
Personal Observation: This created realistic environmental competition where multiple forces could affect the same terrain.Observed Pattern: Mud ↔ Grass ↔ Sand cycles
Wet seasons: Grass → Mud → Water
Dry seasons: Water → Sand, Mud → Grass
Vegetation recovery: Sand → Grass (slow colonization)
Personal Assessment: V1's bias system created natural environmental cycles without explicit seasonal programming.Pattern: Many transformations required specific neighbor counts or arrangements
Water flow: Exactly the right configuration
Lava spread: 3-tile line formation required
Vegetation growth: Multiple grass neighbors needed
My Interpretation: This prevented chaotic transformations and created stable intermediate states.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.Observed V1 Complexity:
Conditions checking multiple directions and distances
Logical combinations with AND, OR, NOT operators
Negative scoring for inhibitory effects
Distance-based neighbor detection (1 and 2 tiles away)
Personal Question: Can V2's JSON format express this level of spatial complexity?Example V1 Rule Expressed in Potential V2 JSON:{ "grass": [ { "id": "WaterFlow_Erosion", "action": {"type": "SetType", "new_type": "mud"}, "score_calculation": { "type": "Add", "children": [ {"type": "Constant", "value": -3}, { "type": "BooleanToValue", "condition": { "type": "AND", "children": [ {"type": "TileAt", "tile": "water", "direction": "N", "distance": 1}, {"type": "TileAt", "tile": "water", "direction": "N", "distance": 2}, { "type": "NOT", "child": { "type": "OR", "children": [ {"type": "TileAt", "tile": "water", "direction": "NW", "distance": 1}, {"type": "TileAt", "tile": "water", "direction": "NE", "distance": 1} ] } } ] }, "value_if_true": 4, "value_if_false": 0 } ] } } ]
}
Personal Concern: This JSON is already complex for a single V1 condition. V1 reactions had up to 16 conditions.V1 Optimization Evidence: Rules were pre-compiled into GPU textures
Complex conditions evaluated in parallel across all tiles
Shared memory caching for neighbor access
Personal Assessment: V2 needs comparable optimization strategies for similar environmental complexity.Research Needed: Performance testing of JSON compilation vs V1's direct GPU implementation.Identified by: Claude Status: Team input neededPersonal Assessment: V1 examples suggest specific environmental behavior goals that V2 should validate.
Geological cycles: Water erosion, sediment deposition, vegetation recovery
Competitive dynamics: Multiple environmental forces affecting same areas
Threshold stability: Avoiding chaotic oscillations between states
Directional flow: Water and lava following realistic propagation patterns
Team Discussion Needed: Should V2 target similar environmental realism?
How important are complex multi-condition interactions?
What level of rule complexity should V2 support?
V1 Evidence: Creating realistic environmental behaviors required intricate condition combinations and careful bias tuning.Personal Question: Will V2's visual editor be capable of creating rules of similar sophistication?Research Needed: UI/UX design for complex rule creation without overwhelming users.Personal Recommendations (not discussed with team):
Use V1 patterns as test cases for V2 JSON compilation system
Create V2 equivalents of key V1 environmental behaviors
Validate rule complexity limits early in V2 development
Design rule editor to handle spatial complexity observed in V1
Status: All recommendations need team review and design discussion.]]></description><link>legacy/v1-environmental-examples.html</link><guid isPermaLink="false">legacy/v1-environmental-examples.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[gameplay]]></title><description><![CDATA[Core game mechanics, rules, and design philosophy for Reaction v2.
<a class="internal-link" data-href="core-mechanics.md" href="gameplay/core-mechanics.html" target="_self" rel="noopener nofollow"><strong></strong></a>Core Mechanics - Victory conditions, timing, and elimination rules
Genre: Real-time PvP grid-based spellcasting game
Victory: Last player standing (avatar tile elimination)
Core Loop: Cast spells → Place runes → Transform environment → Tactical positioningNon-Turn-Based: Continuous simulation without traditional turns
Pre-Planning: Players can queue actions in advance
Dynamic Speed: Movement controlled by time delays between position updatesReactive World: Spells transform terrain according to rule-based systems
Terrain Types: Different tile types provide tactical advantages
Evolving World: Continuous world changes create evolving opportunitiesNo Scarcity: Unlimited mana regeneration - focus on timing over conservation
Recharge Timing: 3-turn recharge cycle provides natural rhythm
Allocation Choice: Specialization vs. flexibility in mana allocation]]></description><link>gameplay/gameplay.html</link><guid isPermaLink="false">gameplay/gameplay.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[docs]]></title><description><![CDATA[Status: 🚧 Stub - This index file needs completionComplete documentation for the Reaction v2 real-time PvP grid-based spellcasting game engine.
<a class="internal-link" data-href="architecture/architecture.md" href="architecture/architecture.html" target="_self" rel="noopener nofollow"><strong></strong></a>Architecture - System design and technical approach
<br><a class="internal-link" data-href="development/development.md" href="development/development.html" target="_self" rel="noopener nofollow"><strong></strong></a>Development - Setup, workflow, and development processes <br><a class="internal-link" data-href="gameplay/gameplay.md" href="gameplay/gameplay.html" target="_self" rel="noopener nofollow"><strong></strong></a>Gameplay - Core game mechanics and design philosophy <br><a class="internal-link" data-href="legacy/legacy.md" href="legacy/legacy.html" target="_self" rel="noopener nofollow"><strong></strong></a>Legacy V1 Analysis - V1 system concepts for V2 development reference
TODO: Add quick start section with:
Project setup instructions
First build steps
Development environment configuration
TODO: Add project overview with:
Game concept summary
Technical architecture highlights
Development status and roadmap
🚧 This file is a stub and needs completion]]></description><link>docs.html</link><guid isPermaLink="false">docs.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[getting-started]]></title><description><![CDATA[Project setup and development environment configuration for Reaction v2.
Node.js: Latest LTS version recommended
npm: Comes with Node.js installation
WebGPU-compatible browser: Chrome 113+, Firefox 113+, or Safari Technology Preview GPU: WebGPU-compatible graphics card
Memory: 8GB+ RAM recommended for development
Storage: 2GB+ free space for dependencies and build artifacts
npm install
npm run dev
This starts the development server with hot reload and debugging enabled.
Open browser to development server URL (usually http://localhost:5173)
Check browser console for WebGPU support
Verify no initial compilation errors
npm run dev # Development server with hot reload
npm run test # Run test suite
npm run build # Production build
npm run lint # ESLint code checking npm run format # Prettier code formatting
.
├── src/ # Source code
│ ├── core/ # Core Engine module
│ ├── spell-system/ # Spell System module │ ├── physics-engine/ # Physics Engine module
│ ├── reaction-engine/ # Reaction Engine module
│ ├── renderer/ # Renderer module
│ └── tools/ # Development tools
├── docs/ # Documentation
├── tests/ # Test files
└── package.json # Project configuration
Problem: Browser doesn't support WebGPU
Solution: Use Chrome 113+, Firefox 113+, or enable experimental featuresProblem: TypeScript compilation errors
Solution: Run npm run lint and fix reported issuesProblem: Development server running slowly
Solution: Close other applications, check GPU drivers are updated
Read Architecture: Start with cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/overview.html" data-href="overview" aria-label="overview" data-tooltip-position="top" target="_self">Architecture Overview</a>
Explore Systems: Browse individual system documentation
Run Tests: Verify everything works with npm run test
Make Changes: Try modifying code and see hot reload in action
⚠️ SUGGESTION: Consider establishing:
IDE configuration and recommended extensions
WebGPU debugging extensions
Performance profiling tools
GPU shader debugging setup
]]></description><link>development/getting-started.html</link><guid isPermaLink="false">development/getting-started.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[building-documentation]]></title><description><![CDATA[The documentation system uses Obsidian for authoring (in docs/) and exports to HTML for GitHub Pages deployment via git subtree.
Obsidian with "Webpage HTML Export" plugin installed
Git command line tools Open the docs/ folder as a vault in Obsidian
Either: Click the "Export as HTML" button (added by Webpage HTML Export plugin)
Or run command "Webpage HTML Export: Export using previous settings" Ensure export target is set to build/docs
After exporting, commit and push the changes in the worktree:cd build/docs
git add .
git commit -m "Update documentation"
git push
cd ../.. Documentation source files (Markdown) live in docs/ on the main branch
Built HTML files are in build/docs/ which is a git worktree of the gh-pages branch
The worktree allows direct commits to gh-pages without switching branches
Changes to documentation require rebuilding and redeploying
]]></description><link>development/building-documentation.html</link><guid isPermaLink="false">development/building-documentation.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[ui]]></title><description><![CDATA[Status: 🚧 Stub - This system documentation needs completionUser interface system for game controls, HUD elements, and player interaction.TODO: Add links to UI components when implemented:
Interface layout and component hierarchy
Input handling and interaction patterns
HUD elements and game overlays
Menu systems and navigation
TODO: Document UI system responsibilities:
Game HUD: Mana flowers, spell hand, player status indicators
Game Controls: Spell casting interface, movement controls, action queuing
Menu Systems: Main menu, settings, deck building, game lobby
Visual Feedback: Action confirmations, error states, loading indicators
TODO: Define major UI components:
Mana Flower Display: Visual representation of mana types and recharge status
Spell Hand Interface: Spell selection and casting controls
Grid Overlay: Tile highlighting, targeting cursors, range indicators
Action Queue Visualization: Preview of queued player actions
Game Status: Timer, player health, elimination status
TODO: Add design guidelines:
Clarity: Clear visual hierarchy and information priority
Responsiveness: Immediate feedback for all player actions
Accessibility: Keyboard navigation, screen reader support, color accessibility
Scalability: Support for different screen sizes and resolutions
TODO: Document system integrations:
Input System: Mouse, keyboard, and touch input handling
Renderer: UI rendering pipeline and performance considerations
Game State: Real-time updates from game simulation
Spell System: Integration with spell casting and mana management
🚧 This file is a stub and needs completion]]></description><link>architecture/systems/ui/ui.html</link><guid isPermaLink="false">architecture/systems/ui/ui.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[DEVELOPMENT_PRINCIPLES]]></title><description><![CDATA[
Never fabricate performance numbers, statistics, or benchmarks
Mark personal ideas as such - don't present speculation as team decisions
Say "I don't know" when you don't know
Uncertainty is better than false confidence Code should explain itself through naming and structure
If you need extensive comments to explain what code does, rewrite it
Magic numbers and unclear constants are tech debt
Optimize for the next person who reads your code Distinguish between your ideas and team decisions
Make it easy for others to understand and build on your work
Ask questions when design decisions aren't clear
Share context behind your choices Use descriptive names for functions, variables, and files
Handle error cases explicitly - don't ignore or hide failures
Prefer simple, obvious solutions over clever optimizations
Document the "why" behind non-obvious business logic Be honest about what's decided vs. what you're proposing
Include enough context for someone to understand and challenge your reasoning
Avoid inventing performance claims or user behavior assumptions
Note when something needs team input or further research Understand the problem before jumping to solutions
Consider the person who will maintain this code in 6 months
Choose consistency with existing patterns over personal preference
Measure performance claims rather than guessing Write clear, descriptive commit messages that explain the "why" not just the "what"
Make atomic commits - each commit should represent one logical change
Never commit broken code or failing tests to main branch
Use branches for feature development and merge via pull requests
Review your own changes before committing - check diffs carefully
Keep commits focused - avoid mixing unrelated changes
Test your changes locally before pushing
Before committing work, ask:
Can someone else understand this without asking me questions?
Am I making any claims I can't back up?
Is this the simplest solution that solves the actual problem?
Have I clearly indicated what needs team discussion?
Are my commit messages clear and descriptive?
Have I tested my changes locally?
The goal is sustainable development where team members can confidently build on each other's work.]]></description><link>development/development_principles.html</link><guid isPermaLink="false">development/DEVELOPMENT_PRINCIPLES.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[tools]]></title><description><![CDATA[Status: Incomplete documentation The Tools system provides development utilities and visual editing capabilities for Reaction v2.The tools system includes:
Visual rule editor for creating and testing transformation rules
Development debugging utilities
Performance profiling tools
Asset management utilities
Documentation incomplete - editor interface and functionality to be detailedDocumentation incomplete - debugging and profiling tools to be documentedDocumentation incomplete - asset processing and management tools to be added]]></description><link>architecture/systems/tools/tools.html</link><guid isPermaLink="false">architecture/systems/tools/tools.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[rendering]]></title><description><![CDATA[Status: Incomplete documentationThe Renderer system handles visual display and UI rendering for Reaction v2.The renderer is responsible for:
GPU-based visual display of the game grid
UI rendering and interface elements
Frame coordination with other systems
Visual effects and animations
Documentation incomplete - details to be added during implementationDocumentation incomplete - optimization details to be addedDocumentation incomplete - WebGPU implementation details to be added]]></description><link>architecture/systems/rendering/rendering.html</link><guid isPermaLink="false">architecture/systems/rendering/rendering.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[reactions]]></title><description><![CDATA[Rule-based environmental transformations through GPU shader compilation for complex tile interactions.Transform human-readable tile interaction rules into highly optimized GPU shaders for environmental transformations like fire spreading, water extinguishing flames, and magical interactions.Design Approach: Designed for ease of rule creation and modification during development, allowing rules to be defined in JSON and automatically converted to efficient GPU code. Alternative approaches may be considered during implementation.
JSON rule compilation to optimized GPU shaders
Competitive rule scoring and execution for deterministic behavior
Environmental pattern matching (fire spreading, water interactions, etc.)
Rule optimization pipeline (specific implementation TBD) <a class="internal-link" data-href="rule-compilation.md" href="architecture/systems/reactions/rule-compilation.html" target="_self" rel="noopener nofollow"><strong></strong></a>Rule Compilation - JSON to GPU shader pipeline
<br><a class="internal-link" data-href="rule-system.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Rule System - Competitive scoring model and execution
<br><a class="internal-link" data-href="visual-editor.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Visual Editor - Development tools and rule creation interface
<br><a class="internal-link" data-href="examples.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Examples - Sample rules and common patterns
Problem: Multiple rules may apply to the same tile simultaneously.
Solution: Competitive evaluation where highest-scoring rule wins.Design Philosophy: Move all possible computational work to build time for minimal runtime overhead.Lower frequency than physics: Reactions may run less frequently for performance.
⚠️ Challenge: Coordination with physics timing is a major technical issue to solve.
Core Engine: Required for texture access and coordination
Build Toolchain: Rule compilation requires build-time processing
]]></description><link>architecture/systems/reactions/reactions.html</link><guid isPermaLink="false">architecture/systems/reactions/reactions.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[rule-compilation]]></title><description><![CDATA[Transform human-readable tile interaction rules into GPU shaders for environmental transformations like fire spreading, water extinguishing flames, and magical interactions.Design Approach: Designed for ease of rule creation and modification during development, allowing rules to be defined in JSON and automatically converted to GPU code. Alternative approaches may be considered during implementation.Offline Processing: Move computational work to build time for reduced runtime overhead. JSON Rule Definition Human-readable transformation rules
Visual editor exports structured rule data
Declarative condition and action specifications GLSL Code Generation Rust-based rule-to-shader compiler
Converts declarative rules to imperative GPU code
Generates helper functions for tile data access SPIR-V Compilation Standard glslangValidator compilation
Produces unoptimized intermediate representation
Platform-independent shader bytecode Optimization (⚠️ NEEDS DESIGN - specific tools TBD) Dead code elimination, function inlining
Constant folding, loop unrolling
Register allocation optimization WebGPU Conversion Convert to WebGPU-compatible shader format
Runtime loading and execution Problem: Multiple rules may apply to the same tile simultaneously.Solution: Competitive evaluation where highest-scoring rule wins.Characteristics:
Deterministic rule resolution
Priority-based rule ordering
Complex conditional logic support
Complex interaction behaviors
Logical Operators: AND, OR, NOT for complex conditions
Spatial Queries: Check neighboring tiles and patterns
Aggregate Functions: Count tiles in regions, calculate thresholds
Boolean Conversion: Transform true/false to numeric scoresBase Priority: Fixed score for rule importance
Environmental Bonuses: Dynamic scoring based on surroundings
Mandatory Conditions: Huge negative scores for rule violations
Threshold Logic: Activation based on neighbor countsTile Transformation: Change tile type and properties
Property Modification: Update velocity, health, timers
Force Application: Apply velocity changes
State Changes: Modify custom data fields{ "grass": [ { "id": "GrassIgnition", "action": { "type": "SetType", "new_type": "fire" }, "score_calculation": { "type": "Add", "children": [ { "type": "Constant", "value": 30 }, { "type": "BooleanToValue", "condition": { "type": "Aggregate", "region": "3x3", "tile_type": "fire", "comparison": "GreaterThan", "count": 0 }, "value_if_true": 0, "value_if_false": -10000 }, { "type": "Aggregate", "region": "3x3", "tile_type": "water", "expression": "count * -50" } ] } } ]
}
Lower frequency than physics: Reactions may run less frequently for performance.Challenge: Coordination with physics timing is a major technical issue to solve.
Rule Evaluation: Each tile evaluates all applicable rules
Score Calculation: Parallel computation of rule priorities Winner Selection: Deterministic highest-score selection
Action Application: Transform winning tiles Input: Read post-physics tile states
Processing: Local neighborhood sampling for conditions
Output: Write transformed tiles for next physics cycle
Integration: Seamless data flow with physics engine
⚠️ SUGGESTION: Potential editor features for future development:
Grid-based visual neighborhood editor
Point-and-click rule creation interface
Real-time rule testing and preview
Direct JSON generation for compilation
⚠️ SUGGESTION: Potential debugging capabilities:
Rule tracing: Debug which rules activated and why
Score visualization: See rule competition in real-time
Validation tools: Detect impossible or conflicting rules
Performance profiling: Shader execution timing
⚠️ SUGGESTION: Potential compilation optimizations:
Compile-time specialization for specific use cases
Dead code elimination for unused rule paths
Constant folding for pre-computed values
Loop unrolling for neighbor checks Rule Complexity: Handles arbitrary rule complexity through compilation
Rule Count: Compilation-time scaling, not runtime cost
Memory Efficiency: Optimized data access patterns
]]></description><link>architecture/systems/reactions/rule-compilation.html</link><guid isPermaLink="false">architecture/systems/reactions/rule-compilation.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[server-architecture]]></title><description><![CDATA[Authoritative game server design with GPU-accelerated simulation identical to client engine.Purpose: Central coordinator for multiplayer matches.Responsibilities:
WebSocket connection management per match
Player authentication and session management
Frame timing coordination at 60 FPS
Match lifecycle (creation, joining, termination)
Dependencies: NetworkManager, ServerGameEnginePurpose: Authoritative game simulation without rendering.Responsibilities:
Identical deterministic simulation to client engine
GPU compute shader execution for physics and reactions
Tile storage and active region management
State validation and integrity checking
Key Differences from Client:
No rendering pipeline (headless)
Additional input validation layers
State snapshot creation for rollback
Network delta generation
Purpose: Real-time communication with game clients.Responsibilities:
WebSocket server lifecycle management
Input message validation and deserialization
State update broadcasting with compression
Connection quality monitoring and adaptation Client Input Reception: WebSocket message containing player actions
Input Validation: Verify action legality (mana costs, targeting, timing)
State Application: Apply validated inputs to authoritative game state
Simulation Step: Execute physics, reactions, and rule processing
Delta Generation: Create compressed state updates for clients
60 FPS Target: 16.67ms frame budget
Input processing: 2ms
Simulation execution: 12ms
Network transmission: 2ms
Buffer time: 0.67ms
Full State Snapshots: Every 60 frames (1 second) as fallback recovery
Delta Updates: Every frame with active region optimization
Priority System: Critical updates (player health) sent immediately
Acknowledgment Tracking: Ensure reliable delivery with retransmissionServer Environment: Node.js with WebGPU adapter
GPU Requirements: NVIDIA T4 or equivalent with compute capability
Memory Management: Shared texture pools across game instancesIdentical Logic: Same shaders as client for deterministic results
Texture Management: Ping-pong system adapted for server environment
Active Region Processing: Leverage existing chunk optimizationInstance Batching: Multiple games on single GPU context
Memory Pooling: Reuse GPU resources between matches
Adaptive Quality: Reduce simulation fidelity under high loadRoom Creation: Dynamic game instance spawning
Player Assignment: Region-based server selection
Capacity Management: Load balancing across server instances
Initialization: GPU resource allocation and world setup
Player Joining: Connection establishment and state synchronization
Active Gameplay: 60 FPS simulation with network updates
Match Conclusion: Resource cleanup and statistics recording
GPU Failures: Automatic instance migration to backup servers
Network Issues: Client reconnection with state recovery
Crash Recovery: Persistent state snapshots for match restoration
Frame timing consistency (target: &lt;16.67ms)
GPU utilization per instance
Memory bandwidth consumption
Network throughput per match
CPU Bound: Input processing and network I/O optimization
GPU Bound: Shader optimization and batch processing
Memory Bound: Texture management and garbage collection
Network Bound: Compression and prioritization improvements
Player queue length
Average frame processing time
GPU memory utilization
Network bandwidth per server
This architecture provides the authoritative foundation for competitive multiplayer while leveraging Reaction's existing deterministic engine design.]]></description><link>architecture/systems/multiplayer/server-architecture.html</link><guid isPermaLink="false">architecture/systems/multiplayer/server-architecture.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[security]]></title><description><![CDATA[Input validation, state integrity, and cheat detection systems for competitive multiplayer security.Authoritative Validation: All game-affecting decisions made on server
Input Processing: Client inputs validated against current game state
State Enforcement: Server never trusts client-reported game state
Damage Calculation: All combat calculations performed server-sideAuthority Boundaries:
Server: Health, mana, spell effects, tile transformations
Client: UI interactions, prediction, visual effects
Validated: Movement inputs, spell targeting, timing
Zero-Trust Client Model: Assume all client data is potentially malicious
Validation Layers: Multiple verification stages for critical operations
State Reconciliation: Continuous comparison of client predictions with server realityinterface InputValidation { syntaxCheck: boolean; // Message format validity rangeCheck: boolean; // Coordinate and value bounds gameRuleCheck: boolean; // Legal according to current state timingCheck: boolean; // Within expected timing windows rateCheck: boolean; // Not exceeding rate limits
}
Mana Verification: Server tracks actual mana levels independently
Targeting Validation: Ensure spell targets are within range and line-of-sight
Cooldown Enforcement: Server-side spell cooldown tracking
Rule Compliance: Validate spell effects against current game rulesExample Validation:function validateSpellCast(input: SpellCastInput, gameState: GameState): ValidationResult { // Check mana availability if (gameState.playerMana[input.playerId] &lt; spell.manaCost) { return { valid: false, reason: "Insufficient mana" }; } // Validate targeting if (!isValidTarget(input.target, gameState.playerPosition[input.playerId])) { return { valid: false, reason: "Invalid target" }; } // Check cooldowns if (gameState.spellCooldowns[input.playerId][input.spellId] &gt; 0) { return { valid: false, reason: "Spell on cooldown" }; } return { valid: true };
}
Position Bounds: Ensure movement stays within world boundaries
Physics Constraints: Validate movement against physics simulation
Speed Limits: Enforce maximum movement speeds
Collision Detection: Prevent movement through solid tilesInput Frequency: Maximum inputs per second per player
Spell Casting Rate: Prevent rapid-fire spell casting
Connection Limits: Maximum connections per IP address
Bandwidth Throttling: Prevent network floodingChecksum Verification: Regular state checksums between server instances
Replay Validation: Ability to replay matches for verification
Cross-Instance Checking: Multiple servers validate critical calculations
Integer-Only Mathematics: Prevent floating-point determinism issuesinterface StateIntegrityCheck { playerHealthSum: number; totalManaInWorld: number; tileTypeDistribution: Map&lt;TileType, number&gt;; activeRuneCount: number; frameChecksum: number;
}
Impossible State Detection: Identify states that violate game physics
Statistical Analysis: Detect patterns that suggest cheating
Performance Anomalies: Identify suspiciously perfect play patterns
Network Timing Analysis: Detect inhuman reaction timesInput Analysis:
Timing analysis for inhuman precision
Pattern recognition for bot behavior
Statistical analysis of success rates
Consistency checking across sessions
State Validation:
Impossible game state detection
Resource tracking (mana, health)
Position validation and teleport detection
Damage calculation verification
Performance Fingerprinting:
Hardware capability profiling
Render timing analysis
Input device characteristics
System performance patterns
Behavior Analysis:
Mouse movement patterns
Reaction time distributions
Decision-making patterns
Play style consistency
Speed Hacking: Movement faster than physics allows
Teleportation: Position changes without valid movement
Resource Manipulation: Invalid mana or health values
Information Cheating: Actions suggesting knowledge of hidden information
Automation: Bot-like behavior patterns
Network Manipulation: Lag switching or packet manipulationTLS Encryption: All WebSocket connections use WSS protocol
Certificate Validation: Proper SSL certificate verification
Session Management: Secure token-based authentication
IP Reputation: Block known malicious IP addressesRate Limiting: Connection and message rate limits
Geographic Filtering: Restrict connections by region if needed
Traffic Analysis: Detect and mitigate attack patterns
Load Balancing: Distribute traffic across multiple serversMessage Authentication: Cryptographic signatures for critical messages
Replay Attack Prevention: Timestamp and sequence number validation
Man-in-the-Middle Protection: Certificate pinning where appropriate
Session Hijacking Prevention: Secure session token managementImmediate Actions:
Flag suspicious activity for review
Increase monitoring for flagged players
Collect evidence for manual review
Apply temporary restrictions if necessary
Investigation Process:
Automated evidence collection
Manual review by security team
Player interview if needed
Final determination and action
Enforcement Actions:
Warning for minor violations
Temporary suspension for moderate violations
Permanent ban for severe violations
Hardware ID banning for repeat offenders
Breach Detection: Automated monitoring for security compromises
Response Team: Dedicated security incident response team
Communication Plan: Player notification for security issues
Recovery Procedures: Service restoration after security incidentsReplay System: Complete match recordings for investigation
Log Aggregation: Centralized logging for security analysis
Player Behavior History: Long-term behavioral pattern tracking
System State Snapshots: Capture game state during suspicious eventsMinimal Data Collection: Only collect data necessary for security
Data Retention: Automatic deletion of old security logs
Player Privacy: Protect personal information during investigations
Consent Management: Clear privacy policy for security monitoringAppeals Process: Fair system for contested security actions
Evidence Disclosure: Provide evidence for security decisions where appropriate
Policy Communication: Clear communication of security policies
Regular Auditing: Third-party security audits of anti-cheat systemsThis comprehensive security framework ensures competitive integrity while maintaining player privacy and providing fair enforcement mechanisms.]]></description><link>architecture/systems/multiplayer/security.html</link><guid isPermaLink="false">architecture/systems/multiplayer/security.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[performance]]></title><description><![CDATA[Bandwidth optimization, server scaling, and latency management strategies for multiplayer infrastructure.Simulation Requirements:
60 FPS authoritative simulation per game instance
Real-time response to player input
Support multiple players per game instance
Maintain responsive gameplay experience
Scaling Goals:
Support multiple concurrent matches per server
Efficient bandwidth utilization
Minimize network latency
High availability for players
Prediction Requirements:
Maintain smooth 60 FPS gameplay
Minimize rollback disruptions
Low prediction processing overhead
Seamless visual experience during corrections
Headless Rendering Optimization:
Skip visual pipeline entirely
Retain compute shaders for physics and reactions
Optimize GPU memory allocation for multiple instances
Implement texture pooling across game instances
Memory Optimization:
Pool GPU textures and buffers across instances
Share compute pipelines between games
Optimize memory allocation for multiple instances
Minimize GPU memory fragmentation
Batch Processing:
Process multiple game instances on single GPU context
Optimize GPU command buffer submissions
Minimize GPU state changes between instances
Implement efficient GPU-CPU synchronization
Input Processing:
Batch input validation across multiple players
Optimize network message deserialization
Implement efficient player state updates
Minimize context switching between game instances
Memory Management:
Optimize memory allocation patterns
Reduce garbage collection overhead
Efficient state history management
Pool frequently used objects
Bandwidth Reduction:
Active region delta compression (90% reduction)
Predictive state filtering
Spatial proximity optimization
Temporal coherence exploitation
Latency Reduction:
Regional server deployment
CDN integration for initial state
Predictive message transmission
Connection pooling and reuse
Instance Management:
Stateless game servers for easy scaling
Load balancing based on server utilization
Dynamic instance spawning during peak hours
Graceful shutdown and player migration
Resource Management:
Monitor server capacity and utilization
Balance load across available resources
Track GPU, memory, and network usage
Scale instances based on demand
Resource Monitoring:
Real-time GPU utilization tracking
Memory pressure detection and management
CPU bottleneck identification
Network bandwidth monitoring
Adaptive Quality:
Reduce simulation fidelity under load
Dynamic update frequency adjustment
Selective feature disabling during peaks
Graceful degradation strategies
Regional Deployment:
Multiple data centers for global coverage
Player assignment based on latency testing
Cross-region backup for failover
Edge computing for input processing
Protocol Optimization:
UDP consideration for non-critical updates
Message priority queuing
Batch transmission optimization
Connection quality adaptation
Client-Side Optimization:
Minimize prediction processing overhead
Efficient rollback state management
Optimized visual interpolation
Predictive input handling
Network Adaptation:
Monitor connection quality metrics
Adjust prediction windows based on latency
Adapt update frequencies to network conditions
Handle packet loss gracefully
Tile Delta Compression:
Run-length encoding for similar tiles
Bit-field optimization for tile changes
Spatial compression for clustered updates
Temporal compression for predictable patterns
State Synchronization:
Differential state encoding
Chunk-based update grouping
Priority-based transmission
Redundancy elimination
Connection Quality Detection:
Bandwidth measurement and adaptation
Quality of service monitoring
Congestion avoidance algorithms
Fallback mode implementation
Traffic Shaping:
Rate limiting per connection
Burst protection mechanisms
Priority queuing for critical updates
Load balancing across connections
Server Monitoring:
Track frame processing performance
Monitor GPU and memory utilization
Measure network throughput and connections
Count active game instances
Client Monitoring:
Measure prediction accuracy and rollbacks
Track network latency and frame drops
Monitor bandwidth consumption
Assess user experience quality
Automated Analysis:
Performance regression detection
Capacity planning based on usage patterns
Predictive scaling triggers
Anomaly detection for performance issues
Optimization Feedback:
A/B testing for optimization strategies
Performance impact measurement
User experience correlation
Continuous improvement cycles
Container Optimization:
Minimal Docker images for game servers
GPU-optimized container runtime
Efficient resource allocation
Fast startup and shutdown times
Resource Utilization:
Pack multiple game instances per server
Optimize GPU memory sharing
Minimize idle resource consumption
Dynamic resource allocation
Performance Alerts:
Latency threshold violations
Resource utilization warnings
Capacity planning notifications
Service degradation detection
Automated Responses:
Auto-scaling based on demand
Failover to backup servers
Load rebalancing during issues
Performance optimization triggers
This comprehensive performance strategy ensures smooth multiplayer gameplay while maintaining cost-effective server operations.]]></description><link>architecture/systems/multiplayer/performance.html</link><guid isPermaLink="false">architecture/systems/multiplayer/performance.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[client-prediction]]></title><description><![CDATA[Local state prediction with rollback mechanisms for responsive gameplay despite network latency.⚠️ UPDATED SYSTEM: Client prediction now uses the unified Deterministic Time-Sliced Execution pipeline. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> for complete integration details.Single Engine: Same game engine used for single-player and multiplayer prediction.Deterministic Execution: Time-sliced pipeline ensures identical client/server results.Automatic State Management: Built-in snapshots and rollback through unified state system.Frame Synchronization: Time slice alignment with server for precise synchronization.
Local state prediction using identical simulation logic
Server state comparison with automatic mismrediction detection Rollback and re-execution through unified state management
Ghost simulation for action queue visualization
Purpose: Runs identical simulation logic for local prediction.Components:
Same GPU compute shaders as server
Physics and reaction processing
Tile state management with active regions
Deterministic frame execution pipeline
Key Differences:
Operates on unconfirmed inputs
Generates visual output during prediction
Maintains rollback state history
Handles prediction correction smoothly
Confirmed States: Server-validated game states stored every 5 frames
Prediction States: Local simulation results with input applied
Rollback Threshold: Maximum 10 frames (167ms at 60 FPS)
Server State Reception: Authoritative state update arrives
Local Comparison: Compare with predicted state at same frame
Divergence Analysis: Identify significant differences
Rollback Decision: Determine if correction is necessary State Restoration: Revert to last confirmed server state
Input Replay: Re-apply all inputs since that frame
Simulation Catch-up: Run physics/reactions to current frame
Visual Interpolation: Smooth transition to corrected state
Own Actions Only: Predict consequences of local player inputs
Physics Prediction: Tile movement and basic collisions
Spell Effects: Immediate visual feedback for cast spells
Avoid Complex Rules: Don't predict environmental transformationsAll Player Actions: Predict other players' likely actions
Rule Interactions: Attempt complex environmental predictions
Higher Rollback Risk: More frequent corrections needed
Better Responsiveness: Smoother gameplay when predictions succeedNetwork Quality Based: Adjust strategy based on connection stability
Misprediction History: Learn from previous prediction accuracy
Dynamic Threshold: Modify rollback sensitivity based on gameplay contextinterface PredictedInput { frameNumber: number; playerId: string; inputData: PlayerInput; timestamp: number; confirmed: boolean;
} Local Input Capture: Player action registration
Immediate Prediction: Apply to local simulation instantly
Server Transmission: Send input with frame number
Confirmation Tracking: Mark inputs as confirmed when server acknowledges
History Cleanup: Remove old confirmed inputs from buffer
Interpolation: Smooth transition between predicted and actual states
Temporal Blending: Gradual adjustment over multiple frames
Priority System: Prioritize corrections for player-controlled entitiesOptimistic Updates: Show immediate response to player actions
Uncertainty Indicators: Visual cues for unconfirmed actions
Rollback Masking: Hide jarring corrections with effectsSpatial Boundaries: Only predict within player's view range
Temporal Limits: Maximum prediction window of 10 frames
Complexity Filtering: Skip expensive calculations during predictionState Compression: Efficient storage of rollback snapshots
Garbage Collection: Automatic cleanup of old prediction data
GPU Resource Sharing: Reuse textures between prediction and renderingLatency Measurement: Dynamic adjustment of prediction window
Quality Scaling: Reduce prediction complexity on slow connections
Fallback Mode: Disable prediction on extremely poor connectionsDesync Recovery: Full state resynchronization when prediction fails
Input Loss: Request missing inputs from server
State Corruption: Fallback to last known good stateConnection Loss: Maintain prediction until reconnection
High Latency: Extend prediction window with quality reduction
Packet Loss: Request state recovery from serverFrame Drops: Reduce prediction complexity automatically
Memory Pressure: Cleanup old snapshots more aggressively
GPU Issues: Fallback to CPU-only prediction if necessaryThis system provides responsive gameplay while maintaining competitive integrity through authoritative server validation.]]></description><link>architecture/systems/multiplayer/client-prediction.html</link><guid isPermaLink="false">architecture/systems/multiplayer/client-prediction.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[deployment]]></title><description><![CDATA[Container orchestration, regional deployment, and horizontal scaling infrastructure for multiplayer servers.Docker Configuration:
NVIDIA Docker runtime for GPU support
Ubuntu base image with WebGPU drivers
Node.js runtime with GPU-accelerated libraries
Minimal attack surface with only required packages
Container Specifications:FROM nvidia/ubuntu:22.04
RUN apt-get update &amp;&amp; apt-get install -y \ nodejs npm \ nvidia-driver-525 \ vulkan-utils
COPY package*.json ./
RUN npm ci --only=production
COPY dist/ ./dist/
EXPOSE 8080
CMD ["node", "dist/server.js"]
Resource Requirements:
4 vCPU cores per game server instance
16GB RAM per server (supports 8-12 concurrent games)
NVIDIA T4 or equivalent GPU (4GB VRAM minimum)
1Gbps network interface
Kubernetes Deployment:
Pod scheduling with GPU node affinity
Horizontal Pod Autoscaler based on CPU/GPU utilization
Service mesh for inter-service communication
ConfigMap and Secret management for configuration
Alternative: Docker Swarm:
Simpler orchestration for smaller deployments
Built-in load balancing and service discovery
GPU resource constraints and placement
Rolling updates with zero-downtime deployment
Primary Regions:
North America (East/West Coast)
Europe (Frankfurt, London)
Asia-Pacific (Singapore, Tokyo)
Optional: South America, Australia
Region Selection Criteria:
Player population density
Network infrastructure quality
Data sovereignty requirements
Cost optimization opportunities
Matchmaking Service:
Global player queue management
Region assignment based on latency
Cross-region backup for peak times
Load balancing across regional clusters
Data Synchronization:
Player profiles and statistics
Match history and replay data
Configuration and rule updates
Security blacklists and ban information
Auto-Scaling Configuration:apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata: name: game-server-hpa
spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: game-server minReplicas: 3 maxReplicas: 50 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 - type: Resource resource: name: nvidia.com/gpu target: type: Utilization averageUtilization: 80
Scaling Triggers:
CPU utilization &gt;70%
GPU utilization &gt;80%
Memory usage &gt;85%
Queue length &gt;100 waiting players
Average response time &gt;100ms
Resource Optimization:
GPU memory pooling across game instances
CPU allocation based on actual usage patterns
Memory tuning for garbage collection optimization
Network bandwidth allocation per game
Performance Monitoring:
Real-time resource utilization tracking
Application performance monitoring (APM)
Custom metrics for game-specific performance
Alerting for performance degradation
Core Services:interface ServiceArchitecture { gameServer: GameServerService; // Game simulation and state matchmaker: MatchmakingService; // Player matching and queuing authentication: AuthService; // Player authentication statistics: StatsService; // Match history and analytics configuration: ConfigService; // Game rules and settings
}
Service Communication:
gRPC for internal service communication
Redis for shared state and caching
Message queues for asynchronous processing
Service mesh for secure inter-service communication
Application Load Balancer:
Session affinity for WebSocket connections
Health check integration with Kubernetes
Geographic routing for optimal latency
SSL termination and certificate management
Game Server Load Balancing:
Consistent hashing for player assignment
Capacity-based routing
Failover to backup servers
Graceful shutdown with player migration
Game State: Redis cluster for real-time state
Player Data: PostgreSQL for persistent player information
Analytics: ClickHouse for match statistics and telemetry
Configuration: etcd for distributed configuration managementMatch Replays:
Compressed binary format for efficiency
Object storage (S3/GCS) for long-term archival
CDN distribution for replay downloads
Retention policy with automatic cleanup
Player Profiles:
Distributed across regions for performance
Eventual consistency for non-critical data
Backup and disaster recovery procedures
GDPR compliance for data deletion
Build Pipeline:
Source code compilation and TypeScript checking
Unit and integration test execution
Docker image building with security scanning
Image tagging and registry push
Deployment manifest generation
Deployment Strategy:
Blue-green deployment for zero-downtime updates
Canary releases for gradual rollout
Feature flags for controlled feature releases
Automated rollback on deployment failures
Development Environment:
Single-region deployment with minimal resources
Mock services for external dependencies
Debug logging and development tools
Rapid iteration and testing capabilities
Staging Environment:
Production-like configuration with reduced scale
Full integration testing
Performance and load testing
Security vulnerability scanning
Production Environment:
Multi-region deployment with full redundancy
Comprehensive monitoring and alerting
Security hardening and compliance
Disaster recovery procedures
System Metrics:
CPU, memory, GPU utilization per node
Network throughput and latency
Disk I/O and storage utilization
Container resource consumption
Application Metrics:
Game server response times
Player connection counts
Match completion rates
Error rates and exceptions
Critical Alerts:
Service downtime or unreachability
High error rates (&gt;5% of requests)
Resource exhaustion warnings
Security incident detection
Performance Alerts:
Latency degradation (&gt;100ms p95)
GPU utilization spikes (&gt;90%)
Memory pressure warnings
Network congestion detection
Centralized Logging:
ELK Stack (Elasticsearch, Logstash, Kibana) or equivalent
Structured logging with correlation IDs
Log aggregation from all services
Long-term log retention for compliance
Security Logging:
Authentication and authorization events
Suspicious activity detection
Security incident correlation
Audit trail for compliance requirements
Data Backup:
Automated database backups with point-in-time recovery
Game state snapshots for active matches
Configuration backup and version control
Cross-region replication for critical data
Recovery Procedures:
Recovery Time Objective (RTO): 15 minutes
Recovery Point Objective (RPO): 5 minutes
Automated failover for database services
Manual intervention procedures for complex failures
Service Redundancy:
Multi-region deployment with active-active configuration
Automatic traffic rerouting during outages
Graceful degradation during partial failures
Communication plan for extended outages
This deployment architecture provides scalable, reliable multiplayer infrastructure capable of supporting global competitive gameplay with minimal latency and maximum uptime.]]></description><link>architecture/systems/multiplayer/deployment.html</link><guid isPermaLink="false">architecture/systems/multiplayer/deployment.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[texture-management]]></title><description><![CDATA[GPU texture coordination and ping-ponging system for race-condition prevention.Challenge: Prevent GPU read-after-write hazards when multiple systems access the same tile data simultaneously.Solution: Texture ping-ponging using paired textures for each layer.Each layer uses paired textures (layer_A, layer_B) enabling GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards.
Read Phase: Modules read from texture set A
Write Phase: Modules write to texture set B Swap Phase: Texture roles switch for next frame
Barrier: GPU compute dispatch barriers ensure proper execution ordering
Format: r32uint for optimal GPU cache performance
Rationale: Single 32-bit channel matches bit-packed tile format2D Layout: Textures leverage GPU's optimized 2D memory access patterns
Spatial Locality: Neighboring tiles often accessed together benefit from cache prefetching
Input Processing: Reads from current texture set
Physics Pass: Writes to alternate texture set
Reaction Pass: Reads from physics output textures
Render Pass: Reads from stable texture set for display
Active Texture Tracking: Core Engine maintains current read/write texture assignments
Automatic Swapping: Texture roles alternate each frame automatically
Resource Cleanup: Proper GPU resource lifecycle management⚠️ NEEDS IMPLEMENTATION DETAIL: Specific WebGPU texture creation and binding patternsTrade-off: Double memory usage (2x textures per layer) for synchronization safety
Optimization: Memory layout optimized for GPU architecture⚠️ NEEDS DESIGN: GPU resource allocation failure handling and recovery strategies
Race Condition Prevention: Eliminates GPU synchronization hazards
Pipeline Operations: Allows overlapped read/write operations
Memory Layout: 2D texture layout for spatial access patterns Memory Overhead: 2x memory usage per layer
Texture Switching: Minimal GPU overhead for texture binding updates
⚠️ NEEDS SPECIFICATION: Core classes and methods for texture managementPlanned Classes:
TextureManager: Handles ping-ponging and synchronization TileStorage: Manages texture allocation and bit-packing
Integration with GameLoop for frame coordination
]]></description><link>architecture/systems/core/texture-management.html</link><guid isPermaLink="false">architecture/systems/core/texture-management.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[config]]></title><description><![CDATA[Status: 🚧 Stub - This system documentation needs completionSystem for managing game configuration, settings, and runtime parameters.TODO: Add links to configuration components when implemented:
Configuration file formats and schemas
Runtime configuration management
Environment-specific settings
Validation and error handling
TODO: Document configuration system responsibilities:
Game settings and parameters
Environment configuration (dev/test/prod)
Runtime parameter management
Configuration validation and defaults
TODO: Define configuration categories:
Game Settings: Tile limits, world parameters, gameplay constants
Performance Settings: GPU options, rendering quality, frame rate targets
Network Settings: Server endpoints, timeout values, retry policies
Development Settings: Debug flags, logging levels, profiling options
TODO: Add implementation details:
Configuration file loading and parsing
Hot-reloading of configuration changes
Configuration override hierarchy
Validation and schema enforcement
🚧 This file is a stub and needs completion]]></description><link>architecture/systems/config/config.html</link><guid isPermaLink="false">architecture/systems/config/config.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[variable-timing]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed time slice scheduling system that enables variable player action timing while maintaining deterministic 60 FPS execution.Variable Player Speeds: Different players can have different action timing based on status effects.Fixed Mana Timing: Mana recharge remains strategically consistent regardless of player speed changes.Smooth Physics: Maintain 60 FPS physics simulation for fluid movement.Deterministic Execution: All timing decisions must be reproducible for multiplayer.Frame Duration: 16.67ms (60 FPS)
Time Slices: 8 slices per frame
Slice Duration: 2.08ms per sliceRationale: 8 slices provides sufficient granularity for speed effects (0.5x to 2x) while maintaining reasonable processing overhead.interface TimeSliceSchedule { // Base timing (normal speed) baseActionInterval: 8; // 8 slices = 1 action baseManaInterval: 24; // 24 slices = 3 actions // Physics runs every slice for smooth motion physicsInterval: 1; // Reactions run less frequently for performance reactionInterval: 4; // Every 4 slices
}
Speed Effects: Status effects modify player action timing immediately.Calculation: newInterval = baseInterval / speedMultiplierSpeed Ranges: Slowed: 0.5x (16 slices per action)
Normal: 1.0x (8 slices per action) Hasted: 2.0x (4 slices per action)
interface PlayerActionSchedule { playerId: string; currentInterval: number; // Current slices between actions nextActionSlice: number; // When next action executes queuedActions: PlayerAction[]; // 3 actions lookahead speedMultiplier: number; // Current speed effect
} class TimeSliceScheduler { private playerSchedules = new Map&lt;string, PlayerActionSchedule&gt;(); private currentSlice = 0; // Process all scheduled actions for this slice processSlice(sliceIndex: number) { this.currentSlice = sliceIndex; // Process players in deterministic order (by ID) const sortedPlayerIds = Array.from(this.playerSchedules.keys()).sort(); for (const playerId of sortedPlayerIds) { this.processPlayerSchedule(playerId, sliceIndex); } } private processPlayerSchedule(playerId: string, slice: number) { const schedule = this.playerSchedules.get(playerId); if (schedule.nextActionSlice === slice) { // Execute queued action const action = schedule.queuedActions.shift(); this.executePlayerAction(playerId, action); // Schedule next action schedule.nextActionSlice = slice + schedule.currentInterval; // Request new action for queue this.requestNextAction(playerId); } }
}
Independence: Mana timing unaffected by player speed changes.Strategic Consistency: Players can rely on consistent mana timing for tactical planning.Implementation: Separate timing system running parallel to player actions.class ManaRechargeScheduler { private readonly MANA_RECHARGE_INTERVAL = 24; // 3 base actions worth private nextRechargeSlice = 24; processSlice(sliceIndex: number) { if (sliceIndex === this.nextRechargeSlice) { this.rechargeManaFlowers(); this.nextRechargeSlice += this.MANA_RECHARGE_INTERVAL; } } private rechargeManaFlowers() { // Recharge all mana flowers regardless of player speeds for (const flower of this.getAllManaFlowers()) { flower.recharge(); } }
}
Timing Update: Speed effects immediately modify next action timing.Queue Preservation: Existing action queue remains valid but timing adjusts.Deterministic Application: Speed changes processed in consistent order.class StatusEffectManager { applySpeedEffect(playerId: string, newMultiplier: number) { const schedule = this.scheduler.getPlayerSchedule(playerId); const currentSlice = this.scheduler.getCurrentSlice(); // Calculate remaining time to next action const remainingSlices = schedule.nextActionSlice - currentSlice; // Apply speed change to remaining time const speedChange = newMultiplier / schedule.speedMultiplier; const newRemainingSlices = Math.ceil(remainingSlices / speedChange); // Update schedule schedule.speedMultiplier = newMultiplier; schedule.currentInterval = Math.ceil(8 / newMultiplier); // 8 = base interval schedule.nextActionSlice = currentSlice + newRemainingSlices; // Invalidate affected ghost predictions this.ghostSimulator.invalidatePlayerPredictions(playerId); }
}
Simultaneous Actions: When multiple players have actions scheduled for same slice, process in deterministic order (player ID).Queue Validation: Validate action legality when scheduled, not when executed.Timing Consistency: Ensure identical timing calculations across all clients and server.class SchedulingEdgeCases { // Handle sub-slice timing precision handleFractionalSlices(calculatedSlices: number): number { // Always round up to ensure actions don't execute too early return Math.ceil(calculatedSlices); } // Handle extreme speed changes clampSpeedMultiplier(multiplier: number): number { return Math.max(0.1, Math.min(10.0, multiplier)); } // Handle action queue overflow validateActionQueue(queue: PlayerAction[]): boolean { // Ensure queue never exceeds 3 actions return queue.length &lt;= 3; }
}
Sparse Processing: Only process slices with scheduled events.Batch Operations: Group similar operations within same slice.Memory Efficiency: Use circular buffers for timing data.Consistent Frequency: Physics processes every slice for smooth motion.Interpolation: Visual interpolation between physics updates for display.State Synchronization: Ensure physics state consistency with action timing.Lookahead: Simulate 3 queued actions for each player.Timing Prediction: Account for current speed effects in predictions.Invalidation: Update predictions when speed effects change.class GhostTimingPredictor { predictActionTiming(playerId: string, actionCount: number): number[] { const schedule = this.scheduler.getPlayerSchedule(playerId); const predictions: number[] = []; let nextSlice = schedule.nextActionSlice; for (let i = 0; i &lt; actionCount; i++) { predictions.push(nextSlice); nextSlice += schedule.currentInterval; } return predictions; }
}
Determinism Tests: Verify identical timing across multiple runs.Edge Case Coverage: Test extreme speed values and rapid changes.Synchronization Validation: Ensure client-server timing consistency.Slice Processing Overhead: Measure time slice processing cost.Memory Usage: Monitor scheduling data structure efficiency.Scalability: Test with varying player counts and speed effects.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/deterministic-execution.html" data-href="deterministic-execution" aria-label="deterministic-execution" data-tooltip-position="top" target="_self">Deterministic Execution</a> - Execution order and consistency
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> - Integration with state snapshots
⚠️ NEEDS TEAM DISCUSSION:
Optimal slice count (current proposal: 8 slices per frame)
Speed multiplier ranges (current proposal: 0.1x to 10x)
Ghost prediction complexity vs performance trade-offs
⚠️ NEEDS IMPLEMENTATION:
Detailed performance benchmarking of time slice overhead
Integration testing with existing Core Engine texture management
Multiplayer synchronization validation
]]></description><link>architecture/general/variable-timing.html</link><guid isPermaLink="false">architecture/general/variable-timing.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[state-management]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed unified state management approach that serves both single-player gameplay and multiplayer networking requirements through a single pipeline.Core Concept: Use identical state management for single-player, multiplayer client prediction, and multiplayer server authority.Benefits:
Consistent behavior across all game modes
Simplified testing and debugging
Reduced code duplication
Natural multiplayer upgrade path Frame-based snapshots for rollback and networking
Deterministic state serialization for cross-platform consistency Efficient delta compression for multiplayer bandwidth optimization
Rollback recovery for client prediction correction
Frequency: Every frame (60 FPS) for complete state history.Retention: 300 snapshots (5 seconds) in circular buffer for rollback window.Compression: Incremental snapshots with delta compression for memory efficiency.interface GameStateSnapshot { frameNumber: number; timestamp: number; // Core game data tileData: CompressedTileData; playerStates: PlayerStateData[]; activeChunks: ChunkId[]; // Timing system state timeSliceState: TimeSliceSchedulerState; manaRechargeState: ManaSchedulerState; // Validation checksum: string; // Compression metadata deltaBaseFrame?: number; compressionLevel: 'full' | 'delta' | 'minimal';
} class StateSnapshotManager { private snapshots = new CircularBuffer&lt;GameStateSnapshot&gt;(300); private deltaCompressor = new DeltaCompressor(); saveFrameState(frameNumber: number, gameState: GameState): void { const snapshot = this.createSnapshot(frameNumber, gameState); this.snapshots.push(snapshot); // Clean up old snapshots beyond retention window this.cleanupOldSnapshots(); } private createSnapshot(frameNumber: number, state: GameState): GameStateSnapshot { // Determine compression strategy const useFullSnapshot = frameNumber % 60 === 0; // Every second const compressionLevel = useFullSnapshot ? 'full' : 'delta'; return { frameNumber, timestamp: performance.now(), tileData: this.compressTileData(state.tiles, compressionLevel), playerStates: this.serializePlayerStates(state.players), activeChunks: Array.from(state.activeChunks), timeSliceState: state.scheduler.serialize(), manaRechargeState: state.manaScheduler.serialize(), checksum: this.calculateChecksum(state), deltaBaseFrame: useFullSnapshot ? undefined : frameNumber - 1, compressionLevel }; }
}
Multiplayer Misprediction: Server state differs from client prediction.Determinism Failure: Checksum mismatch in single-player determinism testing.Network Recovery: Client needs to resynchronize with server.class RollbackManager { async rollbackToFrame(targetFrame: number): Promise&lt;boolean&gt; { // Find target snapshot const snapshot = this.snapshotManager.getSnapshot(targetFrame); if (!snapshot) { console.error(`Cannot rollback: snapshot ${targetFrame} not found`); return false; } // Restore game state await this.restoreGameState(snapshot); // Re-execute frames from rollback point to current const currentFrame = this.gameEngine.getCurrentFrame(); for (let frame = targetFrame + 1; frame &lt;= currentFrame; frame++) { await this.replayFrame(frame); } return true; } private async restoreGameState(snapshot: GameStateSnapshot): Promise&lt;void&gt; { // Restore tile data await this.tileManager.restoreFromSnapshot(snapshot.tileData); // Restore player states this.playerManager.restoreFromSnapshot(snapshot.playerStates); // Restore timing system state this.scheduler.deserialize(snapshot.timeSliceState); this.manaScheduler.deserialize(snapshot.manaRechargeState); // Validate restoration const restoredChecksum = this.calculateChecksum(this.gameState); if (restoredChecksum !== snapshot.checksum) { throw new Error('State restoration checksum mismatch'); } }
}
Local Simulation: Run complete game simulation locally for responsiveness.Server Validation: Compare local state with authoritative server updates.Automatic Correction: Rollback and re-execute when server state differs.class ClientPredictionManager { private pendingInputs = new Map&lt;number, PlayerInput[]&gt;(); private serverStates = new Map&lt;number, GameStateSnapshot&gt;(); processServerUpdate(serverSnapshot: GameStateSnapshot): void { const frameNumber = serverSnapshot.frameNumber; this.serverStates.set(frameNumber, serverSnapshot); // Compare with local prediction const localSnapshot = this.snapshotManager.getSnapshot(frameNumber); if (localSnapshot &amp;&amp; !this.statesMatch(localSnapshot, serverSnapshot)) { console.log(`Misprediction detected at frame ${frameNumber}, rolling back`); this.rollbackManager.rollbackToFrame(frameNumber); } // Confirm inputs up to this frame this.confirmInputsUpToFrame(frameNumber); } private statesMatch(local: GameStateSnapshot, server: GameStateSnapshot): boolean { // Compare essential game state (ignore client-only data) return ( local.checksum === server.checksum &amp;&amp; this.tileDataMatches(local.tileData, server.tileData) &amp;&amp; this.playerStatesMatch(local.playerStates, server.playerStates) ); }
}
Authoritative Simulation: Server runs definitive game simulation.Input Validation: Validate all client inputs before application.State Broadcasting: Send compressed state updates to all clients.class ServerAuthorityManager { private connectedClients = new Set&lt;ClientConnection&gt;(); processFrame(): void { // Standard game processing this.gameEngine.processFrame(); // Generate state delta for clients const currentFrame = this.gameEngine.getCurrentFrame(); const stateDelta = this.generateStateDelta(currentFrame); // Broadcast to all clients this.broadcastStateDelta(stateDelta); } private generateStateDelta(frameNumber: number): StateDelta { const currentSnapshot = this.snapshotManager.getSnapshot(frameNumber); const previousSnapshot = this.snapshotManager.getSnapshot(frameNumber - 1); return this.deltaCompressor.createDelta(previousSnapshot, currentSnapshot); }
}
Change Detection: Only transmit modified tiles per frame.Run-Length Encoding: Compress sequences of similar changes.Spatial Compression: Group changes by active regions.class TileDeltaCompressor { compressTileChanges(oldTiles: TileData, newTiles: TileData): CompressedTileData { const changes: TileChange[] = []; // Detect changes for (let y = 0; y &lt; this.worldHeight; y++) { for (let x = 0; x &lt; this.worldWidth; x++) { const oldTile = oldTiles.getTile(x, y); const newTile = newTiles.getTile(x, y); if (oldTile !== newTile) { changes.push({ x, y, oldValue: oldTile, newValue: newTile }); } } } // Apply compression algorithms return this.compressChanges(changes); } private compressChanges(changes: TileChange[]): CompressedTileData { // Group by active chunks const chunkChanges = this.groupByChunk(changes); // Apply run-length encoding within chunks const compressed = chunkChanges.map(chunk =&gt; this.runLengthEncode(chunk.changes) ); return { changedChunks: compressed, compressionRatio: changes.length / compressed.length }; }
}
Snapshot Pooling: Reuse snapshot objects to reduce garbage collection.Lazy Compression: Compress snapshots in background thread when possible.Memory-Mapped Storage: Use efficient binary formats for large state data.Adaptive Compression: Adjust compression level based on network conditions.Priority Transmission: Send critical state changes immediately.Batch Optimization: Group small changes into larger network packets.Incremental Replay: Only re-execute affected systems during rollback.State Caching: Cache frequently accessed rollback points.Parallel Processing: Use worker threads for rollback computation when possible.Checksum Validation: Verify state integrity at snapshot creation and restoration.Cross-Reference Checking: Validate state consistency across different data structures.Automated Recovery: Attempt automatic recovery from last known good state.Connection Recovery: Seamless reconnection with state synchronization.Missing Data Recovery: Request missing snapshots from server.Graceful Degradation: Continue local simulation during temporary disconnections.class DeterminismValidator { validateStateConsistency(snapshot: GameStateSnapshot): ValidationResult { // Check internal consistency const tileConsistency = this.validateTileData(snapshot.tileData); const playerConsistency = this.validatePlayerStates(snapshot.playerStates); const timingConsistency = this.validateTimingState(snapshot.timeSliceState); // Verify checksum const calculatedChecksum = this.calculateChecksum(snapshot); const checksumValid = calculatedChecksum === snapshot.checksum; return { valid: tileConsistency &amp;&amp; playerConsistency &amp;&amp; timingConsistency &amp;&amp; checksumValid, errors: this.collectValidationErrors(), warnings: this.collectValidationWarnings() }; }
} cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture <br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Integration with time slice scheduling
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/multiplayer/multiplayer.html" data-href="multiplayer" aria-label="multiplayer" data-tooltip-position="top" target="_self">Multiplayer System</a> - Network protocol and client prediction details
⚠️ NEEDS TEAM DISCUSSION:
Snapshot retention policy (current proposal: 5 seconds)
Delta compression vs full snapshot frequency (current proposal: every 60 frames)
Rollback window limits for client prediction
⚠️ NEEDS IMPLEMENTATION:
Performance benchmarking of snapshot creation overhead
Network bandwidth testing with delta compression
Cross-platform determinism validation suite
]]></description><link>architecture/general/state-management.html</link><guid isPermaLink="false">architecture/general/state-management.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[ghost-simulation]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed predictive action visualization system that shows players their queued actions and their likely outcomes without affecting the main game simulation.Action Preview: Show visual representation of 3 queued player actions.Spell Effect Prediction: Display where runes will be placed and their likely effects.Movement Prediction: Show future player positions based on queued movement.Performance Constraint: Ghost simulation must not impact main game performance.Simplified Rules: Use fast approximations instead of full physics/reaction simulation.Position-Only Physics: Predict movement without complex collision interactions.Basic Spell Effects: Show rune placement without full environmental predictions.Selective Simulation: Only simulate aspects visible to players.interface GhostPrediction { actionIndex: number; // Which queued action (0, 1, 2) playerPosition: Position; // Predicted player position spellEffects: RunePlacement[]; // Predicted rune placements confidence: number; // Prediction confidence (0-1) timestamp: number; // When prediction was generated
} class GhostSimulator { private predictionCache = new Map&lt;string, GhostPrediction[]&gt;(); private simulationComplexity: 'minimal' | 'basic' | 'detailed' = 'basic'; updatePlayerGhosts(playerId: string): GhostPrediction[] { const cacheKey = this.generateCacheKey(playerId); // Check cache validity if (this.isCacheValid(cacheKey)) { return this.predictionCache.get(cacheKey); } // Generate new predictions const predictions = this.simulatePlayerActions(playerId); this.predictionCache.set(cacheKey, predictions); return predictions; }
}
Minimal: Position-only prediction with no interaction simulation.
Movement vectors applied directly
Spell targeting shown without environmental effects
Fastest performance, lowest accuracy
Basic: Position + simple spell effects prediction.
Basic collision detection for movement
Rune placement validation
Simple environmental effects (obvious barriers, holes)
Balanced performance and accuracy
Detailed: Full simulation using simplified rules.
Complete physics simulation with reduced precision
Environmental rule evaluation with fast heuristics
Complex spell interactions predicted
Higher accuracy, potential performance impact
class MovementPredictor { predictMovement(player: PlayerState, action: MovementAction): Position { let currentPos = player.position; const moveVector = this.calculateMoveVector(action); // Simple collision detection for ghost prediction const targetPos = { x: currentPos.x + moveVector.x, y: currentPos.y + moveVector.y }; // Check for obvious barriers if (this.isPositionBlocked(targetPos)) { return currentPos; // No movement if blocked } return targetPos; } private isPositionBlocked(position: Position): boolean { // Simplified collision detection for performance const tile = this.getTileAt(position); return tile?.type === TileType.SOLID || tile?.type === TileType.WALL; }
}
class SpellEffectPredictor { predictSpellCast(player: PlayerState, spell: SpellAction): RunePlacement[] { const placements: RunePlacement[] = []; // Validate mana requirements if (!this.hasRequiredMana(player, spell)) { return []; // No effect if insufficient mana } // Calculate rune placements const pattern = this.getSpellPattern(spell.spellId); const targetPos = spell.targetPosition; for (const offset of pattern.runeOffsets) { const runePos = { x: targetPos.x + offset.x, y: targetPos.y + offset.y }; // Basic placement validation if (this.canPlaceRune(runePos)) { placements.push({ position: runePos, runeType: pattern.runeType, delay: pattern.delay, confidence: this.calculatePlacementConfidence(runePos) }); } } return placements; }
}
Cache Keys: Based on player state hash and action queue hash.Invalidation: Cache invalidated when player state or world state changes significantly.Selective Updates: Only update ghosts for players whose state changed.class GhostCacheManager { private readonly CACHE_DURATION = 100; // ms generateCacheKey(playerId: string): string { const player = this.getPlayer(playerId); const actionQueueHash = this.hashActionQueue(player.actionQueue); const playerStateHash = this.hashPlayerState(player); const worldStateHash = this.getRelevantWorldStateHash(player.position); return `${playerId}-${actionQueueHash}-${playerStateHash}-${worldStateHash}`; } isCacheValid(cacheKey: string): boolean { const cached = this.predictionCache.get(cacheKey); if (!cached) return false; const age = performance.now() - cached.timestamp; return age &lt; this.CACHE_DURATION; } invalidatePlayerCache(playerId: string): void { // Remove all cache entries for this player for (const [key, _] of this.predictionCache) { if (key.startsWith(playerId)) { this.predictionCache.delete(key); } } }
}
Performance Monitoring: Adjust simulation complexity based on frame rate.Player Count Scaling: Reduce complexity when many players are active.Network Condition Adaptation: Simplify predictions on slow connections.class AdaptiveGhostManager { private performanceMonitor = new PerformanceMonitor(); updateSimulationComplexity(): void { const currentFPS = this.performanceMonitor.getCurrentFPS(); const playerCount = this.getActivePlayerCount(); if (currentFPS &lt; 55 || playerCount &gt; 6) { this.ghostSimulator.setComplexity('minimal'); } else if (currentFPS &lt; 58 || playerCount &gt; 4) { this.ghostSimulator.setComplexity('basic'); } else { this.ghostSimulator.setComplexity('detailed'); } }
}
Player Ghosts: Translucent player sprites at predicted positions.Action Indicators: Visual cues showing queued action types.Spell Previews: Targeting lines and rune placement previews.Confidence Visualization: Alpha/color coding based on prediction confidence.interface GhostVisual { playerId: string; actionIndex: number; position: Position; alpha: number; // Transparency based on confidence actionIndicator: ActionType; spellPreview?: SpellPreview;
} class GhostRenderer { renderPlayerGhosts(predictions: GhostPrediction[]): void { for (let i = 0; i &lt; predictions.length; i++) { const prediction = predictions[i]; const alpha = this.calculateAlpha(prediction.confidence, i); this.renderGhostPlayer({ playerId: prediction.playerId, actionIndex: i, position: prediction.playerPosition, alpha: alpha, actionIndicator: prediction.actionType, spellPreview: prediction.spellEffects }); } } private calculateAlpha(confidence: number, actionIndex: number): number { // Closer actions are more opaque, further actions more transparent const timeAlpha = 1.0 - (actionIndex * 0.2); const confidenceAlpha = 0.3 + (confidence * 0.7); return timeAlpha * confidenceAlpha; }
}
Prediction Timing: Account for variable action timing in predictions.Speed Effect Integration: Update predictions when player speed changes.Action Queue Synchronization: Maintain predictions synchronized with action queue.class GhostTimingIntegration { updateGhostTimingForSpeedChange(playerId: string, newSpeedMultiplier: number): void { // Recalculate prediction timing based on new speed const predictions = this.ghostSimulator.getPlayerPredictions(playerId); for (const prediction of predictions) { const newTiming = this.recalculateActionTiming( prediction.actionIndex, newSpeedMultiplier ); prediction.expectedExecutionSlice = newTiming; } // Invalidate cache to force regeneration this.ghostCacheManager.invalidatePlayerCache(playerId); } private recalculateActionTiming(actionIndex: number, speedMultiplier: number): number { const baseInterval = 8; // 8 time slices per action at normal speed const adjustedInterval = Math.ceil(baseInterval / speedMultiplier); return this.currentSlice + (adjustedInterval * (actionIndex + 1)); }
}
Invalid Actions: Show warning indicators for actions that can't be executed.Resource Conflicts: Display mana insufficiency or other blocking conditions.Simulation Errors: Graceful degradation to simpler prediction methods.class GhostErrorHandler { handlePredictionError(playerId: string, error: PredictionError): GhostPrediction { console.warn(`Ghost prediction error for ${playerId}:`, error); switch (error.type) { case 'insufficient-mana': return this.createManaWarningGhost(playerId, error.actionIndex); case 'invalid-target': return this.createTargetWarningGhost(playerId, error.actionIndex); case 'simulation-timeout': return this.fallbackToPositionOnlyPrediction(playerId, error.actionIndex); default: return this.createErrorGhost(playerId, error.actionIndex); } }
}
Accuracy Metrics: Track how often predictions match actual outcomes.Performance Benchmarks: Monitor ghost simulation performance impact.User Experience Testing: Validate that ghost feedback improves gameplay.Action Queue Edge Cases: Test ghost behavior with rapidly changing queues.Speed Effect Interactions: Verify ghost timing updates with status effects.Network Lag Simulation: Test ghost behavior under various network conditions.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Integration with action scheduling
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/rendering/rendering.html" data-href="rendering" aria-label="rendering" data-tooltip-position="top" target="_self">Renderer System</a> - Visual rendering integration
⚠️ NEEDS TEAM DISCUSSION:
Default simulation complexity level (minimal/basic/detailed)
Ghost prediction accuracy vs performance trade-offs
Visual design for ghost representation (transparency, colors, indicators)
⚠️ NEEDS IMPLEMENTATION:
Performance benchmarking of different complexity levels
User experience testing of ghost feedback effectiveness
Integration testing with action queue and timing systems
]]></description><link>architecture/general/ghost-simulation.html</link><guid isPermaLink="false">architecture/general/ghost-simulation.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[data-flow]]></title><description><![CDATA[⚠️ OUTDATED DOCUMENT: This document describes a previously proposed Deterministic Time-Sliced Execution pipeline. The physics system has been updated and this document no longer reflects the current architectural direction. This document will be rebuilt to match the current physics system approach.The new pipeline subdivides each 60 FPS frame into 8 time slices, enabling variable player action timing while maintaining perfect determinism for multiplayer.
Frame Duration: 16.67ms (60 FPS)
Time Slices: 8 slices per frame (2.08ms each)
Variable Timing: Different systems execute at different slice intervals
Deterministic Order: All processing uses strict spatial/temporal ordering
Each frame processes 8 time slices in deterministic order:
Scheduled Action Processing: Execute player actions based on individual timing
Mana Recharge Processing: Fixed 3-action interval regardless of player speed
Physics Processing: Every slice for 60 FPS smooth motion
Reaction Processing: Less frequent, deterministic intervals
Ghost Prediction Updates: Maintain 3-action lookahead for all players State Snapshot: Save complete game state for rollback/networking
Network Delta Generation: Create compressed updates for multiplayer
Validation: Verify deterministic execution consistency Base Interval: 8 time slices (normal speed)
Speed Multipliers: Status effects modify timing (0.5x = slowed, 2x = hasted)
Immediate Application: Speed changes affect next scheduled action
Deterministic Order: Players processed by ID for consistent results Fixed Schedule: 24 time slices (3 base actions) regardless of player speed
Strategic Consistency: Mana timing remains constant tactical element
Independent Processing: Separate from player action timing 3-Action Lookahead: Players maintain queue of upcoming actions
Ghost Predictions: Visual preview of queued actions
Queue Validation: Invalid actions automatically replaced Spatial Ordering: Process tiles in strict top-left to bottom-right order
Chunk Processing: Handle 32×32 chunks in deterministic sequence
Integer Mathematics: Fixed-point arithmetic prevents floating-point drift
Synchronization Barriers: GPU compute barriers ensure execution order Deterministic Math Library: Custom integer-only calculations
Hardware Independence: Identical results across GPU architectures
Validation Testing: Automated cross-platform determinism verification Single Pipeline: Same engine for single-player and multiplayer modes
State Snapshots: Automatic frame-based state saving
Rollback Capability: Support for multiplayer prediction correction
Network Synchronization: Frame-based state delta compression Client Prediction: Local state prediction with server validation
Rollback Recovery: Automatic correction on server mismatch
Network Protocol: Frame-synchronized state updates
Ghost Simulation: Predictive action visualization Selective Processing: Only active systems process each slice
GPU Batching: Maintain efficient compute shader dispatches
Memory Coherence: Optimize texture access patterns
Chunk Activation: Process only regions with activity Adaptive Frequencies: Reduce reaction frequency under load
Prediction Caching: Cache ghost simulations for performance
Network Efficiency: Delta compression minimizes bandwidth
State Cleanup: Automatic old state garbage collection cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/deterministic-execution.html" data-href="deterministic-execution" aria-label="deterministic-execution" data-tooltip-position="top" target="_self">Deterministic Execution</a> - GPU determinism and cross-platform consistency
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Time slice scheduling and player action management
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> - Snapshots, rollback, and multiplayer synchronization
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/ghost-simulation.html" data-href="ghost-simulation" aria-label="ghost-simulation" data-tooltip-position="top" target="_self">Ghost Simulation</a> - Predictive action visualization system
⚠️ NEEDS TEAM DISCUSSION: Optimal time slice count (8 vs 4 vs 16)
Performance impact of deterministic GPU ordering
Ghost simulation complexity vs performance trade-offs
]]></description><link>architecture/general/data-flow.html</link><guid isPermaLink="false">architecture/general/data-flow.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item></channel></rss>