<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[source_docs]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>source_docs</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 17 Nov 2025 04:21:48 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 17 Nov 2025 04:21:36 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[shader-data-layout]]></title><description><![CDATA[Central tracking document for all data stored in GPU shader passes and bit allocation for each field.This document tracks all fields that need to be stored in GPU textures for physics, reactions, and rendering systems. Once all requirements are gathered, bit allocations will be determined to optimize texture memory usage.
Hex cell coordinates (q, r)
Sub-grid offset (x, y) - fixed-point Velocity vector (x, y) - fixed-point Object type ID
Mass (may be computed from type instead of stored)
Layer (Ground/Object/Air) Timer type (number of bits TBD - depends on number of timer types)
Timer value (number of bits TBD - count-up timer, max duration TBD) Object exists flag
(Additional flags TBD)
⚠️ TODO: Determine bit counts for each field once all requirements are gathered.⚠️ TODO: Calculate total bits per object and optimize packing strategy.
Physics: Position, velocity, mass - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/movement.html" data-href="physics/movement" aria-label="physics/movement" data-tooltip-position="top" target="_self">Movement System</a>
<br>Reactions: Timer type, timer value, type transformations - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="physics/reactions" aria-label="physics/reactions" data-tooltip-position="top" target="_self">Reaction System</a>
<br>Rendering: All data for visual representation - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/rendering/rendering.html" data-href="rendering" aria-label="rendering" data-tooltip-position="top" target="_self">Rendering</a>
]]></description><link>architecture/general/shader-data-layout.html</link><guid isPermaLink="false">architecture/general/shader-data-layout.md</guid><pubDate>Wed, 12 Nov 2025 05:27:37 GMT</pubDate></item><item><title><![CDATA[general]]></title><description><![CDATA[Core architectural concepts, design patterns, and system design documentation for Reaction v2.
<a class="internal-link" data-href="overview.md" href="architecture/general/overview.html" target="_self" rel="noopener nofollow"><strong></strong></a>System Overview - Complete architectural design and module relationships
<br><a class="internal-link" data-href="data-flow.md" href="architecture/general/data-flow.html" target="_self" rel="noopener nofollow"><strong></strong></a>Data Flow - Frame execution pipeline and module communication ⚠️ OUTDATED
<br><a class="internal-link" data-href="performance.md" href="architecture/general/performance.html" target="_self" rel="noopener nofollow"><strong></strong></a>Performance Strategy - Optimization approaches and technical constraints
<br><a class="internal-link" data-href="technical-decisions.md" href="architecture/general/technical-decisions.html" target="_self" rel="noopener nofollow"><strong></strong></a>Technical Decisions - Design choices and rationale <br><a class="internal-link" data-href="implementation-guide.md" href="architecture/general/implementation-guide.html" target="_self" rel="noopener nofollow"><strong></strong></a>Implementation Guide - Step-by-step implementation approach ⚠️ STUB
<br><a class="internal-link" data-href="determinism.md" href="architecture/general/determinism.html" target="_self" rel="noopener nofollow"><strong></strong></a>Determinism - Fixed-point arithmetic and cross-platform consistency
<br><a class="internal-link" data-href="variable-timing.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Variable Timing System - Time slice scheduling and player action management ⚠️ PROPOSED
<br><a class="internal-link" data-href="state-management.md" href="architecture/general/state-management.html" target="_self" rel="noopener nofollow"><strong></strong></a>State Management - Snapshots, rollback, and multiplayer synchronization ⚠️ STUB
<br><a class="internal-link" data-href="ghost-simulation.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Ghost Simulation - Predictive action visualization system ⚠️ PROPOSED
Modular Design: Modules with focused responsibilitiesWebGPU Processing: Physics, reactions, and rendering use GPU computeDeterministic Requirements: Identical inputs must produce identical outputs for PvP through simultaneous single-read/single-write GPU passesActive Region System: Process only chunks with changing tiles ⚠️ NOT IMPLEMENTED: Active region optimization was decided against⚠️ Unsolved Issues Requiring Design Work:
Frame rate coordination between physics, reactions, and rendering systems
GPU thread execution determinism guarantees (current approach: simultaneous read/write passes)
Specific rule compilation pipeline implementation
]]></description><link>architecture/general/general.html</link><guid isPermaLink="false">architecture/general/general.md</guid><pubDate>Wed, 12 Nov 2025 05:27:19 GMT</pubDate></item><item><title><![CDATA[physics]]></title><description><![CDATA[GPU-accelerated physics simulation on a hexagonal grid with sub-grid positioning, force-based interactions, and object merging mechanics.The physics engine provides realistic object movement, interactions, and transformations using:
Hexagonal grid with polar coordinates for efficient circular world representation
Sub-grid positioning with fixed-point arithmetic for smooth, deterministic movement
Force-based physics including collision repulsion, cohesion attraction, and spell forces
Object merging that combines nearby objects to maintain one object per hex cell
Reaction system for object transformations from merging, environmental interactions, and timers
Multi-pass GPU pipeline for parallel force application, reactions, and collision resolution <a data-tooltip-position="top" aria-label="movement" data-href="movement" href="architecture/systems/physics/movement.html" class="internal-link" target="_self" rel="noopener nofollow">Movement</a> - Hexagonal grid, sub-grid positioning, velocity, and mass
<br><a data-tooltip-position="top" aria-label="cohesion" data-href="cohesion" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">Cohesion</a> - Gap-closing attraction forces
<br><a data-tooltip-position="top" aria-label="collision" data-href="collision" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">Collision</a> - Overlap repulsion forces <br><a data-tooltip-position="top" aria-label="object-merging" data-href="object-merging" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">Object Merging</a> - How nearby objects combine into single objects
<br><a data-tooltip-position="top" aria-label="reactions" data-href="reactions" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">Reactions</a> - Type transformations from merging and environmental patterns <br><a data-tooltip-position="top" aria-label="passes" data-href="passes" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">Pipeline Passes</a> - GPU execution coordination
<br><a data-tooltip-position="top" aria-label="spell-integration" data-href="spell-integration" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">Spell Integration</a> - How spells affect physics layer
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/determinism.html" data-href="general/determinism" aria-label="general/determinism" data-tooltip-position="top" target="_self">Determinism</a> - Fixed-point arithmetic and cross-platform consistency ensuring identical physics results everywhereHexagonal Grid: Corner-to-corner cell size d ensures no two objects occupy the same cell, even during movement.Direct Force Resolution: Forces applied continuously while objects overlap - no iterative convergence.Speed Limits: Maximum ~9.69 cells/second at 60fps, with typical gameplay 2-6 cells/second.Three Layers: Ground, Object, and Air layers for different entity types.<br>Spell System: Spells apply forces and trigger tile transformations - see <a data-tooltip-position="top" aria-label="spell-integration" data-href="spell-integration" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">Spell Integration</a>.Renderer: Provides sub-grid positions, velocities, and timer states for smooth visuals.]]></description><link>architecture/systems/physics/physics.html</link><guid isPermaLink="false">architecture/systems/physics/physics.md</guid><pubDate>Wed, 12 Nov 2025 05:26:49 GMT</pubDate></item><item><title><![CDATA[spells]]></title><description><![CDATA[GPU-accelerated spellcasting with 26-element magic system, mana flower economy, slot/pool casting interface, and deck customization.Player-controlled spellcasting creates runes on the game world through geometric element combinations, resource management, and strategic deck building.Processing: Fully GPU-accelerated (shape evaluation, element combination, rune lifecycle)Core Systems: Elements (26), Mana (6 flowers), Casting (slot/pool), Runes (lifecycle), Deck Building (singleton)
<a data-tooltip-position="top" aria-label="element-system" data-href="element-system" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">Element System</a> - 26 elements in cube/octahedron structure
<br><a data-tooltip-position="top" aria-label="element-effects" data-href="element-effects" href="architecture/systems/spells/element-effects.html" class="internal-link" target="_self" rel="noopener nofollow">Element Effects</a> - What each element does (forces, transformations, passives)
<br><a data-tooltip-position="top" aria-label="mana-system" data-href="mana-system" href="architecture/systems/spells/mana-system.html" class="internal-link" target="_self" rel="noopener nofollow">Mana System</a> - 6 flower types with recharge and conversion
<br><a data-tooltip-position="top" aria-label="spells-and-runes" data-href="spells-and-runes" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">Spells and Runes</a> - Casting interface and rune lifecycle
<br><a data-tooltip-position="top" aria-label="deck-building" data-href="deck-building" href="architecture/systems/spells/deck-building.html" class="internal-link" target="_self" rel="noopener nofollow">Deck Building</a> - Deck rules and pre-match construction
<br><a data-tooltip-position="top" aria-label="customization" data-href="customization" href="architecture/systems/spells/customization.html" class="internal-link" target="_self" rel="noopener nofollow">Customization</a> - Curse system and build options
<br><a data-tooltip-position="top" aria-label="cpu-architecture" data-href="cpu-architecture" href="architecture/systems/spells/cpu-architecture.html" class="internal-link" target="_self" rel="noopener nofollow">CPU Architecture</a> - Outdated, system now GPU-accelerated <br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/spell-integration.html" data-href="../physics/spell-integration" aria-label="../physics/spell-integration" data-tooltip-position="top" target="_self">Spell Integration</a> - How spells affect physics layer
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href=".html" data-href="../core/core" aria-label="../core/core" data-tooltip-position="top" target="_self">Core Engine</a> - Texture management and layer coordination
<br>Physics Engine: Spells apply forces and trigger tile transformations - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/spell-integration.html" data-href="../physics/spell-integration" aria-label="../physics/spell-integration" data-tooltip-position="top" target="_self">Spell Integration</a>.Core Engine: Manages spell layer texture for GPU processing.UI System: Displays casting slots/pools, mana flower availability, targeting overlay, and deck builder interface.Documented:
Element system (26 elements, cancellation rules)
Mana system (6 flowers, recharge, conversion)
Casting interface (slot/pool, actions, cooldown)
Rune lifecycle (placement, delay, trigger, combination)
Deck building rules (minimum size, singleton, reshuffle)
Needs Design:
Specific spell shape primitives
Void rune effects
Single element rune additional effects
Curse system mechanics
Spell acquisition/progression system
Line of sight obstruction rules
Number of casting slots/pools
<br>Entry Point: Start with <a data-tooltip-position="top" aria-label="element-system" data-href="element-system" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">Element System</a> to understand the foundational magic structure.]]></description><link>architecture/systems/spells/spells.html</link><guid isPermaLink="false">architecture/systems/spells/spells.md</guid><pubDate>Wed, 12 Nov 2025 05:26:24 GMT</pubDate></item><item><title><![CDATA[spells-and-runes]]></title><description><![CDATA[Slot/pool casting interface with GPU-accelerated spell shapes, element combinations, and rune lifecycle management.Structure: N casting slots + N casting pools (using 4 as example, final count TBD)Starting State: All slots empty, all pools filled with random spells from deck1. Cast Spell (from filled slot):
Consumes required mana flowers (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a>)
Triggers directional targeting mode
Slot becomes empty after cast
Pools unchanged
2. Load Spell (pool → empty slot):
Player selects spell from any pool
Chosen spell moves to clicked slot
<br>All pools refill sequentially from deck (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/deck-building.html" data-href="deck-building" aria-label="deck-building" data-tooltip-position="top" target="_self">Deck Building</a>)
No mana cost
3. Refresh Pools:
Manually replace all pool spells with new draws from deck
Triggers action cooldown
Flowers do NOT recharge during refresh cooldown (unique penalty)
Universal Cooldown: Single shared cooldown applies to all three actionsMovement: Not affected by action cooldownHold-to-Cast Queueing: Hold mouse on filled slot during cooldown to queue cast for immediate execution when readyActivation: After clicking cast, enter targeting modeInput: Player clicks direction and distance from avatarPlacement: Spell shape centered on clicked locationRange Limits: Each spell has maximum range from casterObstruction: ⚠️ NEEDS DESIGN - Line of sight checks TBDDesign: Abstract geometric primitives (circles, rectangles, lines, etc.) evaluated at runtimeNot Textures: Mathematical definitions, not pre-rendered imagesEvaluation: GPU compute shaders evaluate shape membership per-pixelPrimitives: ⚠️ NEEDS SPECIFICATION - Specific primitive set TBD through spell design processShape Components:
Position (relative to spell center)
Rotation and scale
<br>Element type (from cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>)
Force vector
Delay value Placement: Spell casting writes runes to rune layer via GPU
Delay Countdown: GPU shader decrements delay counter each frame
Trigger + Removal: Simultaneous - apply effects and remove rune when delay reaches zero
Combination: Multiple runes on same pixel combine before triggering
<br>Element Type: One of 26 elements (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>)<br>Force Vector: Applied to physics layer when triggered (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/spell-integration.html" data-href="physics/spell-integration" aria-label="physics/spell-integration" data-tooltip-position="top" target="_self">Spell Integration</a>)Delay Counter: Frame-based countdownStorage: Per-pixel on dedicated rune layer textureNote: ⚠️ Runes are being replaced by spell shapes - this document needs updating to reflect current architecture.Timing: Runes combine when multiple exist on same pixel<br>Element Rules: Uses element system cancellation rules (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>)Force Combination: Vector addition of all force componentsDelay Resolution: Combined rune uses minimum delay of componentsTrigger Timing: Combined rune triggers when shortest delay expiresDelay System: 16-bit looping time counter, runes store target trigger timeShape Evaluation: Compute shaders evaluate abstract primitives per-pixel during spell placementElement Combination: Shader-based component-level cancellation during rune combinationCleanup: Separate shader pass removes triggered runesDeterminism: Fixed-point precision, order-independent combination results]]></description><link>architecture/systems/spells/spells-and-runes.html</link><guid isPermaLink="false">architecture/systems/spells/spells-and-runes.md</guid><pubDate>Wed, 12 Nov 2025 05:26:08 GMT</pubDate></item><item><title><![CDATA[element-system]]></title><description><![CDATA[26 elements organized in cube/octahedron geometric structure where opposing elements are geometrically opposite and cancel when combined.Geometric Foundation: Elements map onto cube/octahedron vertices (6), edges (12), and faces (8).Opposition Principle: Geometric opposites are element opposites. Opposite elements cancel when combined.Total: 26 elements (6 base + 12 dual + 8 triple)Fundamental forces forming three opposing pairs:
Order ↔ Chaos
Creation ↔ Destruction
Spirit ↔ Form
Usage: Base elements used as mana costs, rarely appear as standalone spell elements.Combinations of two base elements, forming primary spell types:Usage: Most spells use dual elements. Core gameplay.Combinations of three base elements, forming rare specialized magic:Usage: Created by rare spells or combination mechanics. Will dramatically change terrain and biome.Component-Level: Elements cancel at base element level according to three opposition pairs.Complete Cancellation: When all components cancel, no rune is created.
Example: Fire (Chaos+Creation) + Frost (Order+Destruction) = nothing
Partial Cancellation: When some but not all components cancel, remaining elements determine result.
Example: Fire (Chaos+Creation) + Water (Order+Creation) = Creation (single element rune)
Order Independence: Combination result is deterministic regardless of evaluation order.Creation: Partial cancellation between dual elements with one shared component.Effect: Recharge player's mana flowers when triggered.Additional Effects: ⚠️ TBDCreation: Triple element rune + opposite triple element rune on same location.Example: Life (Order+Creation+Spirit) + Death (Chaos+Destruction+Form) = VoidDiscovery: Not explained in tutorials. Players discover through experimentation.Effects: ⚠️ NEEDS DESIGN - Powerful secret mechanic, details TBD.<a data-tooltip-position="top" aria-label="element-effects" data-href="element-effects" href="architecture/systems/spells/element-effects.html" class="internal-link" target="_self" rel="noopener nofollow">Element Effects</a> - What each element does (forces, transformations, passive effects)<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a> - Flower types match base elements, spell costs require specific combinations<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells-and-runes.html" data-href="spells-and-runes" aria-label="spells-and-runes" data-tooltip-position="top" target="_self">Spells and Runes</a> - Element combinations computed in GPU shaders during rune placementAvailability: All 26 elements accessible from game start. No progression gate on element types.]]></description><link>architecture/systems/spells/element-system.html</link><guid isPermaLink="false">architecture/systems/spells/element-system.md</guid><pubDate>Wed, 12 Nov 2025 05:25:47 GMT</pubDate></item><item><title><![CDATA[element-effects]]></title><description><![CDATA[Catalog of all 26 spell elements and their effects on physics and tiles.Each element determines how a spell affects the game world. Elements are organized in a geometric structure (core, single-axis, double-axis, triple-axis) and combine through cancellation rules.See <a data-tooltip-position="top" aria-label="element-system" data-href="element-system" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">Element System</a> for structure and cancellation mechanics.Properties: No directional component, neutral/null element.Force Effects: ⚠️ TBD through spell system design.Transformation Effects: ⚠️ TBD through spell system design.Properties: Pure directional elements along three axes (hot/cold, kinetic/static, light/dark).Force Effects: ⚠️ TBD - May provide basic force application.Transformation Effects: ⚠️ TBD - Single-element transformation capabilities.Properties: Combination of two axis components (e.g., hot+kinetic, cold+light).Primary Duty: Most double-element spells provide BOTH force application AND tile transformations.Force Types: ⚠️ NEEDS SPECIFICATION - Impulse vs velocity-set per element.Transformation Effects: ⚠️ NEEDS SPECIFICATION - Tile type changes triggered by spell.Properties: Combination of all three axis components.Primary Duty: Passive modifications to physics behavior.⚠️ TODO: Triple-element spells will provide passive modifications to reactions and forces for their duration.Design Intent: Global or area-of-effect modifiers to game rules while spell is active.Examples (speculative): Modify force strengths, alter reaction rates, change timer behaviors.Properties: Absence of all axes, neutral element.Special Role: ⚠️ TBD - May have unique mechanics or serve as cancellation result.Method: Add velocity delta to current object velocity.Application: Δv applied once when spell contacts object.Use Cases: Push, pull, explosion effects.Elements: ⚠️ NEEDS SPECIFICATION - Which elements use impulse method?Method: Directly replace object velocity with spell-specified value.Application: Overrides current velocity entirely.Use Cases: Wind, flow, directional movement effects.Elements: ⚠️ NEEDS SPECIFICATION - Which elements use velocity-set method?⚠️ NEEDS DISCUSSION: Do spell forces ignore mass (magical effects) or respect mass (physical forces)?Impact: Determines if heavy objects respond same as light objects to spells.Trigger: When double-element spell activates on a tile.Process: Tile type changes based on spell elements and current tile type.Rule Source: Transformation rules defined per element combination.⚠️ NEEDS SPECIFICATION: Complete mapping of element combinations to tile transformations.Examples (speculative):
Fire element: Transform wood → burning wood → ash
Ice element: Transform water → ice
Earth element: Create/modify terrain
Coordination: Spell transformations may interact with reaction system environmental effects.Rule Separation: Spell-triggered transformations separate from physics-driven reactions.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/spell-integration.html" data-href="physics/spell-integration" aria-label="physics/spell-integration" data-tooltip-position="top" target="_self">Spell Integration</a> and cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="physics/reactions" aria-label="physics/reactions" data-tooltip-position="top" target="_self">Reactions</a>.⚠️ TODO: Design passive modification system for triple-element spells.Duration: Modifications active while spell is present.Scope: May affect global rules or localized area.Potential Effects:
Modify force strengths (amplify/dampen collision, cohesion, spell forces)
Alter reaction rates (speed up/slow down environmental reactions)
Change timer behaviors (faster burning, slower freezing, etc.)
Modify mass response (objects lighter/heavier under effect)
⚠️ NEEDS COMPLETION: Catalog all 26 elements with specific effects.The 26 elements are organized as:
1 Core (null)
6 Single-axis (hot, cold, kinetic, static, light, dark)
12 Double-axis (all pairwise combinations of opposite axes)
6 Triple-axis (hot/cold + kinetic/static + light/dark combinations)
1 Null (three cancellations)
<br>See <a data-tooltip-position="top" aria-label="element-system" data-href="element-system" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">Element System</a> for complete structure and cancellation rules.Goal: Each element should feel unique and have clear gameplay identity.Balance: Elements should be roughly balanced in power/utility.Synergy: Element combinations should create interesting strategic choices.Tuning: Force strengths will require gameplay testing and iteration.Configuration: Expose force values as tunable parameters.Variation: Different elements may have different force strengths for balance.Clarity: Players should understand what each element does to tiles.Consistency: Similar elements should have thematically consistent effects.Balance: Transformation effects balanced against force effects for double-elements.<br><a data-tooltip-position="top" aria-label="element-system" data-href="element-system" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">Element System</a> - Structure and cancellation rules<br><a data-tooltip-position="top" aria-label="spells-and-runes" data-href="spells-and-runes" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">Spells and Runes</a> - How elements are cast and combined<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/spell-integration.html" data-href="physics/spell-integration" aria-label="physics/spell-integration" data-tooltip-position="top" target="_self">Spell Integration</a> - How elements affect physics layer<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="physics/reactions" aria-label="physics/reactions" data-tooltip-position="top" target="_self">Reactions</a> - Interaction with reaction systemCurrent State: Structure defined, specific effects TBD through design process.Next Steps:
Define force type (impulse/velocity-set) for each element
Specify force magnitudes for gameplay testing
Design tile transformation rules for double-elements
Design passive modification system for triple-elements
Iterate through playtesting and balance
]]></description><link>architecture/systems/spells/element-effects.html</link><guid isPermaLink="false">architecture/systems/spells/element-effects.md</guid><pubDate>Wed, 12 Nov 2025 05:25:31 GMT</pubDate></item><item><title><![CDATA[reactions]]></title><description><![CDATA[Type transformations triggered by object merging, environmental neighbor patterns, and timers.The reaction system determines how objects transform when they interact. Primarily handles environmental reactions (neighbor-based patterns) but also provides type transformations during object merging. Reactions are tightly integrated with physics, running every physics frame within the same GPU passes.Note: Spell-triggered transformations are handled separately - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/spell-integration.html" data-href="spell-integration" aria-label="spell-integration" data-tooltip-position="top" target="_self">Spell Integration</a>.<br>When: Objects merge during physics overlap passes when distance &lt; d (see <a data-tooltip-position="top" aria-label="object-merging" data-href="object-merging" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">Object Merging</a>).Lookup: Hashmap mapping object type pairs to new types: (type_a, type_b) -&gt; new_typeMultiple Objects: When 3+ objects merge, only pairs are considered (see todo for preventing triple merges).Timer Reset: All transformations reset the object's timer.Source: Object merging (physics-driven), NOT spell-triggered transformations.When: Every physics frame during "Apply Forces + Move" pass.Gather-Based: Each object checks its two-layer hex neighborhood for nearby types.Lookup: Search tree structure maps neighborhood patterns to reactions.Range: Uses same two-layer hex range (sqrt(7)d/2 - d) as force calculations.Example: Wood object detects nearby fire → increases heat timer.When: Timer value reaches threshold for transformation.Exclusive Timers: Each object has one active timer (saves memory).Timer Types: Burning, freezing, electrified, etc. (exact types TBD).Timer Modifications: Environmental reactions can increase/decrease/reset timer values or swap timer types.Transformations: When timer reaches threshold, object type transforms based on timer type.<br>Timer Type: Limited set of timer types (bit count TBD - see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/shader-data-layout.html" data-href="shader-data-layout" aria-label="shader-data-layout" data-tooltip-position="top" target="_self">Shader Data Layout</a>).Timer Value: Count-up timer (bit count TBD).Exclusive: Only one active timer per object to minimize storage.Reset on Transformation: All type transformations reset timer to zero.Increase/Decrease: Environmental reactions modify timer value.Type Swap: Reactions can change which timer type is active.Threshold Check: When timer value exceeds threshold, transformation triggers.Examples:
Wood near fire → heat timer increases → at threshold, wood transforms to fire
Water near fire → fire timer decreases → at threshold, fire extinguishes
Gather Pattern: Each object examines its two-layer hex neighborhood.Search Tree Lookup: Neighbor configuration maps to reaction data via search tree.Reaction Data: Includes timer modifications, type swaps, and transformation rules.Combined Effects: Neighbor combinations may have distinct reactions (not independent).Current State: Object considers its current timer type and value.Neighbor Pattern: Looks up reaction based on nearby object types.Modifications:
Swap timer type
Set timer value
Increase/decrease timer value
Immediate type transformation (if applicable)
Example: Wood object with heat timer near fire → heat timer increases by X per frame.⚠️ TODO: Design how reactions can create objects on different layers.Constraint: Maintain one-object-per-cell guarantee within each layer.Possibility: Object on one layer creates object on different layer in same or neighboring cell.Use Case: Fire (air layer) creating ash (ground layer), explosions creating debris, etc.Key: Ordered or unordered pair of object types (type_a, type_b).Value: New object type after merging.Properties: New object inherits mass from type, velocity from mass-weighted average.Element Handling: If types have elements, use element combination rules.Apply Forces + Move: Environmental reactions happen during force application.Overlap Passes: Merge reactions happen during object merging.Set Grid Position: Reactions complete before grid position updates.Frequency: Reactions run every physics frame (60fps).<br>See <a data-tooltip-position="top" aria-label="passes" data-href="passes" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">Pipeline Passes</a> for multi-pass coordination.Shared Neighborhood: Use same two-layer hex data loaded for forces.Combined Shaders: Environmental reactions integrated into force application shader.Memory Efficiency: Reuse neighborhood cache for both forces and reactions.Basic: Object type changes (e.g., wood → fire).Properties Updated: Mass and other properties update based on new type.Timer Reset: Timer returns to zero on transformation.Removal: Object not output to next pass, removed from simulation.Use Case: Fire extinguished by water, objects consumed by reactions.⚠️ TODO: Cross-layer creation design needed.Constraint: Respect one-per-cell within each layer.Examples: Fire creating smoke, explosions creating particles.]]></description><link>architecture/systems/physics/reactions.html</link><guid isPermaLink="false">architecture/systems/physics/reactions.md</guid><pubDate>Wed, 12 Nov 2025 05:24:27 GMT</pubDate></item><item><title><![CDATA[movement]]></title><description><![CDATA[Hexagonal grid with sub-grid positioning, velocity management, and mass-based interactions.Objects move freely on a hexagonal grid using sub-grid offsets and persistent velocities. Movement is driven by forces (collision, cohesion, spells) that modify velocity each frame, with mass determining acceleration response.Hex Cell Size: Corner-to-corner distance d chosen to equal the minimum object merging distance.One-Per-Cell Guarantee: Cell size ensures no two objects can occupy the same cell.Polar Coordinates: Grid uses polar/cube coordinate system for neighbor lookup and point-to-hex conversion.GPU Storage: Grid stored as skewed parallelogram with wrapped boundaries, enabling rectangular indexing.World Wrapping: Objects at world edges wrap to opposite side for continuous circular world.Offset Storage: Each object stores precise x,y offsets from its hex cell center using fixed-point arithmetic.Unconstrained Movement: Objects can move freely in any direction based on applied forces.Precision: Fixed-point representation ensures deterministic positioning across platforms.Cell Assignment: Objects remain assigned to their current hex cell until the final "set grid position" pass.See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/determinism.html" data-href="general/determinism" aria-label="general/determinism" data-tooltip-position="top" target="_self">Determinism</a> for fixed-point arithmetic implementation.Vector Representation: Two-component velocity (x,y) stored with fixed-point precision.Texture Storage: Velocities stored in GPU textures alongside position data.Deterministic Updates: All velocity changes use fixed-point arithmetic for cross-platform consistency.Frame Persistence: Velocity persists frame-to-frame unless modified by forces.Applied Forces: Collision, cohesion, and spell forces modify velocity each frame.
<br>See <a data-tooltip-position="top" aria-label="cohesion" data-href="cohesion" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">Cohesion</a> for gap-closing attraction
<br>See <a data-tooltip-position="top" aria-label="collision" data-href="collision" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">Collision</a> for overlap repulsion
<br>See <a data-tooltip-position="top" aria-label="spell-integration" data-href="spell-integration" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">Spell Integration</a> for spell-driven forces
Mass Response: Velocity change determined by F=ma (acceleration inversely proportional to mass).Object Merging: Merged objects receive mass-weighted average velocity.Damping: ⚠️ TBD - Optional velocity damping to prevent perpetual motion (needs playtesting).Maximum Velocity: ~9.69 hex cells/second at 60fps based on two-layer force range guarantee.Gameplay Range: Typical gameplay velocities 2-6 cells/second, providing margin for force application.Range Guarantee: Two hex layers sufficient for all force interactions within speed limits.Type-Based: Each object type has an associated mass value.Layer Variation: Different layers may have different mass ranges (e.g., ground heavier than air).Gameplay Impact: Mass affects force response and merging outcomes.⚠️ NEEDS SPECIFICATION: Specific mass values for object types TBD through gameplay balancing.Force Response: Heavier objects accelerate less from the same applied force (a = F/m).Collision Interaction: Mass ratio between colliding objects affects their relative acceleration responses.Momentum Conservation: When objects merge, velocities are mass-averaged to conserve total momentum:m1*v1 + m2*v2 + ... = m_combined * v_combined
<br>See <a data-tooltip-position="top" aria-label="object-merging" data-href="object-merging" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">Object Merging</a> for combination mechanics.Position:
Hex cell coordinates (using polar/cube system)
Fixed-point offset (x,y) from cell center
Velocity:
Fixed-point vector (x,y)
Stored in GPU texture alongside position
Properties:
Object type ID (for mass lookup and reactions)
Mass value (may be stored or computed from type)
Layer assignment (Ground/Object/Air)
Texture Layout: Data packed efficiently for GPU texture storage and access patterns.Force Application Pass: Velocity updated by accumulated forces in "Apply Forces + Move" pass.Position Update: Sub-grid offset updated by velocity in same pass.Cell Assignment: Final hex cell determined in "Set Grid Position" pass.<br>See <a data-tooltip-position="top" aria-label="passes" data-href="passes" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">Pipeline Passes</a> for multi-pass execution coordination.Arithmetic: All position and velocity calculations use 16.16 fixed-point format.Overflow Prevention: Calculations designed to prevent overflow in extreme cases.Determinism: Integer-only operations ensure identical results across platforms.Forces modify velocity each frame:
<br><a data-tooltip-position="top" aria-label="cohesion" data-href="cohesion" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">Cohesion</a> - Gap-closing attraction
<br><a data-tooltip-position="top" aria-label="collision" data-href="collision" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">Collision</a> - Overlap repulsion
<br><a data-tooltip-position="top" aria-label="spell-integration" data-href="spell-integration" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">Spell Integration</a> - Spell-driven forces
<br><a data-tooltip-position="top" aria-label="object-merging" data-href="object-merging" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">Object Merging</a> - Mass-weighted velocity averaging when objects combine<br><a data-tooltip-position="top" aria-label="reactions" data-href="reactions" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">Reactions</a> - Type transformations affect mass assignment
Sub-grid offsets provide precise visual positioning
Velocities available for motion blur and particle effects Ground Layer: Terrain foundation (dirt, stone, water)
Object Layer: Interactive entities (rocks, trees, creatures, players)
Air Layer: Gases and effects (fire, smoke, magic)
Each layer maintains independent position and velocity data but shares the same movement mechanics.]]></description><link>architecture/systems/physics/movement.html</link><guid isPermaLink="false">architecture/systems/physics/movement.md</guid><pubDate>Wed, 12 Nov 2025 05:24:00 GMT</pubDate></item><item><title><![CDATA[spell-integration]]></title><description><![CDATA[How spells affect the physics layer through force application and tile transformations.Spells interact with physics in two primary ways:
Force Application - Spell shapes apply forces to objects, modifying their velocities
Tile Transformations - Spells trigger tile type changes (double-element duty)
Shape Definition: Spells define geometric shapes (circles, rectangles, etc.) that cover regions of the game world.Force Vectors: Each spell shape stores a force vector to be applied to overlapping objects.Trigger Timing: Forces applied when spell triggers (after delay countdown).Overlap Detection: Objects check if their center point overlaps any active spell shapes.Impulse Elements: Apply instantaneous velocity changes (add to current velocity).Velocity-Set Elements: Directly replace object velocity with spell-specified value.Element Determination: Spell element type determines which force application method is used.⚠️ NEEDS SPECIFICATION: Mapping of spell elements to force types TBD through spell system design.See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-effects.html" data-href="spells/element-effects" aria-label="spells/element-effects" data-tooltip-position="top" target="_self">Element Effects</a> for which elements create which force types.Overlapping Spells: Objects can be affected by multiple spell shapes simultaneously.Element Combination: When multiple spells overlap, combine elements using cancellation rules.Cast Time Ordering: Process spells in cast time order for deterministic element combination.Force Combination: After element combination, resulting force applied to object.Primary Duty: Most double-element spells trigger tile type transformations in addition to applying forces.Transformation Trigger: When spell activates on a tile, triggers type transformation rules.Physics Integration: Transformations occur during physics pipeline execution.
Spell Triggers: Double-element spell activates on specific tiles
Type Lookup: Determine target tile type and spell element combination
Rule Application: Apply transformation rules based on spell elements
Tile Update: Update tile type in physics layer
⚠️ TODO: Triple-element spells will provide passive modifications to reactions and forces for their duration.Design Intent: Global or area-of-effect modifications to physics behavior while spell is active.Implementation: TBD through spell system design.Spell Buffer Lookup: Objects check spell buffer for overlapping spell shapes during force accumulation.Force Calculation: Calculate spell force based on element type and spell properties.Vector Addition: Add spell forces to collision and cohesion forces for net force.Mass Consideration: ⚠️ TBD - Determine if spell forces ignore mass or use standard F=ma.Force Application Pass: Spell forces calculated in "Apply Forces + Move" GPU pass.Transformation Pass: Tile transformations may occur in separate pass or integrated with forces.Coordination: Ensure spell effects and physics forces execute in deterministic order.<br>See <a data-tooltip-position="top" aria-label="passes" data-href="passes" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">Pipeline Passes</a> for multi-pass execution coordination.Spell Data (per active spell):
Shape geometry (circle, rectangle, polygon, etc.)
Position and dimensions
Element type(s) after cancellation
Cast time (for ordering)
Force magnitude and direction
Trigger status
Spatial Partitioning: ⚠️ Future optimization - Partition spells spatially to limit checks per object.Per-Object Lookup: Each object queries spell buffer for overlapping shapes.Overlap Test: Geometric test determines if object center is within spell shape.Parallel Access: All objects can read spell buffer simultaneously (read-only access).Determinism: All force calculations and transformations use fixed-point arithmetic.Precision: Force vectors use 16.16 fixed-point format matching physics calculations.Cross-Platform: Ensures identical spell effects across all hardware.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/determinism.html" data-href="general/determinism" aria-label="general/determinism" data-tooltip-position="top" target="_self">Determinism</a> for fixed-point implementation details.⚠️ NEEDS SPECIFICATION: Complete mapping of spell elements to force behaviors.Expected Categories:
Impulse Elements: Push, pull, explosion effects (add to velocity)
Velocity-Set Elements: Wind, flow, directional movement (set velocity)
Transformation Elements: Tile type changes (double-element duty)
Modifier Elements: Physics behavior modifications (triple-element effects)
Design Source: Element effects defined in spell system documentation.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-effects.html" data-href="spells/element-effects" aria-label="spells/element-effects" data-tooltip-position="top" target="_self">Element Effects</a> for complete element catalog.Shape Evaluation: Spells define shapes that physics checks for overlap.Element System: Element types determine force application method.Trigger Lifecycle: Spell timing determines when forces are applied.Cross-references:
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells/spells" aria-label="spells/spells" data-tooltip-position="top" target="_self">Spell System</a> - Overall spell mechanics
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-effects.html" data-href="spells/element-effects" aria-label="spells/element-effects" data-tooltip-position="top" target="_self">Element Effects</a> - What each element does
Forces: Spell forces accumulate with collision and cohesion forces.Movement: Spell forces modify object velocities like any other force.Reactions: Spell transformations may interact with reaction system.Internal references:
<br><a data-tooltip-position="top" aria-label="passes" data-href="passes" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">Pipeline Passes</a> - GPU execution integration
<br><a data-tooltip-position="top" aria-label="cohesion" data-href="cohesion" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">Cohesion</a> and <a data-tooltip-position="top" aria-label="collision" data-href="collision" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">Collision</a> - Other force sources
<br><a data-tooltip-position="top" aria-label="movement" data-href="movement" href="architecture/systems/physics/movement.html" class="internal-link" target="_self" rel="noopener nofollow">Movement</a> - Velocity and position updates
<br><a data-tooltip-position="top" aria-label="reactions" data-href="reactions" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">Reactions</a> - Environmental transformations
Buffer Size: Number of active spells affects lookup performance.Overlap Tests: Geometric tests must be efficient (many objects checking many spells).Spatial Optimization: Future partitioning can reduce checks per object.GPU Parallelism: Spell force calculations fully parallelizable across objects.Force Balance: Spell forces should be noticeable over ambient physics forces.Element Diversity: Different elements should feel distinct through force behaviors.Gameplay Clarity: Players should understand how spell elements affect physics.Tuning Flexibility: Force magnitudes and behaviors exposed as configuration values.]]></description><link>architecture/systems/physics/spell-integration.html</link><guid isPermaLink="false">architecture/systems/physics/spell-integration.md</guid><pubDate>Wed, 12 Nov 2025 05:23:22 GMT</pubDate></item><item><title><![CDATA[passes]]></title><description><![CDATA[Multi-pass GPU compute pipeline for processing physics interactions in deterministic order.The physics system uses a sequence of GPU compute passes executed each frame:
Apply Forces + Move - Calculate forces, update velocities and sub-grid offsets
Overlap Passes (2-N) - Detect and merge objects that are too close
Set Grid Position - Update hex cell assignments based on final offsets
Force Accumulation: Calculate and apply all forces (collision, cohesion, spell) to objects.Velocity Update: Modify object velocities based on net force and mass.Sub-Grid Movement: Update sub-grid offsets without changing hex cell assignment yet.Grid Preservation: Objects remain in current hex cells until final pass.
Load two-layer hex neighborhood into workgroup shared memory
Calculate collision forces from overlapping neighbors
Calculate cohesion forces from nearby neighbors
Calculate spell forces from overlapping spell shapes
Sum all forces using vector addition
Update velocity: v_new = v_old + (F_total / mass)
Clamp velocity to maximum speed
Update sub-grid offset: offset_new = offset_old + v_new
Write updated object to output texture
Forces: <a data-tooltip-position="top" aria-label="cohesion" data-href="cohesion" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">Cohesion</a>, <a data-tooltip-position="top" aria-label="collision" data-href="collision" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">Collision</a>, <a data-tooltip-position="top" aria-label="spell-integration" data-href="spell-integration" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">Spell Forces</a><br>Movement: <a data-tooltip-position="top" aria-label="movement" data-href="movement" href="architecture/systems/physics/movement.html" class="internal-link" target="_self" rel="noopener nofollow">Movement System</a> for velocity and offset detailsObject Merging: Detect objects closer than combination distance d and merge them.Multi-Object Groups: Handle groups of 3+ objects that should all merge together.Cascading Merges: Resolve combinations that create new combinations.Multiple Passes: May require 2-N passes to fully resolve all combinations.Convergence Detection: Terminate when no combinations triggered in previous pass.Pass Skipping: Early exit if no merging activity detected.
Detect objects with distance &lt; d
Identify merge groups using scatter-gather algorithm
Calculate mass-weighted centroid and velocity
Apply reaction rules for type transformation
Create merged object, remove component objects
Check for convergence (no more merges needed)
<br>Merging: <a data-tooltip-position="top" aria-label="object-merging" data-href="object-merging" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">Object Merging</a> for combination mechanics<br>Transformations: <a data-tooltip-position="top" aria-label="reactions" data-href="reactions" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">Reactions</a> for type changes during mergesHex Cell Assignment: Update which hex cell each object occupies based on final offset.Boundary Wrapping: Handle world edge wrapping for continuous world.Final Position: Establish object positions for next frame and rendering.
Read final sub-grid offset from previous pass
Determine if offset exceeds hex cell boundary
Calculate new hex cell coordinates if needed
Adjust offset relative to new cell center
Write final position to output texture
Dual Textures: Each layer has two textures (read and write).Simultaneous Access: All objects read from one texture, write to the other.Determinism: Prevents read-after-write hazards and ensures consistent ordering.Swap: Textures swap roles between passes (output becomes input for next pass).<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/determinism.html" data-href="general/determinism" aria-label="general/determinism" data-tooltip-position="top" target="_self">Determinism</a> for deterministic execution approach.Frame Budget: 16.67ms total frame time.Physics Allocation: Physics should complete in &lt;12ms to leave time for rendering.Pass Budget: Each pass optimized to execute efficiently within time constraints.⚠️ NEEDS DISCUSSION: Timing coordination between physics, reactions, and rendering systems.Sequential Execution: Passes execute in strict order (no overlap between passes).Synchronization: GPU barriers ensure pass completion before next begins.Shared Memory Caching: Load hex neighborhoods once per workgroup to minimize texture reads.Workgroup Size: 8×8 threads (64 total) balances occupancy and shared memory usage.⚠️ NEEDS TUNING: Optimal workgroup size TBD through GPU profiling.Stationary Objects: Skip force calculations for objects with zero velocity and no nearby activity.Convergence: Terminate overlap passes when no more merges detected.Empty Cells: Skip processing for hex cells with no objects.Coalesced Access: Structure memory access patterns for optimal GPU cache utilization.Texture Formats: Use efficient r32uint formats for object data storage.Bit-Packing: Compress object properties to minimize memory bandwidth.Implementation Details: See GPU system documentation for:
Buffer layouts and texture formats
Workgroup configuration
Memory access patterns
Shader structure templates
Note: Physics documents describe the logic and algorithms; GPU documents describe the technical implementation.<br><a data-tooltip-position="top" aria-label="movement" data-href="movement" href="architecture/systems/physics/movement.html" class="internal-link" target="_self" rel="noopener nofollow">Movement</a> - Velocity, mass, and positioning mechanics<br><a data-tooltip-position="top" aria-label="cohesion" data-href="cohesion" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">Cohesion</a> - Gap-closing attraction forces<br><a data-tooltip-position="top" aria-label="collision" data-href="collision" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">Collision</a> - Overlap repulsion forces<br><a data-tooltip-position="top" aria-label="spell-integration" data-href="spell-integration" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">Spell Integration</a> - Spell-driven forces and transformations<br><a data-tooltip-position="top" aria-label="object-merging" data-href="object-merging" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">Object Merging</a> - Combination mechanics and multi-pass resolution<br><a data-tooltip-position="top" aria-label="reactions" data-href="reactions" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">Reactions</a> - Type transformations during merges and environmental interactions]]></description><link>architecture/systems/physics/passes.html</link><guid isPermaLink="false">architecture/systems/physics/passes.md</guid><pubDate>Wed, 12 Nov 2025 05:22:42 GMT</pubDate></item><item><title><![CDATA[object-merging]]></title><description><![CDATA[Mechanic for combining nearby objects into single unified objects, maintaining one-per-cell guarantee and enabling dynamic reactions.One-Per-Cell Guarantee: Ensures no hex cell ever contains more than one object.Gameplay Feature: Creates dynamic object fusion and reaction chains through spatial proximity.Physics Stability: Prevents infinite force application from perpetually overlapping objects.Combination Distance d: Merging triggered when two objects approach closer than distance d.⚠️ NEEDS SPECIFICATION: Exact value of d TBD through gameplay testing.Relationship to Forces: Distance d marks transition from force-based separation to merge-based combination.Inclusive Radius: All objects with centers within distance d of the combined center are included in the merge.Multi-Object Merges: Single combination event can merge 3+ objects if they're all within radius.Cascading Merges: May require multiple passes to resolve chain reactions of combinations.Overlap Detection: GPU pass identifies objects closer than distance d.Scatter-Gather Algorithm: Complex algorithm to identify groups of nearby objects that should merge together.⚠️ NEEDS SPECIFICATION: Exact scatter-gather implementation approach TBD.Position: Combined object placed at mass-weighted centroid of merged objects.Velocity: Combined velocity is mass-weighted average of all merged objects.Momentum Conservation: Total momentum preserved during combination:m1*v1 + m2*v2 + ... = m_combined * v_combined
Reaction Rules: New object type determined by reaction rules applied to merged object types.Type Lookup: Reaction system provides type transformation based on merging object types.Mass Assignment: New object mass based on its transformed type.See <a data-tooltip-position="top" aria-label="reactions" data-href="reactions" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">Reactions</a> for type transformation rules.Multiple Passes: May require 2-N overlap passes to fully resolve cascading combinations.Convergence Detection: Terminate when no more objects need merging.Pass Skipping: Early termination if no combinations triggered in previous pass.<br>See <a data-tooltip-position="top" aria-label="passes" data-href="passes" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">Pipeline Passes</a> for multi-pass coordination.Determinism: All position and velocity calculations use fixed-point arithmetic.Precision: Mass-weighted averaging maintains fixed-point format throughout.Overflow Prevention: Weighted calculations designed to prevent overflow in extreme cases.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/determinism.html" data-href="general/determinism" aria-label="general/determinism" data-tooltip-position="top" target="_self">Determinism</a> for fixed-point implementation details.Challenge: Identifying all objects in merge group requires coordination across GPU threads.Atomic Operations: May use atomic operations to flag objects for combination.Multiple Passes: Iterative approach resolves combinations step by step.Input: Object positions and velocities from previous pass.Processing: Detect nearby objects, calculate merged properties, apply transformations.Output: Updated object layout with merged objects replacing separate objects.Transition Point: At distance &gt; d, collision forces apply; at distance &lt; d, merging takes over.Smooth Handoff: No force application during merge (combination replaces force-based separation).<br>See <a data-tooltip-position="top" aria-label="collision" data-href="collision" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">Collision</a> for repulsion force mechanics.Type Transformation: Merging triggers reaction rules to determine new object type.Environmental Context: Reactions may consider environmental factors in transformation.<br>See <a data-tooltip-position="top" aria-label="reactions" data-href="reactions" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">Reactions</a> for transformation rules and environmental interactions.Convergence Speed: Most combinations should resolve in 2-3 passes.Early Termination: Stop iteration when no combinations detected.Workgroup Coordination: Efficient GPU implementation critical for performance with many objects.Threshold Tuning: Distance d must balance gameplay feel with physics stability.Mass Conservation: Consider whether mass should be conserved or type-determined in merges.Gameplay Impact: Merging creates strategic depth through spatial positioning and object manipulation.]]></description><link>architecture/systems/physics/object-merging.html</link><guid isPermaLink="false">architecture/systems/physics/object-merging.md</guid><pubDate>Wed, 12 Nov 2025 05:22:05 GMT</pubDate></item><item><title><![CDATA[collision]]></title><description><![CDATA[Repulsion force that pushes overlapping objects apart to prevent interpenetration.Overlap Resolution: Push objects apart when they overlap to prevent interpenetration.Continuous Application: Forces applied every frame while objects remain overlapping.Mass-Based Response: Force produces different accelerations based on object mass.Repulsion: Objects push apart when overlapping, with force directed away from collision point.Overlap-Based Magnitude: Force magnitude increases with overlap amount (closer = stronger repulsion).Mass Influence: Force applied to both objects, with acceleration inversely proportional to mass (F = ma).Breaking Threshold: When objects get very close (distance &lt; d), combination mechanic triggers instead of force application.Range: Operates within two-layer hexagonal neighborhood (sqrt(7)d/2 - d maximum distance).⚠️ NEEDS SPECIFICATION: Exact collision force formula TBD through playtesting.Considerations:
Linear vs non-linear force scaling with overlap distance
Force strength calibration for gameplay feel
Balance between collision response and combination trigger
Interaction with cohesion forces
Expected Behavior:
Stronger when objects are closer (higher overlap)
Strong enough to prevent excessive interpenetration
Balanced with cohesion to avoid vibration or instability
Triggers combination when distance falls below threshold d Overlap Detection: Check two-layer hex neighborhood for overlapping objects
Distance Measurement: Calculate distance between object centers (using sub-grid offsets)
Overlap Amount: Determine how much objects overlap (negative distance or proximity measure)
Force Magnitude: Calculate repulsion force based on overlap amount
Direction: Force vector points away from other object's center
Accumulation: Add to total force for frame
Pairwise Forces: Calculate collision force for each overlapping neighbor independently.Vector Addition: All collision forces summed together for net repulsion.Symmetric Application: Each object in collision pair experiences force (Newton's third law).Acceleration: a = F/m determines how much each object moves in response to collision.Momentum Transfer: Lighter objects accelerate more than heavier objects from same force.Realistic Response: Mass-based physics creates intuitive collision behavior.See <a data-tooltip-position="top" aria-label="movement" data-href="movement" href="architecture/systems/physics/movement.html" class="internal-link" target="_self" rel="noopener nofollow">Movement System</a> for mass properties and velocity updates.Distance Threshold: When objects closer than combination distance d, merging takes over.Force Cutoff: Collision forces stop applying at very close range (handled by combination instead).Transition: Smooth transition from force-based separation to combination-based merging.<br>See <a data-tooltip-position="top" aria-label="object-merging" data-href="object-merging" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">Object Merging</a> for combination mechanics.Opposing Forces: Collision (repulsion) must overcome cohesion (attraction) for objects to separate.Stable Equilibrium: Forces should balance to maintain object spacing without oscillation.Dominance: Collision forces typically stronger at close range than cohesion at same distance.<br>See <a data-tooltip-position="top" aria-label="cohesion" data-href="cohesion" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">Cohesion</a> for attraction force mechanics.Determinism: All calculations use fixed-point arithmetic for cross-platform consistency.Precision: Distance and force calculations use 16.16 fixed-point format.Overflow Prevention: Force magnitude clamped to prevent fixed-point overflow in extreme cases.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/determinism.html" data-href="general/determinism" aria-label="general/determinism" data-tooltip-position="top" target="_self">Determinism</a> for fixed-point implementation details.Pass Integration: Collision forces calculated in "Apply Forces + Move" GPU pass.Neighborhood Caching: Two-layer hex neighborhood loaded into workgroup shared memory.Parallel Processing: Each object independently calculates collision forces from neighbors.<br>See <a data-tooltip-position="top" aria-label="passes" data-href="passes" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">Pipeline Passes</a> for integration with multi-pass GPU execution.Neighbor Limits: Two-layer range constraint keeps collision calculations bounded.Early Termination: Skip collision calculations for stationary objects with no nearby motion.Shared Memory: Workgroup caching minimizes texture reads for neighbor data.Playtesting Required: Collision formula will be refined through gameplay iteration.Adjustable Parameters: Force strength and response curve exposed as configuration values.Gameplay Feel: Balance between realistic physics response and responsive, fun gameplay.]]></description><link>architecture/systems/physics/collision.html</link><guid isPermaLink="false">architecture/systems/physics/collision.md</guid><pubDate>Wed, 12 Nov 2025 05:21:29 GMT</pubDate></item><item><title><![CDATA[cohesion]]></title><description><![CDATA[Attraction force that pulls nearby objects together, maintaining density and closing gaps in the object field.Gap Closure: Automatically close gaps between objects for natural density management.Clustering: Maintain dense object coverage without rigid grid constraints.Breaking Force: Allow high-velocity impacts to overcome cohesion and create temporary gaps.Attraction: Objects within cohesion radius pull toward each other.Density Management: Prevents permanent gaps in object field while allowing dynamic separation.Gameplay Interaction: Creates emergent behavior where objects naturally cluster unless disrupted by external forces.Range: Operates within two-layer hexagonal neighborhood (sqrt(7)d/2 - d maximum distance).⚠️ NEEDS SPECIFICATION: Exact cohesion force formula and radius TBD through playtesting.Considerations:
Cohesion radius (likely smaller than two-layer neighborhood range)
Force strength relative to collision forces
Linear vs clamped force falloff with distance
Centroid-based vs pairwise attraction approach
Expected Behavior:
Stronger at medium distances (to close gaps)
Weaker or zero at very close distances (to avoid conflict with collision)
Falls off with distance to limit range Neighbor Detection: Check two-layer hex neighborhood for nearby objects
Distance Calculation: Measure distance between object centers (using sub-grid offsets)
Force Computation: Calculate attraction force based on distance and formula
Vector Direction: Force directed toward other object (or group centroid)
Accumulation: Add to total force for frame
Acceleration: Force produces acceleration inversely proportional to object mass (a = F/m).Symmetric Application: Force applied to both objects in pair (Newton's third law).Balance: Cohesion must be strong enough to close gaps but weak enough to allow spell forces to dominate.Collision Balance: Collision forces must overcome cohesion to prevent objects from merging when they shouldn't.Spell Override: Spell forces should be noticeable and able to overcome cohesion attraction.Combination Trigger: At very close distances (&lt; d), object merging takes over instead of force application.Determinism: All calculations use fixed-point arithmetic for cross-platform consistency.Precision: Distance and force calculations use 16.16 fixed-point format.Overflow Prevention: Force magnitude clamped to prevent fixed-point overflow.See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/determinism.html" data-href="general/determinism" aria-label="general/determinism" data-tooltip-position="top" target="_self">Determinism</a> for fixed-point implementation details.Pass Integration: Cohesion forces calculated in "Apply Forces + Move" GPU pass.Neighborhood Caching: Two-layer hex neighborhood loaded into workgroup shared memory.Parallel Processing: Each object independently calculates cohesion forces from neighbors.<br>See <a data-tooltip-position="top" aria-label="passes" data-href="passes" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">Pipeline Passes</a> for integration with multi-pass GPU execution.Neighbor Limits: Two-layer range constraint keeps cohesion calculations bounded and efficient.Early Termination: Skip cohesion calculations for stationary objects with no nearby activity.Shared Memory: Workgroup caching minimizes texture reads for neighbor data.Playtesting Required: Cohesion formula and radius will be refined through gameplay iteration.Adjustable Parameters: Force strength and radius exposed as configuration values for tuning.Gameplay Feel: Balance between maintaining density and allowing dynamic, responsive movement.]]></description><link>architecture/systems/physics/cohesion.html</link><guid isPermaLink="false">architecture/systems/physics/cohesion.md</guid><pubDate>Wed, 12 Nov 2025 05:21:08 GMT</pubDate></item><item><title><![CDATA[determinism]]></title><description><![CDATA[Framework for achieving deterministic execution across different hardware platforms, ensuring identical game outcomes for competitive multiplayer.Identical Inputs → Identical Outputs: Essential for fair PvP gameplay and competitive integrity.Cross-Platform Consistency: Same results across different hardware, GPU architectures, and drivers.Replay Capability: Matches must be perfectly reproducible from recorded input sequences.Decision: Simultaneous single-read/single-write GPU passes with deterministic internal rules.How It Works:
All tiles read from one texture
All tiles write to separate output texture
Processing order doesn't matter because no tile reads another tile's writes
Deterministic internal rules govern tile behavior
Rationale: Achieves determinism without complex spatial ordering or thread synchronization overhead.Alternative Considered: Spatial ordering strategy (process tiles top-left to bottom-right) - rejected for implementation complexity.No Floating-Point Operations: All physics calculations use fixed-point arithmetic (scaled integers).Platform Independence: Avoids floating-point precision differences across GPU architectures and driver implementations.Consistency: Integer operations produce identical results on all hardware.Precision Format: 16.16 fixed-point (16 bits integer, 16 bits fractional).Scale Factor: 2^16 = 65536⚠️ NEEDS SPECIFICATION: Exact precision requirements for velocity and position through gameplay testing.Addition (trivial):fn fixed_point_add(a: vec2&lt;i32&gt;, b: vec2&lt;i32&gt;) -&gt; vec2&lt;i32&gt; { return a + b;
}
Multiplication:fn fixed_point_multiply(a: i32, b: i32) -&gt; i32 { return (i64(a) * i64(b)) &gt;&gt; 16;
}
Division:fn fixed_point_divide(numerator: i32, denominator: i32) -&gt; i32 { return (i64(numerator) &lt;&lt; 16) / i64(denominator);
}
Bit Precision: Balance between accuracy and overflow risk.Rounding Consistency: Deterministic rounding rules applied uniformly across all calculations.Range Limits: Fixed-point format constrains maximum values (prevents overflow in extreme cases).No Shared Mutable State: Tiles don't share mutable state during GPU pass execution.Read/Write Separation: Texture ping-ponging prevents read-after-write hazards.Data Race Prevention: Concurrent read/write conflicts eliminated by architecture.Selective Use: Atomic operations only where absolutely necessary (e.g., marking active chunks).Deterministic Atomics: When used, atomic operations follow consistent ordering rules.Minimal Dependency: Architecture minimizes need for atomics through pass design.Replay Testing: Identical input sequences must produce identical outputs across platforms.Hardware Variation: Test on NVIDIA, AMD, and Intel GPU architectures.Driver Versions: Validate consistency across different graphics driver versions.⚠️ NEEDS IMPLEMENTATION: Automated cross-platform validation test suite.Checksum Verification: Calculate state checksums at frame boundaries.Regression Detection: Automated testing prevents determinism breaks during development.CI/CD Integration: Determinism validation runs on every commit.Minimal Impact: Simultaneous read/write approach adds negligible overhead.Integer Operations: GPU integer math is as fast as (or faster than) floating-point.Memory Usage: Texture ping-ponging doubles memory usage but ensures safety.Maintain Determinism: All optimizations must preserve deterministic behavior.Memory Access Patterns: Optimize texture reads while keeping deterministic guarantees.Early Termination: Can skip processing for provably inactive regions without breaking determinism.Physics implements deterministic execution through:
Fixed-point arithmetic for all force calculations
Simultaneous read/write passes for collision and movement
Integer-only velocity and position updates
See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/physics.html" data-href="physics/physics" aria-label="physics/physics" data-tooltip-position="top" target="_self">Physics System</a> for implementation details
Multiplayer relies on determinism for:
State synchronization between clients and server
Client-side prediction and rollback
Replay validation and cheat detection
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/multiplayer/multiplayer.html" data-href="multiplayer/multiplayer" aria-label="multiplayer/multiplayer" data-tooltip-position="top" target="_self">Multiplayer System</a> for integration details
All Changes: Consider determinism impact before implementing any physics/gameplay changes.Code Review: Explicit review of determinism implications required.Testing: Validate determinism before and after modifications.Floating-Point Math: Never use floating-point in gameplay logic.Random Numbers: Use deterministic RNG with consistent seeding.Timing Dependencies: Don't rely on wall-clock time or variable frame timing.Undefined Ordering: Ensure all operations have well-defined execution order.]]></description><link>architecture/general/determinism.html</link><guid isPermaLink="false">architecture/general/determinism.md</guid><pubDate>Wed, 12 Nov 2025 05:20:28 GMT</pubDate></item><item><title><![CDATA[implementation-guide]]></title><description><![CDATA[Phased implementation plan for building the game architecture, including priorities, integration strategies, and validation approaches.This document needs to be written to cover:
Implementation phases and priorities
Integration strategies with existing systems
Testing and validation approaches
Risk assessment and mitigation
]]></description><link>architecture/general/implementation-guide.html</link><guid isPermaLink="false">architecture/general/implementation-guide.md</guid><pubDate>Wed, 12 Nov 2025 03:44:51 GMT</pubDate></item><item><title><![CDATA[multiplayer]]></title><description><![CDATA[Navigation hub for multiplayer architecture documentation.Internal architecture of the authoritative game server.Message format specifications and communication protocol.Multiplayer-specific performance goals and optimization strategies.Security measures and anti-cheat detection systems.Infrastructure setup and deployment pipeline.]]></description><link>architecture/systems/multiplayer/multiplayer.html</link><guid isPermaLink="false">architecture/systems/multiplayer/multiplayer.md</guid><pubDate>Wed, 12 Nov 2025 03:40:48 GMT</pubDate></item><item><title><![CDATA[state-management]]></title><description><![CDATA[State snapshot system for capturing, storing, and restoring game state for rollback and synchronization.This document needs to be written to cover:
State snapshot capture and storage
Rollback and recovery mechanisms
State serialization and compression
]]></description><link>architecture/general/state-management.html</link><guid isPermaLink="false">architecture/general/state-management.md</guid><pubDate>Wed, 12 Nov 2025 03:37:27 GMT</pubDate></item><item><title><![CDATA[data-flow]]></title><description><![CDATA[The execution pipeline describing how data flows through the game engine during frame processing.This document needs to be written to cover:
Frame execution pipeline and processing order
How different systems (physics, reactions, state management) connect in the pipeline
]]></description><link>architecture/general/data-flow.html</link><guid isPermaLink="false">architecture/general/data-flow.md</guid><pubDate>Wed, 12 Nov 2025 03:37:22 GMT</pubDate></item><item><title><![CDATA[performance]]></title><description><![CDATA[Multiplayer-specific performance goals, monitoring, and cross-system optimization strategies.This document needs to be written to cover:
Overall multiplayer performance goals and targets
Cross-system performance coordination
Latency management strategies
Performance monitoring and metrics
Scaling strategies (horizontal and vertical)
]]></description><link>architecture/systems/multiplayer/performance.html</link><guid isPermaLink="false">architecture/systems/multiplayer/performance.md</guid><pubDate>Wed, 12 Nov 2025 03:36:52 GMT</pubDate></item><item><title><![CDATA[security]]></title><description><![CDATA[Security measures, input validation, and anti-cheat detection for competitive multiplayer integrity.This document needs to be written to cover:
Server authority model
Input validation systems
Anti-cheat detection mechanisms
Security incident response
]]></description><link>architecture/systems/multiplayer/security.html</link><guid isPermaLink="false">architecture/systems/multiplayer/security.md</guid><pubDate>Wed, 12 Nov 2025 03:36:48 GMT</pubDate></item><item><title><![CDATA[network-protocol]]></title><description><![CDATA[Message format specifications, protocol design, and communication patterns for client-server communication.This document needs to be written to cover:
Message structure and type definitions
Protocol design and communication patterns
Compression and encoding schemes
Connection management and reliability mechanisms
]]></description><link>architecture/systems/multiplayer/network-protocol.html</link><guid isPermaLink="false">architecture/systems/multiplayer/network-protocol.md</guid><pubDate>Wed, 12 Nov 2025 03:36:42 GMT</pubDate></item><item><title><![CDATA[server-architecture]]></title><description><![CDATA[Internal architecture of the authoritative game server, including components, frame processing, and match management.This document needs to be written to cover:
Server components and their responsibilities
Frame execution and processing pipeline
Match lifecycle management
Server-side performance optimization strategies
]]></description><link>architecture/systems/multiplayer/server-architecture.html</link><guid isPermaLink="false">architecture/systems/multiplayer/server-architecture.md</guid><pubDate>Wed, 12 Nov 2025 03:36:37 GMT</pubDate></item><item><title><![CDATA[deployment]]></title><description><![CDATA[Infrastructure setup, container orchestration, and deployment pipeline for multiplayer servers.This document needs to be written to cover:
Container configuration and orchestration platforms
Regional deployment strategy
CI/CD pipeline and deployment process
Infrastructure monitoring
]]></description><link>architecture/systems/multiplayer/deployment.html</link><guid isPermaLink="false">architecture/systems/multiplayer/deployment.md</guid><pubDate>Wed, 12 Nov 2025 03:36:31 GMT</pubDate></item><item><title><![CDATA[getting-started]]></title><description><![CDATA[Project setup and development environment configuration for Reaction v2.This document needs to be written to cover:
Prerequisites and required software
Initial project setup steps
Development workflow and available commands
Common setup issues and troubleshooting
]]></description><link>development/getting-started.html</link><guid isPermaLink="false">development/getting-started.md</guid><pubDate>Wed, 12 Nov 2025 03:13:46 GMT</pubDate></item><item><title><![CDATA[tasklist]]></title><description><![CDATA[Automatically generated task list from all TODO items found in the documentation using Dataview.Status Overview All TODO Items
<a data-tooltip-position="top" aria-label="architecture/systems/physics/cohesion.md" data-href="architecture/systems/physics/cohesion.md" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">cohesion</a>: [implementation] Determine cohesion force formula through playtesting[implementation] Determine cohesion radius through playtesting[testing] Validate cohesion interaction with collision forces<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/collision.md" data-href="architecture/systems/physics/collision.md" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">collision</a>: [implementation] Determine collision force formula through playtesting[testing] Validate collision response with various mass ratios[discussion] Balance between collision force and combination trigger threshold<br><a data-tooltip-position="top" aria-label="architecture/systems/config/config.md" data-href="architecture/systems/config/config.md" href="architecture/systems/config/config.html" class="internal-link" target="_self" rel="noopener nofollow">config</a>: Define configuration system architectureDocument configuration file formatsAdd runtime configuration managementDocument environment-specific settings<br><a data-tooltip-position="top" aria-label="gameplay/core-mechanics.md" data-href="gameplay/core-mechanics.md" href="gameplay/core-mechanics.html" class="internal-link" target="_self" rel="noopener nofollow">core-mechanics</a>: [discussion] Confirm healing mechanics approach (no healing vs tile-based healing zones)[discussion] Map size constraints for optimal performance<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/customization.md" data-href="architecture/systems/spells/customization.md" href="architecture/systems/spells/customization.html" class="internal-link" target="_self" rel="noopener nofollow">customization</a>: [discussion] Curse system implementation details[discussion] Curse stacking rules and limits<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/deck-building.md" data-href="architecture/systems/spells/deck-building.md" href="architecture/systems/spells/deck-building.html" class="internal-link" target="_self" rel="noopener nofollow">deck-building</a>: [discussion] Maximum deck size limits[discussion] Spell acquisition and progression system<br><a data-tooltip-position="top" aria-label="architecture/general/determinism.md" data-href="architecture/general/determinism.md" href="architecture/general/determinism.html" class="internal-link" target="_self" rel="noopener nofollow">determinism</a>: [implementation] Specify exact fixed-point formats for velocity and position[implementation] Implement cross-platform validation test suite[testing] Validate determinism across different GPU architectures<br><a data-tooltip-position="top" aria-label="docs.md" data-href="docs.md" href="docs.html" class="internal-link" target="_self" rel="noopener nofollow">docs</a>: Complete main documentation indexAdd project overview sectionAdd getting started quick links<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/element-effects.md" data-href="architecture/systems/spells/element-effects.md" href="architecture/systems/spells/element-effects.html" class="internal-link" target="_self" rel="noopener nofollow">element-effects</a>: [design] Define force types and magnitudes for all 26 elements[design] Define tile transformation effects for double-element spells[design] Define passive modifications for triple-element spells[discussion] Determine which elements use impulse vs velocity-set forces<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/element-system.md" data-href="architecture/systems/spells/element-system.md" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">element-system</a>: [discussion] Void rune effects[discussion] Triple element spell niche uses<br><a data-tooltip-position="top" aria-label="architecture/general/general.md" data-href="architecture/general/general.md" href="architecture/general/general.html" class="internal-link" target="_self" rel="noopener nofollow">general</a>: [documentation] Update navigation to mark outdated documents[documentation] Remove active region references<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/mana-system.md" data-href="architecture/systems/spells/mana-system.md" href="architecture/systems/spells/mana-system.html" class="internal-link" target="_self" rel="noopener nofollow">mana-system</a>: [discussion] Flower recharge timing balance - 3-turn cycle interaction with action cooldown<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/movement.md" data-href="architecture/systems/physics/movement.md" href="architecture/systems/physics/movement.html" class="internal-link" target="_self" rel="noopener nofollow">movement</a>: [discussion] Define mass values for different object types across all layers[testing] Validate velocity damping needs through playtesting<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/object-merging.md" data-href="architecture/systems/physics/object-merging.md" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">object-merging</a>: [implementation] Specify exact combination distance threshold d[implementation] Implement scatter-gather algorithm for multi-object merges[testing] Validate momentum conservation in merges<br><a data-tooltip-position="top" aria-label="architecture/general/overview.md" data-href="architecture/general/overview.md" href="architecture/general/overview.html" class="internal-link" target="_self" rel="noopener nofollow">overview</a>: [discussion] Mass values for different tile types in collision physics[documentation] Document actual determinism approach (simultaneous read/write passes)<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/passes.md" data-href="architecture/systems/physics/passes.md" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">passes</a>: [implementation] Determine optimal number of overlap passes through profiling[discussion] Frame timing coordination with reactions and rendering<br><a data-tooltip-position="top" aria-label="architecture/general/performance.md" data-href="architecture/general/performance.md" href="architecture/general/performance.html" class="internal-link" target="_self" rel="noopener nofollow">performance</a>: [documentation] Rewrite performance strategy without active regions[discussion] Alternative optimization approaches without active regions<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/reactions.md" data-href="architecture/systems/physics/reactions.md" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">reactions</a>: [design] Change object merging so second overlap prevents creation (no triple+ merges)[design] Design cross-layer object creation during reactions[design] Triple-element spells will provide passive modifications to reactions and forces for their duration[implementation] Build hashmap structure for merge reactions (type pairs -&gt; new type)[implementation] Design search tree for environmental reaction lookups[discussion] Define all timer types needed (burning, freezing, electrified, etc.)[discussion] Define all reaction rules (merges and environmental)<br><a data-tooltip-position="top" aria-label="architecture/general/shader-data-layout.md" data-href="architecture/general/shader-data-layout.md" href="architecture/general/shader-data-layout.html" class="internal-link" target="_self" rel="noopener nofollow">shader-data-layout</a>: [implementation] List all data fields needed in GPU shader passes[implementation] Determine bit allocation for each field[implementation] Calculate total storage requirements per object[implementation] Optimize bit-packing to minimize texture memory usage[discussion] Determine timer type bit count based on number of timer types needed[discussion] Determine timer value bit count based on maximum time duration needed<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/spell-integration.md" data-href="architecture/systems/physics/spell-integration.md" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">spell-integration</a>: [discussion] Define which spell elements use impulses vs velocity setting[implementation] Specify spell force magnitudes per element[discussion] Determine if spell forces ignore mass or not[design] Triple-element spells will provide passive modifications to reactions and forces for their duration<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/spells-and-runes.md" data-href="architecture/systems/spells/spells-and-runes.md" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">spells-and-runes</a>: [discussion] Number of casting slots/pools - using 4 as example, final count TBD[discussion] Obstruction checks for line of sight[discussion] Specific shape primitives for spell design[discussion] Single element rune additional effects beyond mana recharge<br><a data-tooltip-position="top" aria-label="architecture/general/technical-decisions.md" data-href="architecture/general/technical-decisions.md" href="architecture/general/technical-decisions.html" class="internal-link" target="_self" rel="noopener nofollow">technical-decisions</a>: [discussion] Specific mass values for different tile types in collision physics[discussion] Frame rate coordination between physics, reactions, and rendering<br><a data-tooltip-position="top" aria-label="architecture/systems/ui/ui.md" data-href="architecture/systems/ui/ui.md" href="architecture/systems/ui/ui.html" class="internal-link" target="_self" rel="noopener nofollow">ui</a>: Define UI system architectureDocument component hierarchyAdd interaction patternsDocument accessibility requirements
All Warnings
<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/cpu-architecture.md" data-href="architecture/systems/spells/cpu-architecture.md" href="architecture/systems/spells/cpu-architecture.html" class="internal-link" target="_self" rel="noopener nofollow">cpu-architecture</a>: [outdated] Entire file - Spell system now fully GPU-accelerated, not CPU-based<br><a data-tooltip-position="top" aria-label="architecture/general/determinism.md" data-href="architecture/general/determinism.md" href="architecture/general/determinism.html" class="internal-link" target="_self" rel="noopener nofollow">determinism</a>: [proposed] Fixed-point precision needs validation through testing<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/element-effects.md" data-href="architecture/systems/spells/element-effects.md" href="architecture/systems/spells/element-effects.html" class="internal-link" target="_self" rel="noopener nofollow">element-effects</a>: [proposed] Element effects are design proposals awaiting gameplay testing<br><a data-tooltip-position="top" aria-label="architecture/general/general.md" data-href="architecture/general/general.md" href="architecture/general/general.html" class="internal-link" target="_self" rel="noopener nofollow">general</a>: [outdated] Active Region System referenced but not being implemented[outdated] Multiple linked documents describe outdated approaches (implementation-guide, data-flow)<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/mana-system.md" data-href="architecture/systems/spells/mana-system.md" href="architecture/systems/spells/mana-system.html" class="internal-link" target="_self" rel="noopener nofollow">mana-system</a>: [outdated] All fire/water/earth/air references removed - replaced with 6-element system<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/object-merging.md" data-href="architecture/systems/physics/object-merging.md" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">object-merging</a>: [proposed] Scatter-gather implementation approach needs specification<br><a data-tooltip-position="top" aria-label="architecture/general/overview.md" data-href="architecture/general/overview.md" href="architecture/general/overview.html" class="internal-link" target="_self" rel="noopener nofollow">overview</a>: [outdated] Active region optimization references removed - system not being implemented[outdated] data-flow.md reference is outdated<br><a data-tooltip-position="top" aria-label="architecture/general/performance.md" data-href="architecture/general/performance.md" href="architecture/general/performance.html" class="internal-link" target="_self" rel="noopener nofollow">performance</a>: [outdated] Active Region System section describes system that is NOT being implemented[outdated] 32×32 chunk references throughout document<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/spell-integration.md" data-href="architecture/systems/physics/spell-integration.md" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">spell-integration</a>: [proposed] Element-to-force mapping needs spell system design completion<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/spells.md" data-href="architecture/systems/spells/spells.md" href="architecture/systems/spells/spells.html" class="internal-link" target="_self" rel="noopener nofollow">spells</a>: [outdated] Previously mentioned CPU-only design - now fully GPU-accelerated<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/spells-and-runes.md" data-href="architecture/systems/spells/spells-and-runes.md" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">spells-and-runes</a>: [outdated] Previously mentioned CPU processing - now fully GPU-accelerated
Files by Status Implementation Tasks
<br><a data-tooltip-position="top" aria-label="architecture/general/shader-data-layout.md" data-href="architecture/general/shader-data-layout.md" href="architecture/general/shader-data-layout.html" class="internal-link" target="_self" rel="noopener nofollow">shader-data-layout</a>: [implementation] List all data fields needed in GPU shader passes[implementation] Determine bit allocation for each field[implementation] Calculate total storage requirements per object[implementation] Optimize bit-packing to minimize texture memory usage[discussion] Determine timer type bit count based on number of timer types needed[discussion] Determine timer value bit count based on maximum time duration needed<br><a data-tooltip-position="top" aria-label="architecture/general/shader-data-layout.md" data-href="architecture/general/shader-data-layout.md" href="architecture/general/shader-data-layout.html" class="internal-link" target="_self" rel="noopener nofollow">shader-data-layout</a>: [implementation] List all data fields needed in GPU shader passes[implementation] Determine bit allocation for each field[implementation] Calculate total storage requirements per object[implementation] Optimize bit-packing to minimize texture memory usage[discussion] Determine timer type bit count based on number of timer types needed[discussion] Determine timer value bit count based on maximum time duration needed<br><a data-tooltip-position="top" aria-label="architecture/general/shader-data-layout.md" data-href="architecture/general/shader-data-layout.md" href="architecture/general/shader-data-layout.html" class="internal-link" target="_self" rel="noopener nofollow">shader-data-layout</a>: [implementation] List all data fields needed in GPU shader passes[implementation] Determine bit allocation for each field[implementation] Calculate total storage requirements per object[implementation] Optimize bit-packing to minimize texture memory usage[discussion] Determine timer type bit count based on number of timer types needed[discussion] Determine timer value bit count based on maximum time duration needed<br><a data-tooltip-position="top" aria-label="architecture/general/shader-data-layout.md" data-href="architecture/general/shader-data-layout.md" href="architecture/general/shader-data-layout.html" class="internal-link" target="_self" rel="noopener nofollow">shader-data-layout</a>: [implementation] List all data fields needed in GPU shader passes[implementation] Determine bit allocation for each field[implementation] Calculate total storage requirements per object[implementation] Optimize bit-packing to minimize texture memory usage[discussion] Determine timer type bit count based on number of timer types needed[discussion] Determine timer value bit count based on maximum time duration needed<br><a data-tooltip-position="top" aria-label="architecture/general/determinism.md" data-href="architecture/general/determinism.md" href="architecture/general/determinism.html" class="internal-link" target="_self" rel="noopener nofollow">determinism</a>: [implementation] Specify exact fixed-point formats for velocity and position[implementation] Implement cross-platform validation test suite[testing] Validate determinism across different GPU architectures<br><a data-tooltip-position="top" aria-label="architecture/general/determinism.md" data-href="architecture/general/determinism.md" href="architecture/general/determinism.html" class="internal-link" target="_self" rel="noopener nofollow">determinism</a>: [implementation] Specify exact fixed-point formats for velocity and position[implementation] Implement cross-platform validation test suite[testing] Validate determinism across different GPU architectures<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/reactions.md" data-href="architecture/systems/physics/reactions.md" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">reactions</a>: [design] Change object merging so second overlap prevents creation (no triple+ merges)[design] Design cross-layer object creation during reactions[design] Triple-element spells will provide passive modifications to reactions and forces for their duration[implementation] Build hashmap structure for merge reactions (type pairs -&gt; new type)[implementation] Design search tree for environmental reaction lookups[discussion] Define all timer types needed (burning, freezing, electrified, etc.)[discussion] Define all reaction rules (merges and environmental)<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/reactions.md" data-href="architecture/systems/physics/reactions.md" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">reactions</a>: [design] Change object merging so second overlap prevents creation (no triple+ merges)[design] Design cross-layer object creation during reactions[design] Triple-element spells will provide passive modifications to reactions and forces for their duration[implementation] Build hashmap structure for merge reactions (type pairs -&gt; new type)[implementation] Design search tree for environmental reaction lookups[discussion] Define all timer types needed (burning, freezing, electrified, etc.)[discussion] Define all reaction rules (merges and environmental)<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/cohesion.md" data-href="architecture/systems/physics/cohesion.md" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">cohesion</a>: [implementation] Determine cohesion force formula through playtesting[implementation] Determine cohesion radius through playtesting[testing] Validate cohesion interaction with collision forces<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/cohesion.md" data-href="architecture/systems/physics/cohesion.md" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">cohesion</a>: [implementation] Determine cohesion force formula through playtesting[implementation] Determine cohesion radius through playtesting[testing] Validate cohesion interaction with collision forces<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/collision.md" data-href="architecture/systems/physics/collision.md" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">collision</a>: [implementation] Determine collision force formula through playtesting[testing] Validate collision response with various mass ratios[discussion] Balance between collision force and combination trigger threshold<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/object-merging.md" data-href="architecture/systems/physics/object-merging.md" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">object-merging</a>: [implementation] Specify exact combination distance threshold d[implementation] Implement scatter-gather algorithm for multi-object merges[testing] Validate momentum conservation in merges<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/object-merging.md" data-href="architecture/systems/physics/object-merging.md" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">object-merging</a>: [implementation] Specify exact combination distance threshold d[implementation] Implement scatter-gather algorithm for multi-object merges[testing] Validate momentum conservation in merges<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/passes.md" data-href="architecture/systems/physics/passes.md" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">passes</a>: [implementation] Determine optimal number of overlap passes through profiling[discussion] Frame timing coordination with reactions and rendering<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/spell-integration.md" data-href="architecture/systems/physics/spell-integration.md" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">spell-integration</a>: [discussion] Define which spell elements use impulses vs velocity setting[implementation] Specify spell force magnitudes per element[discussion] Determine if spell forces ignore mass or not[design] Triple-element spells will provide passive modifications to reactions and forces for their duration
Testing Tasks
<br><a data-tooltip-position="top" aria-label="architecture/general/determinism.md" data-href="architecture/general/determinism.md" href="architecture/general/determinism.html" class="internal-link" target="_self" rel="noopener nofollow">determinism</a>: [implementation] Specify exact fixed-point formats for velocity and position[implementation] Implement cross-platform validation test suite[testing] Validate determinism across different GPU architectures<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/cohesion.md" data-href="architecture/systems/physics/cohesion.md" href="architecture/systems/physics/cohesion.html" class="internal-link" target="_self" rel="noopener nofollow">cohesion</a>: [implementation] Determine cohesion force formula through playtesting[implementation] Determine cohesion radius through playtesting[testing] Validate cohesion interaction with collision forces<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/collision.md" data-href="architecture/systems/physics/collision.md" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">collision</a>: [implementation] Determine collision force formula through playtesting[testing] Validate collision response with various mass ratios[discussion] Balance between collision force and combination trigger threshold<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/object-merging.md" data-href="architecture/systems/physics/object-merging.md" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">object-merging</a>: [implementation] Specify exact combination distance threshold d[implementation] Implement scatter-gather algorithm for multi-object merges[testing] Validate momentum conservation in merges<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/movement.md" data-href="architecture/systems/physics/movement.md" href="architecture/systems/physics/movement.html" class="internal-link" target="_self" rel="noopener nofollow">movement</a>: [discussion] Define mass values for different object types across all layers[testing] Validate velocity damping needs through playtesting
Discussion Items
<br><a data-tooltip-position="top" aria-label="architecture/general/overview.md" data-href="architecture/general/overview.md" href="architecture/general/overview.html" class="internal-link" target="_self" rel="noopener nofollow">overview</a>: [discussion] Mass values for different tile types in collision physics[documentation] Document actual determinism approach (simultaneous read/write passes)<br><a data-tooltip-position="top" aria-label="architecture/general/performance.md" data-href="architecture/general/performance.md" href="architecture/general/performance.html" class="internal-link" target="_self" rel="noopener nofollow">performance</a>: [documentation] Rewrite performance strategy without active regions[discussion] Alternative optimization approaches without active regions<br><a data-tooltip-position="top" aria-label="architecture/general/shader-data-layout.md" data-href="architecture/general/shader-data-layout.md" href="architecture/general/shader-data-layout.html" class="internal-link" target="_self" rel="noopener nofollow">shader-data-layout</a>: [implementation] List all data fields needed in GPU shader passes[implementation] Determine bit allocation for each field[implementation] Calculate total storage requirements per object[implementation] Optimize bit-packing to minimize texture memory usage[discussion] Determine timer type bit count based on number of timer types needed[discussion] Determine timer value bit count based on maximum time duration needed<br><a data-tooltip-position="top" aria-label="architecture/general/shader-data-layout.md" data-href="architecture/general/shader-data-layout.md" href="architecture/general/shader-data-layout.html" class="internal-link" target="_self" rel="noopener nofollow">shader-data-layout</a>: [implementation] List all data fields needed in GPU shader passes[implementation] Determine bit allocation for each field[implementation] Calculate total storage requirements per object[implementation] Optimize bit-packing to minimize texture memory usage[discussion] Determine timer type bit count based on number of timer types needed[discussion] Determine timer value bit count based on maximum time duration needed<br><a data-tooltip-position="top" aria-label="architecture/general/technical-decisions.md" data-href="architecture/general/technical-decisions.md" href="architecture/general/technical-decisions.html" class="internal-link" target="_self" rel="noopener nofollow">technical-decisions</a>: [discussion] Specific mass values for different tile types in collision physics[discussion] Frame rate coordination between physics, reactions, and rendering<br><a data-tooltip-position="top" aria-label="architecture/general/technical-decisions.md" data-href="architecture/general/technical-decisions.md" href="architecture/general/technical-decisions.html" class="internal-link" target="_self" rel="noopener nofollow">technical-decisions</a>: [discussion] Specific mass values for different tile types in collision physics[discussion] Frame rate coordination between physics, reactions, and rendering<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/reactions.md" data-href="architecture/systems/physics/reactions.md" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">reactions</a>: [design] Change object merging so second overlap prevents creation (no triple+ merges)[design] Design cross-layer object creation during reactions[design] Triple-element spells will provide passive modifications to reactions and forces for their duration[implementation] Build hashmap structure for merge reactions (type pairs -&gt; new type)[implementation] Design search tree for environmental reaction lookups[discussion] Define all timer types needed (burning, freezing, electrified, etc.)[discussion] Define all reaction rules (merges and environmental)<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/reactions.md" data-href="architecture/systems/physics/reactions.md" href="architecture/systems/physics/reactions.html" class="internal-link" target="_self" rel="noopener nofollow">reactions</a>: [design] Change object merging so second overlap prevents creation (no triple+ merges)[design] Design cross-layer object creation during reactions[design] Triple-element spells will provide passive modifications to reactions and forces for their duration[implementation] Build hashmap structure for merge reactions (type pairs -&gt; new type)[implementation] Design search tree for environmental reaction lookups[discussion] Define all timer types needed (burning, freezing, electrified, etc.)[discussion] Define all reaction rules (merges and environmental)<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/collision.md" data-href="architecture/systems/physics/collision.md" href="architecture/systems/physics/collision.html" class="internal-link" target="_self" rel="noopener nofollow">collision</a>: [implementation] Determine collision force formula through playtesting[testing] Validate collision response with various mass ratios[discussion] Balance between collision force and combination trigger threshold<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/passes.md" data-href="architecture/systems/physics/passes.md" href="architecture/systems/physics/passes.html" class="internal-link" target="_self" rel="noopener nofollow">passes</a>: [implementation] Determine optimal number of overlap passes through profiling[discussion] Frame timing coordination with reactions and rendering<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/spell-integration.md" data-href="architecture/systems/physics/spell-integration.md" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">spell-integration</a>: [discussion] Define which spell elements use impulses vs velocity setting[implementation] Specify spell force magnitudes per element[discussion] Determine if spell forces ignore mass or not[design] Triple-element spells will provide passive modifications to reactions and forces for their duration<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/spell-integration.md" data-href="architecture/systems/physics/spell-integration.md" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">spell-integration</a>: [discussion] Define which spell elements use impulses vs velocity setting[implementation] Specify spell force magnitudes per element[discussion] Determine if spell forces ignore mass or not[design] Triple-element spells will provide passive modifications to reactions and forces for their duration<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/movement.md" data-href="architecture/systems/physics/movement.md" href="architecture/systems/physics/movement.html" class="internal-link" target="_self" rel="noopener nofollow">movement</a>: [discussion] Define mass values for different object types across all layers[testing] Validate velocity damping needs through playtesting<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/customization.md" data-href="architecture/systems/spells/customization.md" href="architecture/systems/spells/customization.html" class="internal-link" target="_self" rel="noopener nofollow">customization</a>: [discussion] Curse system implementation details[discussion] Curse stacking rules and limits<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/customization.md" data-href="architecture/systems/spells/customization.md" href="architecture/systems/spells/customization.html" class="internal-link" target="_self" rel="noopener nofollow">customization</a>: [discussion] Curse system implementation details[discussion] Curse stacking rules and limits<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/deck-building.md" data-href="architecture/systems/spells/deck-building.md" href="architecture/systems/spells/deck-building.html" class="internal-link" target="_self" rel="noopener nofollow">deck-building</a>: [discussion] Maximum deck size limits[discussion] Spell acquisition and progression system<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/deck-building.md" data-href="architecture/systems/spells/deck-building.md" href="architecture/systems/spells/deck-building.html" class="internal-link" target="_self" rel="noopener nofollow">deck-building</a>: [discussion] Maximum deck size limits[discussion] Spell acquisition and progression system<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/element-system.md" data-href="architecture/systems/spells/element-system.md" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">element-system</a>: [discussion] Void rune effects[discussion] Triple element spell niche uses<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/element-system.md" data-href="architecture/systems/spells/element-system.md" href="architecture/systems/spells/element-system.html" class="internal-link" target="_self" rel="noopener nofollow">element-system</a>: [discussion] Void rune effects[discussion] Triple element spell niche uses<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/mana-system.md" data-href="architecture/systems/spells/mana-system.md" href="architecture/systems/spells/mana-system.html" class="internal-link" target="_self" rel="noopener nofollow">mana-system</a>: [discussion] Flower recharge timing balance - 3-turn cycle interaction with action cooldown<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/spells-and-runes.md" data-href="architecture/systems/spells/spells-and-runes.md" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">spells-and-runes</a>: [discussion] Number of casting slots/pools - using 4 as example, final count TBD[discussion] Obstruction checks for line of sight[discussion] Specific shape primitives for spell design[discussion] Single element rune additional effects beyond mana recharge<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/spells-and-runes.md" data-href="architecture/systems/spells/spells-and-runes.md" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">spells-and-runes</a>: [discussion] Number of casting slots/pools - using 4 as example, final count TBD[discussion] Obstruction checks for line of sight[discussion] Specific shape primitives for spell design[discussion] Single element rune additional effects beyond mana recharge<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/spells-and-runes.md" data-href="architecture/systems/spells/spells-and-runes.md" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">spells-and-runes</a>: [discussion] Number of casting slots/pools - using 4 as example, final count TBD[discussion] Obstruction checks for line of sight[discussion] Specific shape primitives for spell design[discussion] Single element rune additional effects beyond mana recharge<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/spells-and-runes.md" data-href="architecture/systems/spells/spells-and-runes.md" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">spells-and-runes</a>: [discussion] Number of casting slots/pools - using 4 as example, final count TBD[discussion] Obstruction checks for line of sight[discussion] Specific shape primitives for spell design[discussion] Single element rune additional effects beyond mana recharge<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/element-effects.md" data-href="architecture/systems/spells/element-effects.md" href="architecture/systems/spells/element-effects.html" class="internal-link" target="_self" rel="noopener nofollow">element-effects</a>: [design] Define force types and magnitudes for all 26 elements[design] Define tile transformation effects for double-element spells[design] Define passive modifications for triple-element spells[discussion] Determine which elements use impulse vs velocity-set forces<br><a data-tooltip-position="top" aria-label="gameplay/core-mechanics.md" data-href="gameplay/core-mechanics.md" href="gameplay/core-mechanics.html" class="internal-link" target="_self" rel="noopener nofollow">core-mechanics</a>: [discussion] Confirm healing mechanics approach (no healing vs tile-based healing zones)[discussion] Map size constraints for optimal performance<br><a data-tooltip-position="top" aria-label="gameplay/core-mechanics.md" data-href="gameplay/core-mechanics.md" href="gameplay/core-mechanics.html" class="internal-link" target="_self" rel="noopener nofollow">core-mechanics</a>: [discussion] Confirm healing mechanics approach (no healing vs tile-based healing zones)[discussion] Map size constraints for optimal performance
Research Items
Dataview: No results to show for list query.
Documentation Tasks
<br><a data-tooltip-position="top" aria-label="architecture/general/general.md" data-href="architecture/general/general.md" href="architecture/general/general.html" class="internal-link" target="_self" rel="noopener nofollow">general</a>: [documentation] Update navigation to mark outdated documents[documentation] Remove active region references<br><a data-tooltip-position="top" aria-label="architecture/general/general.md" data-href="architecture/general/general.md" href="architecture/general/general.html" class="internal-link" target="_self" rel="noopener nofollow">general</a>: [documentation] Update navigation to mark outdated documents[documentation] Remove active region references<br><a data-tooltip-position="top" aria-label="architecture/general/overview.md" data-href="architecture/general/overview.md" href="architecture/general/overview.html" class="internal-link" target="_self" rel="noopener nofollow">overview</a>: [discussion] Mass values for different tile types in collision physics[documentation] Document actual determinism approach (simultaneous read/write passes)<br><a data-tooltip-position="top" aria-label="architecture/general/performance.md" data-href="architecture/general/performance.md" href="architecture/general/performance.html" class="internal-link" target="_self" rel="noopener nofollow">performance</a>: [documentation] Rewrite performance strategy without active regions[discussion] Alternative optimization approaches without active regions
Review Tasks
Dataview: No results to show for list query.
Proposed Systems
<br><a data-tooltip-position="top" aria-label="architecture/general/determinism.md" data-href="architecture/general/determinism.md" href="architecture/general/determinism.html" class="internal-link" target="_self" rel="noopener nofollow">determinism</a>: [proposed] Fixed-point precision needs validation through testing<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/object-merging.md" data-href="architecture/systems/physics/object-merging.md" href="architecture/systems/physics/object-merging.html" class="internal-link" target="_self" rel="noopener nofollow">object-merging</a>: [proposed] Scatter-gather implementation approach needs specification<br><a data-tooltip-position="top" aria-label="architecture/systems/physics/spell-integration.md" data-href="architecture/systems/physics/spell-integration.md" href="architecture/systems/physics/spell-integration.html" class="internal-link" target="_self" rel="noopener nofollow">spell-integration</a>: [proposed] Element-to-force mapping needs spell system design completion<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/element-effects.md" data-href="architecture/systems/spells/element-effects.md" href="architecture/systems/spells/element-effects.html" class="internal-link" target="_self" rel="noopener nofollow">element-effects</a>: [proposed] Element effects are design proposals awaiting gameplay testing
Outdated Documents
<br><a data-tooltip-position="top" aria-label="architecture/general/general.md" data-href="architecture/general/general.md" href="architecture/general/general.html" class="internal-link" target="_self" rel="noopener nofollow">general</a>: [outdated] Active Region System referenced but not being implemented[outdated] Multiple linked documents describe outdated approaches (implementation-guide, data-flow)<br><a data-tooltip-position="top" aria-label="architecture/general/general.md" data-href="architecture/general/general.md" href="architecture/general/general.html" class="internal-link" target="_self" rel="noopener nofollow">general</a>: [outdated] Active Region System referenced but not being implemented[outdated] Multiple linked documents describe outdated approaches (implementation-guide, data-flow)<br><a data-tooltip-position="top" aria-label="architecture/general/overview.md" data-href="architecture/general/overview.md" href="architecture/general/overview.html" class="internal-link" target="_self" rel="noopener nofollow">overview</a>: [outdated] Active region optimization references removed - system not being implemented[outdated] data-flow.md reference is outdated<br><a data-tooltip-position="top" aria-label="architecture/general/overview.md" data-href="architecture/general/overview.md" href="architecture/general/overview.html" class="internal-link" target="_self" rel="noopener nofollow">overview</a>: [outdated] Active region optimization references removed - system not being implemented[outdated] data-flow.md reference is outdated<br><a data-tooltip-position="top" aria-label="architecture/general/performance.md" data-href="architecture/general/performance.md" href="architecture/general/performance.html" class="internal-link" target="_self" rel="noopener nofollow">performance</a>: [outdated] Active Region System section describes system that is NOT being implemented[outdated] 32×32 chunk references throughout document<br><a data-tooltip-position="top" aria-label="architecture/general/performance.md" data-href="architecture/general/performance.md" href="architecture/general/performance.html" class="internal-link" target="_self" rel="noopener nofollow">performance</a>: [outdated] Active Region System section describes system that is NOT being implemented[outdated] 32×32 chunk references throughout document<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/cpu-architecture.md" data-href="architecture/systems/spells/cpu-architecture.md" href="architecture/systems/spells/cpu-architecture.html" class="internal-link" target="_self" rel="noopener nofollow">cpu-architecture</a>: [outdated] Entire file - Spell system now fully GPU-accelerated, not CPU-based<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/mana-system.md" data-href="architecture/systems/spells/mana-system.md" href="architecture/systems/spells/mana-system.html" class="internal-link" target="_self" rel="noopener nofollow">mana-system</a>: [outdated] All fire/water/earth/air references removed - replaced with 6-element system<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/spells-and-runes.md" data-href="architecture/systems/spells/spells-and-runes.md" href="architecture/systems/spells/spells-and-runes.html" class="internal-link" target="_self" rel="noopener nofollow">spells-and-runes</a>: [outdated] Previously mentioned CPU processing - now fully GPU-accelerated<br><a data-tooltip-position="top" aria-label="architecture/systems/spells/spells.md" data-href="architecture/systems/spells/spells.md" href="architecture/systems/spells/spells.html" class="internal-link" target="_self" rel="noopener nofollow">spells</a>: [outdated] Previously mentioned CPU-only design - now fully GPU-accelerated
Breaking Changes
Dataview: No results to show for list query.
Performance Concerns
Dataview: No results to show for list query.
Security Concerns
Dataview: No results to show for list query.
Technical Debt
Dataview: No results to show for list query.
Stub Files Proposed Documents Outdated Documents
Dataview: No results to show for table query.
<br>Note: This page automatically aggregates todos, warnings, and status information from frontmatter metadata across all documentation files. For complete documentation on how to use frontmatter fields (status, tags, todo categories, warning types) and integration with the documentation structure, see cross-reference<a rel="noopener nofollow" class="internal-link" href="development/documentation-structure.html#Frontmatter Metadata" data-href="documentation-structure#Frontmatter Metadata" aria-label="documentation-structure > Frontmatter Metadata" data-tooltip-position="top" target="_self">Frontmatter Metadata Documentation</a>.]]></description><link>development/tasklist.html</link><guid isPermaLink="false">development/tasklist.md</guid><pubDate>Wed, 12 Nov 2025 02:57:10 GMT</pubDate></item><item><title><![CDATA[development]]></title><description><![CDATA[Setup, workflow, and development processes for Reaction v2.
<a class="internal-link" data-href="getting-started.md" href="development/getting-started.html" target="_self" rel="noopener nofollow"><strong></strong></a>Getting Started - Project setup and first build
<br><a class="internal-link" data-href="development-principles.md" href="development/development-principles.html" target="_self" rel="noopener nofollow"><strong></strong></a>Development Principles - Core values and guidelines for contributors
<br><a class="internal-link" data-href="documentation-structure.md" href="development/documentation-structure.html" target="_self" rel="noopener nofollow"><strong></strong></a>Documentation Structure - How to organize and navigate documentation
<br><a class="internal-link" data-href="building-documentation.md" href="development/building-documentation.html" target="_self" rel="noopener nofollow"><strong></strong></a>Building Documentation - Export and deploy documentation to GitHub Pages <br><a class="internal-link" data-href="tasklist.md" href="development/tasklist.html" target="_self" rel="noopener nofollow"><strong></strong></a>Task List - Auto-generated TODO items, warnings, and documentation status
npm install
npm run dev # Development server
npm run test # Test suite npm run build # Production build
npm run lint # ESLint
npm run format # Prettier Core types: src/core/types.ts
Spell types: src/spell-system/types.ts
Documentation: docs/
Architecture: docs/architecture/
<br>See <a class="internal-link" data-href="development-principles.md" href="development/development-principles.html" target="_self" rel="noopener nofollow">Development Principles</a> for core values and <a class="internal-link" data-href="documentation-structure.md" href="development/documentation-structure.html" target="_self" rel="noopener nofollow">Documentation Structure</a> for information organization guidelines.]]></description><link>development/development.html</link><guid isPermaLink="false">development/development.md</guid><pubDate>Wed, 12 Nov 2025 02:56:53 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[Reaction v2 is a complete reimagining of the original Reaction game, featuring GPU-accelerated physics, deterministic gameplay, and a powerful spell crafting system where players cast spells that place magical runes, transforming terrain through physics-based rule systems.We're currently in the architecture design phase, focusing on creating robust system designs before moving to implementation.
Real-time PvP Combat - Fast-paced multiplayer battles on grid-based terrain
Spell Crafting System - Create custom spell combinations using magical runes
Rule-based Physics - Dynamic terrain transformation through deterministic physics
GPU Acceleration - High-performance rendering and physics calculations
Deterministic Gameplay - Consistent game state across all clients for competitive play cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/architecture.html" data-href="architecture/architecture" aria-label="architecture/architecture" data-tooltip-position="top" target="_self">Architecture</a> - System design and technical approach
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="development/development.html" data-href="development/development" aria-label="development/development" data-tooltip-position="top" target="_self">Development</a> - Setup, workflow, and development processes
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="gameplay/gameplay.html" data-href="gameplay/gameplay" aria-label="gameplay/gameplay" data-tooltip-position="top" target="_self">Gameplay</a> - Core game mechanics and design philosophy <br>cross-reference<a rel="noopener nofollow" class="internal-link" href=".html" data-href="legacy/legacy" aria-label="legacy/legacy" data-tooltip-position="top" target="_self">Legacy V1 Analysis</a> - V1 system concepts for V2 development reference <br>Development Setup: See cross-reference<a rel="noopener nofollow" class="internal-link" href="development/getting-started.html" data-href="development/getting-started" aria-label="development/getting-started" data-tooltip-position="top" target="_self">Getting Started Guide</a>
<br>Architecture Overview: Read cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/overview.html" data-href="architecture/general/overview" aria-label="architecture/general/overview" data-tooltip-position="top" target="_self">System Overview</a>
<br>Development Principles: Review cross-reference<a rel="noopener nofollow" class="internal-link" href="development/development-principles.html" data-href="development/development-principles" aria-label="development/development-principles" data-tooltip-position="top" target="_self">Core Principles</a>
npm run dev # Start development server
npm run test # Run test suite
npm run build # Create production build /docs - Documentation source (Markdown)
/src - Source code
/tests - Test suites
/build - Build outputs (gitignored) <br><a data-tooltip-position="top" aria-label="https://github.com/FireToDust/Reaction-Web" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/FireToDust/Reaction-Web" target="_self">GitHub Repository</a>
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="development/building-documentation.html" data-href="development/building-documentation" aria-label="development/building-documentation" data-tooltip-position="top" target="_self">Building Documentation</a>
<br><a data-tooltip-position="top" aria-label="docs" data-href="docs" href="docs.html" class="internal-link" target="_self" rel="noopener nofollow">Full Documentation Index</a>
For detailed documentation, explore the links above or browse the documentation tree.]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Wed, 12 Nov 2025 02:56:29 GMT</pubDate></item><item><title><![CDATA[development-principles]]></title><description><![CDATA[
Never fabricate performance numbers, statistics, or benchmarks
Mark personal ideas as such - don't present speculation as team decisions
Say "I don't know" when you don't know
Uncertainty is better than false confidence Code should explain itself through naming and structure
If you need extensive comments to explain what code does, rewrite it
Magic numbers and unclear constants are tech debt
Optimize for the next person who reads your code Make it easy for others to understand and build on your work
Ask questions when design decisions aren't clear
Share context behind your choices Focus on accomplishing the goal, not just following instructions literally
Understand why you're doing something before deciding how
When updating work, consider what would serve the reader, not just what changed
Question whether existing structure still serves its purpose Use descriptive names for functions, variables, and files
Handle error cases explicitly - don't ignore or hide failures
Prefer simple, obvious solutions over clever optimizations
Document the "why" behind non-obvious business logic Be honest about what's decided vs. what you're proposing
Include enough context for someone to understand and challenge your reasoning
Avoid inventing performance claims or user behavior assumptions
Note when something needs team input or further research Understand the problem before jumping to solutions
Consider the person who will maintain this code in 6 months
Choose consistency with existing patterns over personal preference Don't just replace what changed - step back and ensure the whole section still flows logically
Remove historical context that's no longer relevant to current readers
Fix structural issues or awkward transitions when you encounter them, even if you didn't create them Write clear, descriptive commit messages that explain the "why" not just the "what"
Make atomic commits - each commit should represent one logical change
Never commit broken code or failing tests to main branch
Use branches for feature development and merge via pull requests
Review your own changes before committing - check diffs carefully
Keep commits focused - avoid mixing unrelated changes
Test your changes locally before pushing
Before committing work, ask:
Can someone else understand this without asking me questions?
Am I making any claims I can't back up?
Is this the simplest solution that solves the actual problem?
Have I clearly indicated what needs team discussion?
Are my commit messages clear and descriptive?
Have I tested my changes locally?
The goal is sustainable development where team members can confidently build on each other's work.]]></description><link>development/development-principles.html</link><guid isPermaLink="false">development/development-principles.md</guid><pubDate>Tue, 11 Nov 2025 23:46:20 GMT</pubDate></item><item><title><![CDATA[core-mechanics]]></title><description><![CDATA[Elimination: Last player standing wins. Players are eliminated when their avatar tile is destroyed.Duration: Unlimited match length - games end only when elimination occurs
Player Count: Variable player count, limited only by performance constraints
Real-Time Execution: Continuous simulationExecution Timing: Player actions execute in real-time
Status Effects: Players can be slowed, frozen, or otherwise affected by spells and environmentPlayer → Spell → World → Player: Clear action consequence chain
Player casts spell
Spell affects world tiles and environment
World changes affect all players through environmental interactions
Player Tiles: Players exist as tiles on the object layer
Physics Only: Player avatars affected by physics (velocity, collisions, forces) but never transform into other tile types
Damage System: Players can take damage and be destroyed but maintain their tile type while alive
Movement: Players move using same physics system as other object layer tilesDamage Sources: Tiles can deal damage, apply slow effects, or other status conditions to players
Healing: Either no healing mechanics, or healing through specific terrain tiles
Regeneration Strategy: No health regeneration vs. tile-based healing zones (to be playtested)
Destruction: Players eliminated when health reaches zero, but tile type never changesPhysics-Driven: Maps generated through built-in physics simulation and tile reactions
Emergent Terrain: World evolves naturally through rule-based transformations
Dynamic Environment: Continuous world changes create evolving strategic opportunitiesStrategic Terrain: Different tile types provide tactical advantages and challenges
Reactive Tiles: Special tiles that explode, ignite, or transform when targeted by spells
Environmental Interactions: Terrain affects tactical gameplay
Spell-Terrain Synergy: Spells designed to interact meaningfully with terrain typesSize: To be determined through playtesting for optimal performance and gameplay balance
Performance Scaling: Map size limited by ability to maintain 60 FPS with active player countNo Scarcity: Unlimited mana flower regeneration - focus on timing and positioning over resource conservation
Mana Recharge: Timed recharge cycle provides natural pacing without creating resource pressureTile-Based Escalation: Environmental changes naturally create pressure and opportunities
No Regeneration Alternative: Potential no-healing system to ensure permanent consequences
Environmental Pressure: Reactive terrain and ongoing world changes prevent static positioningBalanced Design: Spells designed for diverse strategies
Situational Advantage: Different spells excel in different terrain and tactical situations
No Power Creep: Focus on interesting combinations rather than raw damage scaling
Terrain Understanding: Learning different tile type behaviors
Spell Combinations: Combining rune effects
Positioning: Tactical movement and area control
Timing: Execution of pre-planned actions at optimal moments
Environmental Prediction: Anticipating world changes and terrain evolution
See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="../architecture/systems/spells/spells" aria-label="../architecture/systems/spells/spells" data-tooltip-position="top" target="_self">Spell System</a> for complete spell mechanics.Element Mastery:
Understanding 26 elements and geometric opposition structure
Recognizing cancellation opportunities (complete, partial, Void)
Defensive counter-element selection against opponents
Resource Management:
Mana flower spending patterns with timed recharge cycles
Action cooldown timing (cast/load/refresh decisions)
Refresh action strategic use (tempo cost for pool cycling)
Deck Construction:
Pre-match element focus vs diverse coverage decisions
Mana flower conversion optimization (2:1 trade-off)
Singleton format encourages spell variety strategies
Tactical Execution:
Slot/pool management (when to cast vs load)
Directional targeting precision
Spell overlap timing for combinations Rule Interactions: Complex behaviors arising from rule combinations
Adaptive Strategy: Changing world state requires flexible tactical adaptation
Risk/Reward: Curse system and aggressive positioning create choices
Long-term Planning: Pre-planning system rewards strategic foresight
Element Counter-Play: Geometric opposition creates natural counter-strategies
]]></description><link>gameplay/core-mechanics.html</link><guid isPermaLink="false">gameplay/core-mechanics.md</guid><pubDate>Tue, 11 Nov 2025 22:32:58 GMT</pubDate></item><item><title><![CDATA[architecture]]></title><description><![CDATA[High-level system design, technical decisions, and performance considerations for Reaction v2.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/overview.html" data-href="overview" aria-label="overview" data-tooltip-position="top" target="_self">System Overview</a> - Complete architectural design and module relationships
<br><a class="internal-link" data-href="general/general.md" href="architecture/general/general.html" target="_self" rel="noopener nofollow"><strong></strong></a>General Architecture - Core architectural concepts and design patterns <br><a class="internal-link" data-href="systems/systems.md" href="architecture/systems/systems.html" target="_self" rel="noopener nofollow"><strong></strong></a>Systems - Individual system modules and implementations
]]></description><link>architecture/architecture.html</link><guid isPermaLink="false">architecture/architecture.md</guid><pubDate>Tue, 11 Nov 2025 22:12:22 GMT</pubDate></item><item><title><![CDATA[docs]]></title><description><![CDATA[Status: 🚧 Stub - This index file needs completionComplete documentation for the Reaction v2 real-time PvP grid-based spellcasting game engine.
<a class="internal-link" data-href="architecture/architecture.md" href="architecture/architecture.html" target="_self" rel="noopener nofollow"><strong></strong></a>Architecture - System design and technical approach
<br><a class="internal-link" data-href="development/development.md" href="development/development.html" target="_self" rel="noopener nofollow"><strong></strong></a>Development - Setup, workflow, and development processes <br><a class="internal-link" data-href="gameplay/gameplay.md" href="gameplay/gameplay.html" target="_self" rel="noopener nofollow"><strong></strong></a>Gameplay - Core game mechanics and design philosophy
TODO: Add quick start section with:
Project setup instructions
First build steps
Development environment configuration
TODO: Add project overview with:
Game concept summary
Technical architecture highlights
Development status and roadmap
🚧 This file is a stub and needs completion]]></description><link>docs.html</link><guid isPermaLink="false">docs.md</guid><pubDate>Tue, 11 Nov 2025 21:24:24 GMT</pubDate></item><item><title><![CDATA[documentation-structure]]></title><description><![CDATA[Documentation should function as a navigational search tree where each level provides just enough information to guide readers to the right destination.Parent nodes are signposts, not encyclopedias
Overview documents help readers navigate to specifics
Include enough detail to make informed navigation choices
Avoid comprehensive coverage at high levels
No redundant information
Each piece of information has one authoritative location
Link to sources rather than copying content
Update links when information moves
Hierarchical information flow
Overview → Category → Implementation Details
General concepts → Specific examples
Architecture → Component details
Overview Documents
List what's covered and where to find it
Provide context for understanding relationships
Include links to detailed documentation
Don't duplicate content from linked pages
Category Documents
Explain concepts specific to that category
Direct readers to implementation details
Show how pieces relate within the category
Link to related categories when relevant
Detail Documents
Contain complete implementation information
Reference but don't duplicate architectural context
Link back to parent concepts when helpful
Focus on specific, actionable content
Top-Down Discovery
Start with high-level goals or concepts
Follow links to increasingly specific information
Each level adds detail without repeating previous levels
Cross-ReferencingThe documentation uses two types of links to distinguish hierarchical structure from references:Regular Links - Use standard wiki-link syntax for direct parent-child relationships:[[child-document|Display Name]]
Cross-Reference Links - Use cross-reference syntax for non-hierarchical links:[cross-reference:: [[other-document|Display Name]]]
When to use cross-reference syntax:
Linking to files that are NOT direct children of the current document
Referencing related concepts at the same level or in different branches
Linking to authoritative sources for shared information
Any link that represents a reference rather than a structural parent-child relationship
Purpose: The cross-reference syntax allows Obsidian's graph view to filter out reference links, displaying only the hierarchical documentation tree structure. This makes it easier to visualize and maintain the documentation organization.Guidelines:
Use regular links to show "this document contains these sub-topics"
Use cross-reference links to show "see this other document for more information"
Avoid circular documentation dependencies regardless of link type
Maintenance
When information changes, update it in one place
Check that navigation paths remain clear
Remove or redirect broken internal links
Ensure new content fits the existing hierarchy
Documentation files use YAML frontmatter to track document status, categorization, and task management. This metadata integrates with Dataview for automated task tracking and status monitoring.Tracks document lifecycle and implementation state:
stub - Placeholder document that needs content
draft - Being actively written, incomplete
proposed - Complete proposal awaiting team approval
approved - Approved design ready for implementation
implemented - Code exists matching this documentation
outdated - Document needs updating to match current state
deprecated - Obsolete but kept for historical reference
Example:---
status: proposed
---
Categorizes document type for filtering and organization:
Navigation - Index, overview, or parent pages
Architecture - System architecture and design
Implementation - Detailed implementation specifications
Reference - API references, data formats, constants
Development - Development process and workflow
Testing - Testing strategies and requirements
Performance - Performance analysis and optimization
Security - Security considerations and requirements
Multiplayer - Multiplayer-specific systems
Legacy - Version 1 reference material
TaskList - Special: automated task aggregator pages
Example:---
tags: - Architecture - Performance
---
Task tracking with subcategories using tagged items. Each todo item can have an optional [category] tag at the start:Categories:
[implementation] - Code needs to be written
[testing] - Tests need to be written
[discussion] - Requires team discussion/decision
[research] - Requires investigation or research
[documentation] - Documentation needs to be written
[review] - Needs code or design review
(no tag) - General uncategorized task
Example:---
todo: - "[implementation] Detailed performance benchmarking of time slice overhead" - "[testing] Cross-platform determinism validation suite" - "[discussion] Optimal slice count (current proposal: 8 slices)" - "[research] Alternative scheduling algorithms" - "[documentation] Complete API reference section" - "General task without category"
---
Tracks concerns, proposals, and issues requiring attention. Each warning can have an optional [type] tag:Types:
[proposed] - Proposed system or architectural decision
[outdated] - Content is outdated and needs updating
[breaking] - Breaking change to existing implementations
[performance] - Performance concern or bottleneck
[security] - Security concern or vulnerability
[debt] - Technical debt that should be addressed
(no tag) - General warning
Example:---
warnings: - "[proposed] Time slice scheduling system enables variable timing" - "[performance] High memory usage with 300 snapshot buffer" - "[breaking] API changes required for state management" - "[debt] Inefficient memory allocation in snapshot system"
---
---
status: proposed
tags: - Architecture - Multiplayer
todo: - "[implementation] Performance benchmarking of snapshot creation" - "[testing] Network bandwidth testing with delta compression" - "[discussion] Snapshot retention policy (current: 5 seconds)"
warnings: - "[proposed] Unified state management serves single and multiplayer" - "[performance] Snapshot creation overhead needs measurement"
---
The subcategorized todo and warning items allow Dataview queries to filter by specific types. See cross-reference<a rel="noopener nofollow" class="internal-link" href="development/tasklist.html" data-href="tasklist" aria-label="tasklist" data-tooltip-position="top" target="_self">Task List</a> for automated queries that collect and organize these items across all documentation.
Use status to track document maturity through its lifecycle
Apply tags for broad categorization (multiple tags allowed)
Subcategorize todo items to help with task filtering and prioritization
Subcategorize warnings to identify types of concerns at a glance
Update status as documents progress from draft → proposed → approved → implemented
Mark documents as outdated when code diverges from documentation
The goal is that readers can efficiently find exactly what they need without encountering duplicate or outdated information.]]></description><link>development/documentation-structure.html</link><guid isPermaLink="false">development/documentation-structure.md</guid><pubDate>Mon, 13 Oct 2025 19:47:30 GMT</pubDate></item><item><title><![CDATA[systems]]></title><description><![CDATA[Navigational document for the systems of Reaction v2.
<a class="internal-link" data-href="spells/spells.md" href="architecture/systems/spells/spells.html" target="_self" rel="noopener nofollow"><strong></strong></a>Spell System - Player spellcasting and mana management
<br><a class="internal-link" data-href="physics/physics.md" href="architecture/systems/physics/physics.html" target="_self" rel="noopener nofollow"><strong></strong></a>Physics Engine - GPU-accelerated movement, collisions, and reactions
<br><a class="internal-link" data-href="rendering/rendering.md" href="architecture/systems/rendering/rendering.html" target="_self" rel="noopener nofollow"><strong></strong></a>Renderer - Visual display and UI rendering
<br><a class="internal-link" data-href="multiplayer/multiplayer.md" href="architecture/systems/multiplayer/multiplayer.html" target="_self" rel="noopener nofollow"><strong></strong></a>Multiplayer - Real-time PvP networking
<br><a class="internal-link" data-href="ui/ui.md" href="architecture/systems/ui/ui.html" target="_self" rel="noopener nofollow"><strong></strong></a>User Interface - Game controls, HUD elements, and player interaction
<br><a class="internal-link" data-href="config/config.md" href="architecture/systems/config/config.html" target="_self" rel="noopener nofollow"><strong></strong></a>Configuration - System settings and runtime parameters
<br><a class="internal-link" data-href="gpu/gpu.md" href="architecture/systems/gpu/gpu.html" target="_self" rel="noopener nofollow"><strong></strong></a>GPU Manager - WebGPU resource management and coordination
]]></description><link>architecture/systems/systems.html</link><guid isPermaLink="false">architecture/systems/systems.md</guid><pubDate>Sat, 08 Nov 2025 05:21:41 GMT</pubDate></item><item><title><![CDATA[determinism]]></title><description><![CDATA[Ensuring reproducible physics simulation for fair PvP gameplay.Identical Inputs → Identical Outputs: Essential for fair PvP gameplay
Cross-Platform Consistency: Same results across different hardware and drivers
Replay Capability: Matches should be perfectly reproducible
Spatial Ordering: Process tiles in strict top-left to bottom-right order
Integer Mathematics: Fixed-point arithmetic prevents floating-point drift Cross-Platform Consistency: Identical results across GPU architectures
Validation Framework: Automated testing for deterministic execution
No Floating-Point Drift: Use integer-only calculations to prevent precision accumulation
Fixed-Point Arithmetic: ⚠️ NEEDS SPECIFICATION - Specific fixed-point formats for velocity and position
Rounding Consistency: Deterministic rounding rules across all calculationsNo Shared State: Tiles don't share mutable state during processing
Atomic Operations: Critical for marking active chunks and activity propagation
Data Races: Prevent concurrent read/write conflicts]]></description><link>architecture/systems/physics/determinism.html</link><guid isPermaLink="false">architecture/systems/physics/determinism.md</guid><pubDate>Fri, 07 Nov 2025 00:58:21 GMT</pubDate></item><item><title><![CDATA[gpu-shaders]]></title><description><![CDATA[Multi-pass GPU compute pipeline for force-based physics with combination mechanics on a hexagonal grid.The physics system uses a sequence of GPU compute passes to update object positions and handle combinations:
Apply Forces + Move: Calculate and apply all forces, update velocities and sub-grid offsets
Overlap Passes (2-N): Detect and merge objects that are too close
Set Grid Position: Update hex cell assignments based on final offsets
Purpose: Apply collision, cohesion, and spell forces; update velocity and sub-grid offset.Grid Position Preserved: Objects remain in their current hex cell until final pass.Neighbor Range: Check two-layer hexagonal neighborhood for force interactions.@compute @workgroup_size(8, 8)
fn apply_forces_and_move( @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;, @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;
) { let hex_coord = calculate_hex_coord(global_id); let object = read_object(hex_coord); if (!object.exists) { return; } // Load two-layer hex neighborhood into shared memory load_hex_neighborhood_to_cache(hex_coord, local_id); workgroupBarrier(); // Accumulate forces from neighbors var total_force = vec2&lt;i32&gt;(0, 0); // Fixed-point // Collision forces (from overlapping objects) total_force += calculate_collision_forces(object, neighborhood_cache); // Cohesion forces (from nearby objects within radius) total_force += calculate_cohesion_forces(object, neighborhood_cache); // Spell forces (from overlapping spell shapes) total_force += calculate_spell_forces(object, spell_buffer); // Update velocity (F = ma, so a = F/m) let acceleration = fixed_point_divide(total_force, object.mass); object.velocity = fixed_point_add(object.velocity, acceleration); // Clamp velocity to maximum object.velocity = clamp_velocity(object.velocity, MAX_VELOCITY); // Update sub-grid offset (don't change hex cell assignment yet) object.offset = fixed_point_add(object.offset, object.velocity); write_object(hex_coord, object);
}
Collision Forces: For each overlapping neighbor, calculate repulsion force based on overlap distance and mass.Cohesion Forces: For neighbors within cohesion radius, calculate attraction force toward group centroid.Spell Forces: Check spell buffer for overlapping spell shapes; apply impulses or set velocities based on element type.Details: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/forces.html" data-href="forces" aria-label="forces" data-tooltip-position="top" target="_self">Forces</a> for force formulas and mechanics.Purpose: Detect objects closer than combination distance d; merge them into single objects.Scatter-Gather: Complex algorithm to identify and merge groups of nearby objects.Multiple Passes: May require several passes to fully resolve cascading combinations.⚠️ NEEDS SPECIFICATION: Exact scatter-gather implementation approach TBD.@compute @workgroup_size(8, 8)
fn overlap_detection_pass( @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;, @builtin(local_invocation_id) local_id: vec3&lt;u32&gt;
) { let hex_coord = calculate_hex_coord(global_id); let object = read_object(hex_coord); if (!object.exists) { return; } // Load two-layer hex neighborhood load_hex_neighborhood_to_cache(hex_coord, local_id); workgroupBarrier(); // Find all objects within combination distance d var nearby_objects = find_objects_within_distance(object, neighborhood_cache, COMBINATION_DISTANCE); if (nearby_objects.count &gt; 0) { // Mark for combination // TODO: Implement scatter-gather algorithm // - Assign combination group ID // - Calculate combined properties (mass-averaged velocity, centroid position) // - Apply reaction rules for type transformation // - Write combined object, mark merged objects for deletion }
}
Distance Check: Calculate distance between object centers; trigger if &lt; d.Group Formation: All objects within d of combined center merge together.Property Calculation:
Velocity: Mass-weighted average of all merged objects
Position: Mass-weighted centroid
<br>Type: Determined by reaction rules (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="reactions" aria-label="reactions" data-tooltip-position="top" target="_self">Reaction System</a>)
Mass: Based on new type
Atomic Operations: Use atomics to prevent race conditions when multiple groups overlap.Purpose: Update which hex cell each object occupies based on its final sub-grid offset.Boundary Wrapping: Handle objects that have moved across world edges.Spatial Indexing: Ensure objects are correctly indexed for next frame's neighbor queries.@compute @workgroup_size(8, 8)
fn set_grid_position( @builtin(global_invocation_id) global_id: vec3&lt;u32&gt;
) { let hex_coord = calculate_hex_coord(global_id); let object = read_object(hex_coord); if (!object.exists) { return; } // Calculate new hex cell based on offset let new_hex_coord = calculate_hex_from_offset(hex_coord, object.offset); // Normalize offset relative to new cell center let normalized_offset = normalize_offset_to_cell(object.offset, new_hex_coord); // Handle world wrapping let wrapped_coord = wrap_hex_coordinate(new_hex_coord); if (wrapped_coord != hex_coord) { // Object moved to new cell - relocate it object.offset = normalized_offset; atomic_write_object(wrapped_coord, object); delete_object(hex_coord); } else { // Object stayed in same cell - just update offset object.offset = normalized_offset; write_object(hex_coord, object); }
}
Coordinate System: Use cube coordinates (q, r, s) where q + r + s = 0.Neighbor Lookup: Efficient neighbor calculation using coordinate offsets.Point-to-Hex: Convert Cartesian (x, y) position to hex coordinates using cube algorithm.GPU Layout: Grid stored as skewed parallelogram in texture memory.Rectangular Indexing: Standard 2D texture coordinates map to hex cells.Wrapped Boundaries: World edges wrap seamlessly for continuous circular world.Layer Definition: Objects check 19 hex cells (center + 6 immediate + 12 second-layer).Shared Memory Size: 19 objects fit efficiently in workgroup shared memory.Coordinate Calculation: Precompute neighbor offsets for each hex layer.Purpose: Load neighborhood data once per workgroup to minimize texture reads.Cache Size: 19 hex cells × object data size (position, velocity, type, mass).Synchronization: Workgroup barriers ensure all threads see cached data.// Workgroup shared memory for hex neighborhood
var&lt;workgroup&gt; neighborhood_cache: array&lt;ObjectData, 19&gt;;
var&lt;workgroup&gt; cache_loaded: bool; fn load_hex_neighborhood_to_cache( center_hex: vec2&lt;i32&gt;, local_id: vec3&lt;u32&gt;
) { // First thread loads all 19 neighbors if (local_id.x == 0 &amp;&amp; local_id.y == 0) { for (var i = 0; i &lt; 19; i++) { let neighbor_hex = center_hex + HEX_NEIGHBOR_OFFSETS[i]; neighborhood_cache[i] = read_object(neighbor_hex); } cache_loaded = true; }
}
Current Choice: 8×8 workgroups (64 threads).Rationale: Balance between GPU occupancy and shared memory usage.⚠️ NEEDS TUNING: Optimal workgroup size TBD through GPU profiling.GPU Texture Layout:struct ObjectData { // Position (12 bytes) hex_coord: vec2&lt;i32&gt;, // 8 bytes - hex cell coordinates offset: vec2&lt;i32&gt;, // 8 bytes - fixed-point offset from cell center // Velocity (8 bytes) velocity: vec2&lt;i32&gt;, // 8 bytes - fixed-point velocity vector // Properties (8 bytes) type_id: u32, // 4 bytes - object type mass: u32, // 4 bytes - mass (or could be computed from type) // Flags (4 bytes) layer: u32, // 4 bytes - Ground/Object/Air (could be packed) exists: bool, // 1 byte - object exists flag // ... potential padding or additional flags
}
// Total: ~32 bytes per object (may be optimized with bit-packing)
Memory Packing: Consider bit-packing to reduce texture memory and bandwidth.Structure: Array of active spell shapes in GPU buffer.Data Per Spell:
Shape geometry (circle, rectangle, etc.)
Position and radius
Element type(s)
Cast time (for element combination ordering)
Force magnitude/velocity value
Spatial Partitioning: Future optimization to limit spell checks per object.Integer-Only Operations: All physics calculations use fixed-point (scaled integers).Platform Independence: Avoids floating-point precision differences across GPUs.Bit Precision: Balance accuracy vs overflow risk (e.g., 16.16 fixed-point).<br>Details: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/determinism.html" data-href="determinism" aria-label="determinism" data-tooltip-position="top" target="_self">Determinism</a> for implementation.// Fixed-point addition (trivial)
fn fixed_point_add(a: vec2&lt;i32&gt;, b: vec2&lt;i32&gt;) -&gt; vec2&lt;i32&gt; { return a + b;
} // Fixed-point multiplication (scale factor = 2^16)
fn fixed_point_multiply(a: i32, b: i32) -&gt; i32 { return (i64(a) * i64(b)) &gt;&gt; 16;
} // Fixed-point division
fn fixed_point_divide(numerator: i32, denominator: i32) -&gt; i32 { return (i64(numerator) &lt;&lt; 16) / i64(denominator);
}
Stationary Objects: Skip force calculations for objects with zero velocity and no nearby activity.Convergence Detection: In overlap passes, terminate early if no combinations triggered.Pass Skipping: Skip remaining overlap passes once no objects need merging.Coalesced Access: Threads in workgroup access contiguous memory locations.Texture Cache: Structure data layout for optimal GPU cache utilization.Bit-Packing: Compress object data to minimize texture memory bandwidth.Combination Conflicts: Use atomic operations when multiple objects try to merge.Cell Relocation: Atomic writes when moving objects to new hex cells.Flag Updates: Atomic flags for convergence detection across workgroups.
Pipeline implements movement, velocity, and combination mechanics
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/movement-system.html" data-href="movement-system" aria-label="movement-system" data-tooltip-position="top" target="_self">Movement System</a> for conceptual details Force calculation details and formulas
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/forces.html" data-href="forces" aria-label="forces" data-tooltip-position="top" target="_self">Forces</a> for force types and equations Spell buffer provides force input
Objects check for overlapping spell shapes
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a> for spell mechanics Combination type transformations use reaction rules
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="reactions" aria-label="reactions" data-tooltip-position="top" target="_self">Reaction System</a> for transformation rules
Language: WebGPU Shading Language (WGSL).Compilation: Shaders compiled at runtime by WebGPU driver.Validation: Browser provides shader compilation errors during development.Development Mode: Support shader hot-reloading for rapid iteration.Error Handling: Graceful fallback when shader compilation fails.Debugging: Use browser GPU debugging tools for shader profiling.GPU Timers: Measure individual pass execution times.Bandwidth Monitoring: Track texture read/write operations.Workgroup Tuning: Profile different workgroup sizes for optimal performance.]]></description><link>architecture/systems/physics/gpu-shaders.html</link><guid isPermaLink="false">architecture/systems/physics/gpu-shaders.md</guid><pubDate>Fri, 07 Nov 2025 00:53:58 GMT</pubDate></item><item><title><![CDATA[forces]]></title><description><![CDATA[Force mechanics for collision repulsion, cohesion attraction, and spell-driven movement.Forces modify object velocities each frame, creating realistic physics interactions. All forces operate within the two-layer hexagonal neighborhood range, ensuring objects can respond before collisions become problematic.Coverage: Objects check two layers of surrounding hexagons for force interactions.Maximum Range: All forces operate within sqrt(7)d/2 - d distance limit, where d is the hex cell size.Range Guarantee: Two hex layers provide sufficient coverage for all force interactions given speed limits (~9.69 cells/second max).Efficiency: Neighbor checking limited to necessary range reduces computation.Polar Coordinates: Use polar/cube coordinate system for efficient neighbor queries.Wrapped Boundaries: Handle world wrapping when checking neighbors near edges.Layer Order: Process neighbors in consistent order for deterministic results.Overlap Resolution: Push objects apart when they overlap to prevent interpenetration.Continuous Application: Forces applied every frame while objects remain overlapping.Mass-Based Response: Force produces different accelerations based on object mass.Repulsion: Objects push apart when overlapping, with force directed away from collision point.Overlap-Based Magnitude: Force magnitude increases with overlap amount.Mass Influence: Force applied to both objects, with acceleration inversely proportional to mass (F = ma).Breaking Threshold: High overlap triggers combination mechanic instead of force (when distance &lt; d).⚠️ NEEDS SPECIFICATION: Exact collision force formula TBD through playtesting.Considerations:
Linear vs non-linear force scaling with overlap distance
Force strength calibration for gameplay feel
Balance between collision response and combination trigger
Interaction with cohesion forces
Gap Closure: Automatically close gaps between objects for natural density management.Clustering: Maintain dense object coverage without rigid grid constraints.Breaking Force: Allow high-velocity impacts to overcome cohesion and create temporary gaps.Attraction: Objects within cohesion radius pull toward each other.Density Management: Prevents permanent gaps in object field while allowing dynamic separation.Gameplay Interaction: Creates emergent behavior where objects naturally cluster unless disrupted.⚠️ NEEDS SPECIFICATION: Exact cohesion force formula and radius TBD through playtesting.Considerations:
Cohesion radius (likely smaller than two-layer range)
Force strength relative to collision forces
Linear vs clamped force falloff with distance
Centroid vs pairwise attraction
Impulse Elements: Some spell elements apply instantaneous velocity changes (impulses).Velocity-Setting Elements: Other spell elements directly set object velocities to specific values.Element Determination: Spell element type determines force application method.⚠️ NEEDS SPECIFICATION: Mapping of spell elements to force types TBD through spell system design.Buffer Lookup: Objects check spell buffer for active spell shapes.Overlap Detection: Determine which spell shapes overlap the object's center point.Multiple Spells: Objects can be affected by multiple overlapping spell shapes.Combination Order: When multiple spells overlap, combine elements by cast time order (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a>).Impulse Method: Add velocity delta to current velocity (Δv applied once per spell contact).Velocity-Set Method: Directly replace velocity with spell-specified value.Mass Independence: Spell forces may ignore mass (TBD through spell design).<br>Details: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a> for spell shape mechanics and element combination rules.Force Sources: Each frame, objects accumulate forces from:
Collision forces (from overlapping objects)
Cohesion forces (from nearby objects within radius)
Spell forces (from overlapping spell shapes)
Summation: Forces summed using vector addition.Velocity Update: Net force applied to update velocity: v_new = v_old + (F_total / mass) * dtPosition Update: Updated velocity used to modify sub-grid offset.Determinism: All force calculations use fixed-point arithmetic for platform-independent results.Precision: Bit precision chosen to balance accuracy and GPU texture storage.Overflow Prevention: Force magnitudes clamped to prevent fixed-point overflow.<br>Details: See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/determinism.html" data-href="determinism" aria-label="determinism" data-tooltip-position="top" target="_self">Determinism</a> for fixed-point implementation.
Forces modify object velocities each frame
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/movement-system.html" data-href="movement-system" aria-label="movement-system" data-tooltip-position="top" target="_self">Movement System</a> for velocity and mass details Force calculations performed in "Apply Forces + Move" pass
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/gpu-shaders.html" data-href="gpu-shaders" aria-label="gpu-shaders" data-tooltip-position="top" target="_self">GPU Shaders</a> for pipeline details Spell shapes provide force input from buffer
Element types determine force application method
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a> for spell mechanics
Collision vs Cohesion: Collision forces must overcome cohesion to allow object separation.Spell Dominance: Spell forces should be noticeable over ambient collision/cohesion forces.Combination Threshold: Objects approaching distance d should combine rather than bounce indefinitely.Playtesting Required: Force formulas will be refined through gameplay iteration.Adjustable Parameters: Force strengths and radii exposed as configuration values.Element Variation: Different spell elements may use different force strengths/types.Neighbor Limits: Two-layer range constraint keeps force calculations bounded.Parallel Computation: Force calculations fully parallelizable across objects in GPU.Early Termination: Skip force calculations for stationary objects with no nearby activity.]]></description><link>architecture/systems/physics/forces.html</link><guid isPermaLink="false">architecture/systems/physics/forces.md</guid><pubDate>Fri, 07 Nov 2025 00:52:42 GMT</pubDate></item><item><title><![CDATA[movement-system]]></title><description><![CDATA[Hexagonal grid with sub-grid positioning, velocity management, mass-based interactions, and combination mechanics.Objects move freely on a hexagonal grid using sub-grid offsets and persistent velocities. The combination mechanic merges objects that get too close, maintaining the one-object-per-cell guarantee while enabling dynamic physics interactions.Hex Cell Size: Corner-to-corner distance d chosen to equal the minimum combination distance.One-Per-Cell Guarantee: Cell size ensures no two objects can occupy the same cell, even during mid-movement.Polar Coordinates: Grid uses polar/cube coordinate system for neighbor lookup and point-to-hex conversion.GPU Storage: Grid stored as skewed parallelogram with wrapped boundaries, enabling rectangular indexing.World Wrapping: Objects at world edges wrap to opposite side for continuous circular world.Offset Storage: Each object stores precise x,y offsets from its hex cell center using fixed-point arithmetic.Unconstrained Movement: Objects can move freely in any direction based on applied forces.Precision: Fixed-point representation ensures deterministic positioning across platforms.Cell Assignment: Objects remain assigned to their current hex cell until the final "set grid position" pass.Vector Representation: Two-component velocity (x,y) stored with fixed-point precision.Texture Storage: Velocities stored in GPU textures alongside position data.Deterministic Updates: All velocity changes use fixed-point arithmetic.Frame Persistence: Velocity persists frame-to-frame unless modified by forces.Applied Forces: Collision, cohesion, and spell forces modify velocity each frame (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/forces.html" data-href="forces" aria-label="forces" data-tooltip-position="top" target="_self">Forces</a>).Spell Inputs: Spell elements can apply impulses or directly set velocities.Combinations: Merged objects receive mass-averaged velocity.Damping: Optional velocity damping to prevent perpetual motion (TBD through playtesting).Maximum Velocity: ~9.69 hex cells/second at 60fps based on two-layer force range guarantee.Gameplay Range: Typical gameplay velocities 2-6 cells/second, providing margin for force application.Range Guarantee: Two hex layers sufficient for all force interactions within speed limits.Type-Based: Each object type has an associated mass value.Layer Variation: Different layers may have different mass ranges (e.g., ground heavier than air).Gameplay Impact: Mass affects force response and combination outcomes.⚠️ NEEDS SPECIFICATION: Specific mass values for object types TBD through gameplay balancing.Force Response: Heavier objects accelerate less from the same applied force (F = ma).Collision Interaction: Mass ratio between colliding objects affects their relative force responses.Combination Averaging: When objects combine, velocities are mass-averaged to conserve momentum.Conservation: Total momentum preserved during combinations: m1*v1 + m2*v2 = m_combined * v_combinedOne-Per-Cell Guarantee: Ensures no hex cell ever contains more than one object.Gameplay Feature: Creates dynamic object fusion and reaction chains.Physics Stability: Prevents infinite force application from perpetually overlapping objects.Distance Threshold: Combination triggered when two objects approach closer than distance d.Merge Radius: All objects with centers within d of the combined center are included in the merge.Multi-Object Merges: Single combination can merge 3+ objects if they're all within radius.Velocity Averaging: Combined velocity is mass-weighted average of all merged objects.<br>Type Transformation: New object type determined by reaction rules applied to merged objects (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="reactions" aria-label="reactions" data-tooltip-position="top" target="_self">Reaction System</a>).Mass Assignment: New object mass based on its transformed type.Position: Combined object placed at mass-weighted centroid of merged objects.Position:
Hex cell coordinates (using polar/cube system)
Fixed-point offset (x,y) from cell center
Velocity:
Fixed-point vector (x,y)
Stored in GPU texture alongside position
Properties:
Object type ID (for mass lookup and reactions)
Mass value (may be stored or computed from type)
Layer assignment (Ground/Object/Air)
Texture Layout: Data packed efficiently for GPU texture storage and access patterns.
Velocity modified by forces each frame
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/forces.html" data-href="forces" aria-label="forces" data-tooltip-position="top" target="_self">Forces</a> for force types and calculations Movement calculations performed in GPU compute shaders
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/gpu-shaders.html" data-href="gpu-shaders" aria-label="gpu-shaders" data-tooltip-position="top" target="_self">GPU Shaders</a> for pipeline details Objects check spell buffer for overlapping spell shapes
Spell elements determine force application method
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells.html" data-href="spells" aria-label="spells" data-tooltip-position="top" target="_self">Spell System</a> for spell mechanics Combination types determined by reaction rules
New object mass based on reaction-determined type
<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/physics/reactions.html" data-href="reactions" aria-label="reactions" data-tooltip-position="top" target="_self">Reaction System</a> for transformation rules Sub-grid offsets provide precise visual positioning
Velocities available for motion blur and particle effects Ground Layer: Terrain foundation (dirt, stone, water)
Object Layer: Interactive entities (rocks, trees, creatures, players)
Air Layer: Gases and effects (fire, smoke, magic)
]]></description><link>architecture/systems/physics/movement-system.html</link><guid isPermaLink="false">architecture/systems/physics/movement-system.md</guid><pubDate>Fri, 07 Nov 2025 00:51:51 GMT</pubDate></item><item><title><![CDATA[cpu-architecture]]></title><description><![CDATA[⚠️ DEPRECATED: This document describes a CPU-based spell system that was not implemented.The spell system is now fully GPU-accelerated. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells-and-runes.html" data-href="spells-and-runes" aria-label="spells-and-runes" data-tooltip-position="top" target="_self">Spells and Runes</a> for current architecture.GPU Processing:
Shape evaluation (compute shaders)
Element combination (shader computation)
Rune delay countdown (GPU texture counters)
Rune triggering and cleanup (multi-pass shaders)
This document originally explored CPU-based spell processing for flexibility and ease of debugging. The decision was later revised to use GPU processing for consistency with physics and reaction systems, better performance at scale, and deterministic parallel evaluation.]]></description><link>architecture/systems/spells/cpu-architecture.html</link><guid isPermaLink="false">architecture/systems/spells/cpu-architecture.md</guid><pubDate>Wed, 15 Oct 2025 00:03:58 GMT</pubDate></item><item><title><![CDATA[customization]]></title><description><![CDATA[Player customization through deck building and optional curse mechanics.Deck building is the primary customization system. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/deck-building.html" data-href="deck-building" aria-label="deck-building" data-tooltip-position="top" target="_self">Deck Building</a> for complete rules.Key Decisions:
Spell selection from collection
<br>Mana flower conversion to match deck composition (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a>)
Element focus vs diverse coverage
⚠️ NEEDS DESIGN: Curse system implementation details TBD.Risk/Reward: Cursed builds offer advantages with meaningful drawbacksOptional: Curses are optional - pure builds remain viableBuild Diversity: Support multiple viable build approaches⚠️ NEEDS SPECIFICATION:
Curse selection mechanics
Stacking rules (can multiple curses be combined?)
Activation conditions and triggers
Balancing approach between pure and cursed builds
Integration with deck building and flower conversion
]]></description><link>architecture/systems/spells/customization.html</link><guid isPermaLink="false">architecture/systems/spells/customization.md</guid><pubDate>Wed, 15 Oct 2025 00:03:53 GMT</pubDate></item><item><title><![CDATA[deck-building]]></title><description><![CDATA[Pre-match deck construction with singleton format, infinite reshuffle, and mana flower conversion.Minimum Size: 6 × number of casting pools
Example: 4 pools requires minimum 24 spells
Ensures sufficient variety for pool cycling
Singleton Format: No duplicate spells
Maximum 1 copy of each spell in deck
Prevents single-spell spam strategies
Maximum Size: ⚠️ NEEDS DISCUSSION - Should there be a deck size cap?Infinite Reshuffle: Deck never depletes
Automatically reshuffles when exhausted
All spells remain available throughout match
Timing: Deck built before match starts in pre-game lobbyConstruction Steps:
Select spells from player's collection
Configure mana flower conversion (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a>)
Validate deck meets minimum size
Enter match with finalized configuration
Immutable: Deck and flower configuration cannot change during match<br>Flower conversion details in cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/mana-system.html" data-href="mana-system" aria-label="mana-system" data-tooltip-position="top" target="_self">Mana System</a>.Mechanic: Lose 2 flowers → gain 1 flower of chosen typePurpose: Specialize flower distribution to match deck's element compositionTrade-off: More specialized casting capability at cost of total flower capacityExamples:
Fire-focused deck: Convert toward Chaos/Creation flowers
Balanced deck: Use default 3-3-3-3-3-3 allocation
<br>Element Access: All 26 elements accessible from game start (see cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>)
No progression gate on element types
Base, dual, and triple elements all available
Spell Acquisition: ⚠️ NEEDS DESIGN - How players acquire spells for collection
Spells are collectible (specific system TBD)
Element availability ≠ spell availability
Strategic depth from spell variety, not element unlocks
]]></description><link>architecture/systems/spells/deck-building.html</link><guid isPermaLink="false">architecture/systems/spells/deck-building.md</guid><pubDate>Tue, 14 Oct 2025 23:57:55 GMT</pubDate></item><item><title><![CDATA[mana-system]]></title><description><![CDATA[Resource economy based on 6 elemental flower types with individual flower tracking and strategic conversion mechanics.6 Base Element Flowers: Each flower type corresponds to a base element from cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a>:
Order Flowers
Chaos Flowers
Creation Flowers
Destruction Flowers
Spirit Flowers
Form Flowers
Default Allocation: 3 of each type (18 total)Individual Tracking: Each flower has independent recharge state and cooldown.Duration: 3 turns per flowerIndividual Cooldowns: Each flower tracks its own timer independently.Recharge Behavior:
✅ Cast spell: Flowers recharge normally
✅ Load spell: Flowers recharge normally
✅ Movement: Flowers recharge normally
❌ Refresh pools: Flowers do NOT recharge (strategic penalty)
Unlimited Regeneration: Flowers always regenerate. Never permanently lost during match.Flexible Costs: Spells require specific combinations and quantities of flower types.Examples:
Basic Fire spell: 1 Chaos + 1 Creation
Powerful Fire spell: 3 Chaos + 2 Creation
Life spell: 1 Order + 1 Creation + 1 Spirit
Validation: All required flowers must be available (not recharging) to cast spell.Cost-Power Relationship: Higher costs = more powerful spells. Specific costs TBD through playtesting.When: During deck building phase (before match starts)Operation: Lose 2 flowers → gain 1 flower of chosen typeIrreversible: Conversion affects starting flower configuration for that match.Purpose: Specialize flower distribution to match deck element composition.Trade-off: Increased element focus at cost of total capacity and flexibility.<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/element-system.html" data-href="element-system" aria-label="element-system" data-tooltip-position="top" target="_self">Element System</a> - Spell costs require combinations matching element structure (dual elements = 2 flower types, triple elements = 3 flower types)<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/spells-and-runes.html" data-href="spells-and-runes" aria-label="spells-and-runes" data-tooltip-position="top" target="_self">Spells and Runes</a> - Refresh action uniquely prevents flower recharge during cooldown<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/spells/deck-building.html" data-href="deck-building" aria-label="deck-building" data-tooltip-position="top" target="_self">Deck Building</a> - Flower conversion configured during deck construction]]></description><link>architecture/systems/spells/mana-system.html</link><guid isPermaLink="false">architecture/systems/spells/mana-system.md</guid><pubDate>Tue, 14 Oct 2025 23:57:10 GMT</pubDate></item><item><title><![CDATA[overview]]></title><description><![CDATA[Reaction is a real-time PvP game where players cast spells that place magical runes on a grid. These runes transform the terrain according to rule-based systems.The core technical challenge: simulate thousands of interacting tiles at 60 FPS while allowing complex spell interactions that feel responsive and fair.Performance Goal: High performance with many active tilesDeterminism: Identical inputs produce identical outputs (essential for fair PvP)Responsiveness: Spell casting feels immediate despite complex backend processingExtensibility: New spells and tile interactions can be added without engine rewritesThe system separates concerns into focused, loosely-coupled modules:Purpose: Central coordination and tile data management.Responsibilities:
Bit-packed tile storage across 4 layers (Ground, Object, Air, Rune)
GPU texture management with ping-ponging (enables GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards) for race-condition prevention
Active region optimization (32×32 chunks - chosen to balance GPU workgroup efficiency with memory overhead) ⚠️ NOT IMPLEMENTED: Active region optimization was decided against
Frame execution pipeline coordination
Dependencies: WebGPU APIPurpose: GPU-accelerated player-controlled spellcasting with geometric element system.Responsibilities:
26-element system (cube/octahedron structure) with component-level cancellation
6-flower mana economy (individual tracking, 3-turn recharge, 2:1 conversion)
Slot/pool casting interface (cast/load/refresh actions with universal cooldown)
Abstract spell shapes (geometric primitives evaluated in GPU shaders)
Rune lifecycle (GPU delay counters, triggering, combination, cleanup)
Deck building (singleton format, infinite reshuffle, minimum size 6×pools)
Curse system (TBD)
Dependencies: Core Engine (rune layer texture), Physics Engine (force application)Processing: GPU compute shaders for shape evaluation, element combination, and rune lifecyclePurpose: GPU-accelerated tile movement and collision simulation.Responsibilities:
Free-form movement with fixed-precision Vector2 velocities
Mass-based collision physics with momentum transfer
Cohesion forces for natural tile clustering (1.5 block radius, 5×5 neighborhood)
Multi-pass collision resolution for deterministic results
Sub-grid positioning with integer fixed-point arithmetic
Layer interaction physics (falling, bouncing)
Dependencies: Core Engine (texture coordination)Processing: GPU compute shaders with hardcoded physics rulesNote: Frame rate coordination approach proposed in cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">data-flow.md</a> - implementation and effectiveness TBD ⚠️ data-flow.md is outdatedPurpose: Rule-based environmental transformations.Responsibilities:
JSON rule compilation to optimized GPU shaders
Competitive rule scoring and execution
Environmental pattern matching (fire spreading, etc.)
Optimization pipeline (specific implementation TBD)
Dependencies: Core Engine (texture access), Build toolchainProcessing: GPU compute shaders with compiled rulesNote: The rule compilation pipeline allows simple code generation with sophisticated optimization. Alternative approaches welcome if simpler.Purpose: Visual display and user interface.Responsibilities:
Multi-layer world rendering
UI elements (mana flowers, spell hand)
Visual effects and animations
Camera and viewport management
Dependencies: Core Engine (tile data access)Processing: GPU rendering pipelinePurpose: Development and debugging utilities.Responsibilities:
Visual rule editor with grid-based interface
Debug overlays and tile inspection
Performance profiling and rule tracing
Asset validation and testing tools
Dependencies: All modules (for debugging access)<br>⚠️ PROPOSED ARCHITECTURE: A Deterministic Time-Sliced Execution approach has been proposed for variable timing and multiplayer synchronization. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">data-flow.md</a> for proposed pipeline details - implementation and validation TBD.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href=".html" data-href="tile-storage" aria-label="tile-storage" data-tooltip-position="top" target="_self">tile-storage.md</a> for complete tile format and layer architecture details. Specific bit allocation TBD during implementation.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/performance.html" data-href="performance" aria-label="performance" data-tooltip-position="top" target="_self">performance.md</a> and individual system documentation for specific optimization strategies.<br>See cross-reference<a rel="noopener nofollow" class="internal-link" href="gameplay/gameplay.html" data-href="gameplay" aria-label="gameplay" data-tooltip-position="top" target="_self">gameplay mechanics</a> for complete gameplay mechanics and customization systems.
Visual Editor: Grid-based rule design interface
JSON Export: Human-readable rule definitions
Compilation: Automatic shader generation and optimization
Testing: Live rule testing and validation
Integration: Hot-reload in development builds Tile Inspector: Real-time tile data examination
Rule Tracer: Understand why specific rules activated
Performance Overlay: Monitor frame timing and bottlenecks
Determinism Validation: Verify identical execution across runs
Tile Types: ~64 per layer (chosen to be comfortably under realistic limits)World Size: Fixed at initialization (no dynamic streaming)Flower Types: 6 (matching base elements)Casting Slots/Pools: Count TBD through playtesting (using 4 as example)Performance Degradation: Automated benchmarks prevent optimization regressionsRule Complexity: Visual editor prevents impossible shader compilationDeterminism: Strict execution ordering and integer-only mathematicsToolchain Stability: Containerized build environment for consistent results]]></description><link>architecture/general/overview.html</link><guid isPermaLink="false">architecture/general/overview.md</guid><pubDate>Tue, 14 Oct 2025 23:52:30 GMT</pubDate></item><item><title><![CDATA[technical-decisions]]></title><description><![CDATA[Design choices, rationale, and alternative approaches considered during Reaction v2 architecture.Decision: Separate concerns into focused, loosely-coupled modules
Rationale: Enables independent development and testing of complex systems
Alternative Considered: Monolithic architecture - rejected for maintainability concernsDecision: WebGPU-based processing for physics, reactions, and rendering
Rationale: Required performance for thousands of interacting tiles at 60 FPS
Trade-offs: Added complexity vs. performance requirementsSpell System: GPU compute shaders for shape evaluation, element combination, and rune lifecycle
Rationale: Consistency with physics/reaction systems, parallel evaluation, deterministic combination results
Alternative Considered: CPU processing - rejected for performance at scale and system consistencyPhysics Engine: GPU compute shaders with hardcoded physics rules
Rationale: High parallelization needs for tile movement and collision detection
Update: Physics now includes mass-based collisions with momentum transfer for realistic tile interactionsReaction Engine: GPU compute shaders with compiled rules
Rationale: Complex rule evaluation benefits from parallel processingDecision: Input → Physics → Runes → Reactions → Render
Rationale: Ensures deterministic execution and proper data dependencies
⚠️ UNSOLVED: Timing coordination between systems at different frequenciesDecision: Simultaneous single-read/single-write GPU passes with deterministic internal rules
Rationale: Achieves determinism without complex spatial ordering or thread synchronization
Alternatives Considered: Spatial ordering strategy - rejected for complexityDecision: 32-bit integers with packed tile data
Rationale: GPU cache efficiency and memory bandwidth optimization
⚠️ NOTE: Specific bit allocation TBD during implementation. See <a class="internal-link" data-href="../systems/core-engine/tile-storage.md" href=".html" target="_self" rel="noopener nofollow">tile-storage.md</a> for current architectural approach.Decision: Ground, Object, Air, Rune layers
Rationale: Clean separation of different tile behaviors and interactions
Alternative Considered: Single layer with type flags - rejected for complexityDecision: Dual texture approach for each layer
Rationale: Prevents GPU read-after-write hazards and race conditions
Trade-off: Double memory usage for synchronization safetyDecision: NOT IMPLEMENTING active region optimization
Rationale: Implementation deemed too complex for expected benefit; planning for relatively few dormant areas in game design
Alternative Sizes Considered: 32×32 tile chunks were originally proposed to balance GPU workgroup efficiency with memory overhead
Status: All 32×32 chunk references throughout documentation are now outdatedDecision: JSON rules → GPU shaders via offline compilation
Rationale: Move computational work to build time for runtime performance
⚠️ NOTE: Alternative approaches may be considered during implementationDecision: 26 elements organized in cube/octahedron geometric structure
Rationale: Intuitive geometric opposition creates natural counter-play, component-level cancellation enables emergent combinations
Structure: 6 base + 12 dual + 8 triple elements
Alternative Considered: Smaller element set - rejected for strategic depthDecision: N slots + N pools system with three player actions (cast/load/refresh)
Rationale: Creates meaningful decisions between immediate casting and deck cycling
Trade-offs: Refresh action uniquely prevents flower recharge (strategic cost)
Alternative Considered: Traditional hand system - rejected for limited strategic depthDecision: Abstract geometric primitives evaluated at runtime in GPU shaders
Rationale: Perfect rotational symmetry, minimal memory, flexible design
Alternative Considered: Pre-rendered texture system - rejected for memory cost and symmetry concernsDecision: Singleton format (no duplicates) with infinite reshuffle
Rationale: Encourages spell variety, prevents deck depletion strategies
Minimum Size: 6 × number of pools ensures sufficient variety
Alternative Considered: Duplicate limits with deck depletion - rejected for complexityDecision: 6 flower types matching base elements with 3-turn recharge cycle
Rationale: Direct correspondence with element system, individual tracking enables strategic timing
Default Allocation: 3 of each type (18 total), unlimited regeneration
Alternative Considered: 4-element system (fire/water/earth/air) - rejected for misalignment with element structureDecision: 2:1 flower conversion ratio during deck building
Rationale: Enables element specialization at meaningful cost (total capacity reduction)
Alternative Considered: No conversion - rejected for limited deck customizationDecision: ~64 tile types per layer
Rationale: Chosen to be comfortably under realistic GPU and memory limits
Constraint: Leaves room for expansion without architectural changesDecision: Identical inputs must produce identical outputs
Rationale: Essential for fair PvP gameplay
Implementation: Integer-only mathematics, simultaneous single-read/single-write GPU passes with deterministic internal rules
⚠️ CHALLENGE: GPU thread execution order is not inherently deterministic - Addressed through simultaneous read/write pass architectureDecision: Fixed world size at initialization
Rationale: Avoids dynamic streaming complexity
Trade-off: Limits map variety for implementation simplicityDecision: Grid-based rule design interface planned
Rationale: Simplifies rule creation and prevents impossible shader compilation
Status: Design planned, implementation TBDDecision: Use containerized build for consistent results
Rationale: Ensures deterministic shader compilation across development environments
⚠️ STATUS: Implementation approach needs specification⚠️ Major Design Decisions Still Needed: Frame Rate Coordination: How to handle different update frequencies between physics (60 FPS) and reactions (potentially lower)? Rule Compilation Pipeline: Exact toolchain and optimization steps? World Size Limits: Performance testing needed to determine optimal map dimensions? Build System Integration: How rule compilation integrates with main build process? Spell System TBD: Number of Casting Slots/Pools: Using 4 as example, optimal count requires playtesting Spell Shape Primitives: Which geometric primitives to support for spell design Void Rune Effects: Powerful secret mechanic effects need design Single Element Rune Effects: Beyond mana recharge, additional effects TBD Curse System Implementation: Mechanics, stacking rules, balancing approach Spell Acquisition System: How players unlock/collect spells ]]></description><link>architecture/general/technical-decisions.html</link><guid isPermaLink="false">architecture/general/technical-decisions.md</guid><pubDate>Tue, 14 Oct 2025 23:52:00 GMT</pubDate></item><item><title><![CDATA[performance]]></title><description><![CDATA[Optimization approaches and technical constraints for tile processing performance.⚠️ NEEDS DISCUSSION: Specific performance targets and constraints have not been established yet.General Goals:
Support many active tiles simultaneously
Performance should scale reasonably with world activity
⚠️ NOT IMPLEMENTED: Active region optimization was decided against - implementation deemed too complex for expected benefit. Team is planning for relatively few dormant areas instead.Purpose: Avoid processing static regions to maintain performance.~~Implementation:
Divide world into 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)
Track chunks with active tiles in GPU buffer
Shaders only process listed active chunks
Activity propagates to neighboring chunks automatically
Dormant regions have minimal GPU cost~~
~~Benefits:
Automatic scaling with activity level
Efficient memory bandwidth usage
Reduced compute shader dispatches~~
GPU Cache Optimization: Leverage 2D data access patterns for efficient memory readsBit-Packing: 32-bit tiles maximize cache line utilization
Tile Type (~6 bits): 64 possible types per layer
Velocity (16 bits): Movement vector for physics
Custom Data (10 bits): Health, timers, charges, etc.
Ping-Ponging: Dual texture approach prevents read-after-write hazardsGPU Workgroup Efficiency: 32×32 chunks align with GPU architectureMemory Layout: Textures use r32uint format for optimal GPU cache performanceParallel Processing: Each GPU thread handles one tile for maximum parallelization⚠️ POTENTIAL OPTIMIZATIONS: Additional GPU techniques
Memory Coalescing: Threads in a warp access consecutive memory addresses simultaneously for maximum bandwidth
⚠️ GUIDELINE: Minimize divergent branching
Structure algorithms so threads in the same warp follow similar execution paths
When early exits are necessary, group similar work patterns together to reduce warp divergence
Tile Types: ~64 per layer (chosen to be comfortably under realistic limits)
World Size: Fixed at initialization (no dynamic streaming)
Mana Types: 8 maximum (player state buffer constraint)
Spell Hand: Size TBD based on UI and gameplay needs⚠️ NEEDS DISCUSSION: Specific performance characteristics to be determined through testing
32×32 chunks chosen to balance GPU workgroup efficiency with memory overhead
GPU texture cache considerations
Parallel processing efficiency targets
⚠️ SUGGESTION: Potential optimization techniques for rule compilation:
Compile-time specialization for specific use cases
Dead code elimination for unused rule paths
Constant folding for pre-computed values
Loop unrolling for neighbor checks
Shader Generation: Move complex rule logic to build time
Asset Optimization: Texture and mesh preprocessing
⚠️ NEEDS DESIGN: Specific optimization pipeline implementation⚠️ SUGGESTION: Potential monitoring and validation approaches:
Automated benchmarks to prevent regressions
Frame timing and bottleneck profiling
Determinism validation across runs
⚠️ Major Unsolved Issues:
Frame rate coordination between different systems
GPU thread execution order determinism
Memory bandwidth optimization across modules
⚠️ SUGGESTION: Potential profiling capabilities to develop:
Frame timing monitoring for pipeline stages
GPU utilization tracking
Memory bandwidth analysis
Active region processing visualization
⚠️ SUGGESTION: Potential debugging tools:
Tile inspector for real-time data examination
Rule tracer for activation analysis
Determinism validation tools
]]></description><link>architecture/general/performance.html</link><guid isPermaLink="false">architecture/general/performance.md</guid><pubDate>Mon, 13 Oct 2025 23:15:21 GMT</pubDate></item><item><title><![CDATA[deterministic-execution]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed deterministic execution approach for GPU-accelerated physics and reactions. This system solves the fundamental challenge of achieving identical results across different hardware for competitive multiplayer.⚠️ CURRENT APPROACH: The actual determinism strategy being used is simultaneous single-read/single-write GPU passes with deterministic internal rules, NOT the spatial ordering strategy described below. The spatial ordering and active region approaches have been superseded.Core Issue: GPU thread execution order within workgroups is not inherently deterministic.Impact:
Non-deterministic collision resolution between tiles
Inconsistent force application results
Different outcomes on different hardware
Breaks competitive multiplayer requirements
Criticality: Essential for fair PvP gameplay and replay capability.⚠️ NOTE: The current architecture achieves determinism through simultaneous single-read and single-write GPU passes, with all operations happening at the same time using deterministic internal rules. This is NOT the spatial ordering strategy described in the following section.⚠️ OUTDATED: The following spatial ordering strategy is NOT being used in the current architecture.Chunk-Level Ordering: Process 32×32 chunks in strict spatial sequence (top-left to bottom-right).Tile-Level Ordering: Within each chunk, process tiles in deterministic spatial order.Player-Level Ordering: Process players in consistent ID-based sequence.// Deterministic tile processing within chunk
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in; void main() { // Map thread to deterministic tile position ivec2 chunkPos = getChunkPosition(); ivec2 localPos = ivec2(gl_LocalInvocationID.xy); ivec2 tilePos = chunkPos * 32 + localPos * 4; // Process 4 tiles per thread in spatial order for (int i = 0; i &lt; 4; i++) { ivec2 currentTile = tilePos + ivec2(i % 2, i / 2); processTileDeterministic(currentTile); }
}
Precision: 16.16 fixed-point format (16 bits integer, 16 bits fractional).Operations: All calculations use integer arithmetic to prevent floating-point drift.Cross-Platform Consistency: Identical results regardless of GPU floating-point implementation.class DeterministicMath { static readonly FIXED_POINT_SCALE = 65536; // 2^16 // Deterministic multiplication static multiply(a: number, b: number): number { return Math.floor((a * b) / this.FIXED_POINT_SCALE); } // Deterministic collision detection static checkCollision(pos1: Point, pos2: Point, radius: number): boolean { const dx = pos1.x - pos2.x; const dy = pos1.y - pos2.y; const distanceSquared = dx * dx + dy * dy; const radiusSquared = radius * radius; return distanceSquared &lt;= radiusSquared; } // Deterministic force resolution static resolveCollision(tile1: TileState, tile2: TileState): CollisionResult { // Use consistent tie-breaking rules const primaryTile = tile1.id &lt; tile2.id ? tile1 : tile2; const secondaryTile = tile1.id &lt; tile2.id ? tile2 : tile1; return this.calculateForces(primaryTile, secondaryTile); }
}
Execution Phases: Use compute barriers to enforce processing order between dependent operations.Memory Barriers: Ensure texture writes complete before subsequent reads.Workgroup Synchronization: Coordinate processing within and between workgroups.Read-Write Separation: Maintain existing texture ping-ponging for race condition prevention.Deterministic Swapping: Ensure texture role swapping occurs at consistent points.State Consistency: Verify texture state consistency across deterministic processing.Replay Tests: Identical input sequences must produce identical outputs.Hardware Variation Testing: Validate consistency across different GPU architectures.Stress Testing: Verify determinism under high load and complex scenarios.class DeterminismValidator { private frameChecksums = new Map&lt;number, string&gt;(); validateFrame(frameNumber: number, gameState: GameState): boolean { const checksum = this.calculateStateChecksum(gameState); const expectedChecksum = this.frameChecksums.get(frameNumber); if (expectedChecksum &amp;&amp; expectedChecksum !== checksum) { console.error(`Determinism failure at frame ${frameNumber}`); return false; } this.frameChecksums.set(frameNumber, checksum); return true; } private calculateStateChecksum(state: GameState): string { // Create deterministic hash of all relevant game state const stateData = this.serializeGameState(state); return this.deterministicHash(stateData); }
}
Determinism-First Design: Consider determinism impact of all changes.Validation Requirements: Test determinism before and after modifications.Code Review Focus: Explicit review of determinism implications.Documentation: Document assumptions about execution order and state dependencies.Overhead Analysis: Spatial ordering adds ~5-10% GPU processing overhead.Optimization Opportunities: Maintain determinism while optimizing memory access patterns.Fallback Strategies: ⚠️ NEEDS DISCUSSION - CPU fallback for determinism-critical operations if GPU determinism proves insufficient.Hardware Differences: Test across NVIDIA, AMD, and Intel GPU architectures.Driver Updates: Establish testing protocol for graphics driver changes.Compatibility Matrix: Maintain supported hardware and driver combinations.Optimization Constraints: Some GPU optimizations may break determinism.Testing Requirements: Extensive validation needed for any physics changes.Quality Assurance: Determinism testing integrated into CI/CD pipeline.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Time slice scheduling integration
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/performance.html" data-href="performance" aria-label="performance" data-tooltip-position="top" target="_self">Performance Strategy</a> - Optimization approaches with determinism constraints
⚠️ NEEDS IMPLEMENTATION: GPU compute shader templates for deterministic processing
Cross-platform validation test suite
Performance benchmarking of spatial ordering overhead
]]></description><link>architecture/general/deterministic-execution.html</link><guid isPermaLink="false">architecture/general/deterministic-execution.md</guid><pubDate>Mon, 13 Oct 2025 23:10:27 GMT</pubDate></item><item><title><![CDATA[active-regions]]></title><description><![CDATA[Chunk-based processing optimization to avoid processing static regions.Purpose: Avoid processing static regions to maintain performance.Core Characteristic: Automatic scaling with activity level rather than world size.
Chunk Size: 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)
World Organization: Divide entire world into fixed chunk grid
Chunk Coordinates: Each chunk identified by (chunk_x, chunk_y) coordinates Active Chunk Buffer: GPU buffer maintains list of chunks with active tiles
Shader Processing: Shaders only process tiles in listed active chunks
Dynamic Updates: Chunks added/removed from active list based on tile changes Neighbor Activation: Activity automatically propagates to neighboring chunks
Movement Spreading: Moving tiles mark their destination chunks as active
Collision Effects: Collisions spread activity to neighboring regions
Gradual Decay: Activity in stable regions decays over time
@compute @workgroup_size(8, 8)
fn process_active_chunks(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) { let chunk_coord = active_chunks[workgroup_id.x]; let local_coord = global_id.xy; let world_coord = chunk_coord * 32u + local_coord; // Process only tiles in active chunks if (world_coord.x &lt; world_size.x &amp;&amp; world_coord.y &lt; world_size.y) { process_tile(world_coord); }
}
GPU Alignment: 32×32 chunks align well with GPU workgroup sizes
Memory Coalescing: Chunk-based processing improves memory access patterns
Thread Utilization: Reduces wasted GPU threads on empty regions
Activity-Based Cost: Processing cost scales with active tiles, not world size
Dormant Regions: Static areas have minimal GPU cost
Memory Access: Reduced texture memory accesses in inactive regions
Active Chunk Buffer: Small GPU buffer storing active chunk coordinates
Tracking Data: Minimal per-chunk metadata for activity state
Negligible Cost: Buffer size insignificant compared to texture memory
Tile Movement: Moving tiles activate their current and destination chunks
Spell Casting: Rune placement activates target chunks
Environmental Changes: Rule transformations mark chunks active
Force Application: Physics forces spread activation
⚠️ NEEDS DESIGN: Specific strategy for marking chunks inactive
Potential approaches: Timer-based decay, change detection, activity counters
Challenge: Balance between responsiveness and performance
Chunk Boundaries: Ensure proper handling of tiles affecting multiple chunks
Large Effects: Spells or explosions affecting many chunks simultaneously
Performance Spikes: Sudden activation of many dormant regions
Movement Processing: Physics updates active chunk list based on tile movement
Collision Detection: Collision effects activate neighboring chunks Rule Processing: Environmental transformations mark affected chunks active
Pattern Matching: Large-scale patterns may activate multiple chunks Rune Placement: Spell casting activates target chunks immediately
Area Effects: Large spells properly handle multi-chunk activation
⚠️ NEEDS SPECIFICATION: Detailed implementation approach for:
Active chunk buffer data structure
GPU buffer update mechanisms Integration with existing texture ping-ponging
Performance monitoring and tuning capabilities
]]></description><link>architecture/systems/core/active-regions.html</link><guid isPermaLink="false">architecture/systems/core/active-regions.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[core]]></title><description><![CDATA[Central coordination and tile data management for the Reaction v2 game engine.The Core Engine coordinates data flow between CPU spell logic and GPU simulation systems while maintaining high performance and deterministic execution.Key Challenge: Synchronize three different processing systems (CPU spells, GPU physics, GPU reactions) without race conditions or performance bottlenecks.
Bit-packed tile storage across 4 layers (Ground, Object, Air, Rune)
GPU texture management with ping-ponging for race-condition prevention Active region optimization using 32×32 chunks
Frame execution pipeline coordination <a class="internal-link" data-href="tile-storage.md" href="architecture/systems/core/tile-storage.html" target="_self" rel="noopener nofollow"><strong></strong></a>Tile Storage System - Bit-packing format and layer organization
<br><a class="internal-link" data-href="texture-management.md" href="architecture/systems/core/texture-management.html" target="_self" rel="noopener nofollow"><strong></strong></a>Texture Management - GPU texture coordination and ping-ponging
<br><a class="internal-link" data-href="active-regions.md" href="architecture/systems/core/active-regions.html" target="_self" rel="noopener nofollow"><strong></strong></a>Active Regions - Chunk-based processing optimization
<br><a class="internal-link" data-href="api-reference.md" href="architecture/systems/core/api-reference.html" target="_self" rel="noopener nofollow"><strong></strong></a>API Reference - Classes and integration points Ground Layer: Terrain foundation (dirt, stone, water)
Object Layer: Interactive entities (rocks, trees, creatures, players)
Air Layer: Gases and effects (fire, smoke, magic) Rune Layer: Spell-placed magical effects (temporary) Active Region System: Only process chunks with changing tiles
Texture Ping-Ponging: Prevents GPU read-after-write hazards
Bit-Packed Storage: 32-bit tile representation
Chunk-Based Processing: 32×32 tile regions Spell System: Writes rune data to rune layer textures
Physics Engine: Reads/writes velocity data via texture pairs
Reaction Engine: Processes transformation rules on tile data Renderer: Provides read-only access to current tile states for display
Game Logic: Exposes tile query API for validation and state checking WebGPU API: Required for texture management and GPU compute coordination
]]></description><link>architecture/systems/core/core.html</link><guid isPermaLink="false">architecture/systems/core/core.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[api-reference]]></title><description><![CDATA[Classes, interfaces, and integration points for the Core Engine system.⚠️ STATUS: API design has not been established yet. The following are suggestions for future design work.⚠️ SUGGESTION: Manages texture allocation and bit-packing operations.Potential Responsibilities:
Bit-packing and unpacking of tile data
Texture allocation and memory management
Layer-specific data access patterns
⚠️ NEEDS DESIGN: Detailed method signatures and data structuresHandles ping-ponging and GPU synchronization.Responsibilities:
Texture pair management for each layer
Ping-pong switching between frames
GPU resource lifecycle management
Synchronization barrier coordination
⚠️ NEEDS DESIGN: WebGPU integration patterns and error handlingCoordinates frame execution pipeline across all modules.Responsibilities:
Frame timing and execution order
Module coordination and communication
Performance monitoring and bottleneck detection
⚠️ NEEDS SPECIFICATION: Integration with different module update frequenciesOptimizes chunk-based processing across GPU modules.Responsibilities:
Active chunk list management
Activity propagation logic
GPU buffer updates for active regions
Performance scaling based on activity
⚠️ NEEDS SPECIFICATION: Activity detection and decay algorithmsRune Placement API:// Preliminary interface - subject to change
interface RunePlacementAPI { placeRune(position: TileCoord, rune: RuneData): void; removeRune(position: TileCoord): void; queryRune(position: TileCoord): RuneData | null;
}
Velocity Management API:// Preliminary interface - subject to change
interface VelocityAPI { setVelocity(position: TileCoord, velocity: Vector2): void; getVelocity(position: TileCoord): Vector2; applyForce(position: TileCoord, force: Vector2): void;
}
Tile State API:// Preliminary interface - subject to change interface TileStateAPI { getTile(position: TileCoord, layer: LayerType): TileData; setTile(position: TileCoord, layer: LayerType, data: TileData): void; queryNeighborhood(center: TileCoord, radius: number): TileData[];
}
Read-Only Display API:// Preliminary interface - subject to change
interface DisplayAPI { getCurrentTileState(position: TileCoord): LayeredTileData; getVisibleRegion(viewport: Rectangle): TileData[]; subscribeToChanges(callback: (changes: TileChange[]) =&gt; void): void;
}
⚠️ NEEDS FINALIZATION: Specific bit allocation during implementation// Preliminary structure - bit allocation TBD
interface TileData { type: number; // ~6 bits - tile type identifier velocity: Vector2; // 16 bits - movement vector (signed) customData: number; // ~10 bits - health, timers, charges
}
enum LayerType { Ground = 0, // Terrain foundation Object = 1, // Interactive entities Air = 2, // Gases and effects Rune = 3 // Spell-placed effects
}
interface TileCoord { x: number; y: number;
} interface ChunkCoord { chunkX: number; chunkY: number;
}
⚠️ NEEDS DESIGN: Comprehensive error handling strategy for:
GPU resource allocation failures
WebGPU device lost scenarios Texture memory exhaustion
Invalid tile coordinate access
Synchronization failures
⚠️ NEEDS IMPLEMENTATION: Built-in profiling capabilities for:
Frame timing breakdown by module
GPU utilization and memory bandwidth
Active region processing efficiency
Texture ping-pong overhead measurement WebGPU API: Core dependency for all GPU operations
TypeScript: Type safety and development experience Integration with all other game modules
Shared type definitions across the codebase
Common utility functions and error types
]]></description><link>architecture/systems/core/api-reference.html</link><guid isPermaLink="false">architecture/systems/core/api-reference.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[tile-storage]]></title><description><![CDATA[Problem: GPU shaders need packed data, but game logic needs flexible representations.Solution: Bit-packed 32-bit tiles stored in GPU textures.
Ground Layer: Terrain foundation (dirt, stone, water)
Object Layer: Interactive entities (rocks, trees, creatures)
Air Layer: Gases and effects (fire, smoke, magic) Rune Layer: Spell-placed magical effects (temporary)
Note: Specific bit allocation TBD during implementation. Approximate layout:
Tile Type (~6 bits, chosen for comfortable headroom)
Velocity X/Y (signed values for movement)
Custom Data (remaining bits for health, timers, charges)
Texture Ping-Ponging: Each layer uses paired textures (layer_A, layer_B) enabling GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards.Memory Layout: Textures use r32uint format for optimal GPU cache performance.Purpose: Avoid processing static regions to maintain performance.Implementation:
Divide world into 32×32 tile chunks (chosen to balance GPU workgroup efficiency with memory overhead)
Track chunks with active tiles in GPU buffer
Shaders only process listed active chunks
Activity propagates to neighboring chunks automatically
Dormant regions have minimal GPU cost TileStorage: Manages texture allocation and bit-packing
TextureManager: Handles ping-ponging and synchronization
GameLoop: Coordinates frame execution pipeline
ActiveRegionTracker: Optimizes chunk-based processing Spell System: Writes rune data to rune layer textures
Physics Engine: Reads/writes velocity data via texture pairs
Reaction Engine: Processes transformation rules on tile data
Renderer: Reads current tile states for display
]]></description><link>architecture/systems/core/tile-storage.html</link><guid isPermaLink="false">architecture/systems/core/tile-storage.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[gpu]]></title><description><![CDATA[Shared WebGPU resource management and coordination for all GPU-accelerated systems.The GPU Manager System manages the WebGPU instance, device initialization, and resource sharing across all systems that require GPU computation or rendering.Key Challenge: Coordinate GPU resource usage across multiple systems (Physics, Reactions, Renderer) while maintaining performance and preventing resource conflicts.
WebGPU device initialization and capability detection
GPU resource allocation and memory management
Compute pipeline coordination between systems
Error handling and recovery for GPU operations
Performance monitoring and resource utilization tracking WebGPU Device: Single device instance shared across all systems
Buffer Pools: Reusable buffer allocation for different data types
Texture Management: Coordinate texture creation and lifecycle
Compute Queue: Prioritized command queue for GPU operations Physics System: Provides compute shaders for collision and movement
Reactions System: Manages rule compilation and execution shaders Renderer: Coordinates rendering pipeline and display
Core System: Integrates with texture ping-ponging and memory management Automatic Fallback: Handle WebGPU unavailability gracefully
Capability Detection: Query and adapt to GPU limitations
Error Recovery: Robust handling of GPU context loss
Performance Profiling: Built-in GPU timing and resource monitoring Allocation Tracking: Monitor buffer and texture usage across systems
Memory Optimization: Efficient sharing and reuse of GPU resources
Priority Management: Coordinate competing GPU workloads
Synchronization: Ensure proper ordering of GPU operations Device Setup: Initialize WebGPU device with required features
System Registration: Allow systems to register their GPU requirements
Resource Allocation: Provide standardized buffer/texture allocation Command Submission: Centralized GPU command queue management
Resource Sharing: Safe sharing of buffers and textures between systems
Performance Monitoring: Real-time GPU utilization reporting WebGPU API: Required for all GPU operations
Browser/Platform: WebGPU support and capabilities
]]></description><link>architecture/systems/gpu/gpu.html</link><guid isPermaLink="false">architecture/systems/gpu/gpu.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[v1-data-strategies]]></title><description><![CDATA[This document captures data organization and packing techniques from V1 to inform V2's bit-packed tile system design. V1 demonstrated sophisticated GPU-optimized data structures that V2 developers should understand when designing the core engine's tile storage.Source: Analysis of V1 data structures (src/rules/rules.ts, src/core/types.ts, src/graphics/shaders/reaction.wgsl)
Status: Reference material for V2 data architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 data structures and hasn't been reviewed by the team.V1 Architecture: Rules stored as packed data in 128×128 GPU textureTexture format: r32uint (32-bit unsigned integers)
Total capacity: 16,384 × 32 bits = 64KB rule storage
Organization: 4 u32s horizontally per tile type, 16 vertically per reaction
Spatial Organization Pattern:X-axis: tile_type * 4 + data_column (0-3)
Y-axis: reaction_index * 16 + condition_index (0-15)
Data access: textureLoad(rules, vec2u(x_coord, y_coord))
Personal Assessment: This layout optimized GPU cache access for spatially-related rule queries.My Interpretation: The 4×16 block per reaction ensured related data stayed within GPU cache lines.V1 Condition Data Format (9 bits per leaf condition):Bit allocation:
- Tile type: 5 bits (0-31, accommodating enum value 20 for sand)
- Direction: 3 bits (8 compass directions) - Distance: 1 bit (1 or 2 tiles away) Packing formula: (tile_type &lt;&lt; 4) | (direction &lt;&lt; 1) | distance_bit
Personal Observation: This encoding maximized information density while staying within GPU bit manipulation capabilities.V1 Internal Node Encoding (2 bits per operator):Operator types: AND=0, OR=1, NOR=2, NAND=3
Packed format: 7 operators × 2 bits = 14 bits total
Storage: Combined with condition value in single u32
My Assessment: This allowed complex logical trees in minimal memory.V1 Reaction Block Format (4 u32s × 16 conditions):u32[0]: (modes &lt;&lt; 15) | (value &lt;&lt; 10) | (bias &lt;&lt; 5) | result_tile
u32[1]: leaf_conditions[0,1,2] packed as 3×9 bits + padding
u32[2]: leaf_conditions[3,4,5] packed as 3×9 bits + padding u32[3]: leaf_conditions[6,7,8] packed as 3×9 bits + padding
Personal Note: This distributed related data across multiple texture coordinates while maintaining efficient access.Packed Leaf Storage (3 conditions per u32):Bit layout per u32: [condition2][condition1][condition0][padding]
Bit offsets: 0, 9, 18 bits (LSB-first packing)
Extraction: (packed_data &gt;&gt; bit_offset) &amp; 0b111111111
My Interpretation: This maximized data density while allowing parallel condition evaluation.Contributor: Claude Status: Individual analysis of data flowPersonal Addition: These data access observations haven't been discussed with the team.V1 Rule Loading Strategy: Batch pre-fetch for condition evaluationRule queries per tile:
- Base reaction data: 1 texture read (bias, result_tile, modes)
- Leaf condition data: 3 texture reads (chunks 0-2, 3-5, 6-8)
- Total per condition: 4 texture reads maximum
Personal Assessment: This minimized GPU memory bandwidth by batching related reads.Cache-Friendly Access Pattern:Spatial locality: Consecutive X coordinates for condition chunks
Temporal locality: All rule data for one condition read together
Memory coalescing: Adjacent GPU threads access adjacent texture coordinates
My Interpretation: V1 was designed around GPU memory hierarchy optimization.V1 Initialization Approach: Pre-populate with "do nothing" defaultsDefault leaf value: tile=31, direction=0, distance=1 (encoded as 496)
Default packed chunk: 3 leaves = 130,277,872
Default condition modes: value=0, modes=0 (AND tree)
Personal Observation: This eliminated special case handling during rule evaluation.Bounds Safety Pattern:Out-of-bounds behavior: Default values ensure safe evaluation
Missing rules: "Do nothing" transformation (tile unchanged)
Invalid data: Graceful degradation rather than crashes
My Assessment: This defensive programming approach ensured robust GPU execution.Contributor: Claude Status: Individual analysis needing validationPersonal Addition: These efficiency observations need team discussion for V2 design.V1 Rule Capacity (calculated from observed limits):Maximum tile types: 32 (5-bit encoding)
Maximum reactions per type: 8
Maximum conditions per reaction: 16
Maximum tree complexity: 7 internal nodes + 8 leaves per condition
Storage Efficiency:Bits per condition: 32 × 4 = 128 bits
Information density: ~9 bits condition data + 14 bits modes + 10 bits scoring
Utilization: ~33 bits useful data / 128 bits storage ≈ 26% efficiency
Personal Assessment: V1 prioritized access speed over storage efficiency.My Interpretation: The 74% "waste" provided padding for GPU cache alignment and simplified addressing.V1 Memory Bandwidth Usage (estimated):Texture reads per tile evaluation:
- Rule base data: 1 × 32 bits = 32 bits
- Condition chunks: 3 × 32 bits = 96 bits - Shared cache reads: ~144 × 32 bits = 4,608 bits (amortized across workgroup)
Personal Calculation: ~128 bits rule data + ~72 bits shared cache per tileMy Assessment: V1's bandwidth usage was reasonable for the computational complexity achieved.V1 Scaling Limitations (observed):Rule texture size: Fixed 128×128 (no dynamic scaling)
Tile type limit: 32 types maximum (5-bit field)
Reaction complexity: 16 conditions maximum per reaction
Memory usage: Linear with rule complexity
Personal Concern: V1's fixed limits might not scale to V2's ambitions.Research Questions:
How do V1's limits compare to V2's requirements?
Should V2 use similar fixed-size allocations or dynamic scaling?
Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Approach: Complex multi-level packing with specialized extraction
V2 Planned: Bit-packed tiles with ~6 bits type + velocity + custom dataPersonal Questions:
Should V2 use V1's sophisticated bit manipulation techniques?
How will V2's 4-layer system affect packing complexity?
Will V2's real-time requirements allow V1-style complex unpacking?
My Assessment: V2 might benefit from simpler packing schemes than V1's intricate system.V1 Evidence: GPU texture storage with cache-optimized layout
V2 Plans: Texture ping-ponging with active region optimizationCompatibility Questions:
Can V2's active regions use V1's texture organization principles?
Should V2 pre-allocate like V1 or use dynamic allocation?
How do V2's performance targets compare to V1's memory usage patterns?
Team Discussion Needed: Memory allocation strategy for V2's different requirements.V1 Approach: Maximum density through complex bit manipulation
V2 Considerations: Balance between efficiency and implementation complexityPersonal Assessment: V1's approach was sophisticated but complex to implement and debug.Research Needed: Whether V2's requirements justify V1-level complexity.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific data design considerations for V2.V1 Evidence: Complex packing achieved high data density and good GPU performance
V2 Trade-offs: Implementation complexity vs memory/performance benefitsResearch Questions:
What are V2's memory constraints compared to V1?
How important is V1-level data density for V2's goals?
Should V2 prioritize development simplicity or runtime efficiency?
Team Discussion Needed: Performance requirements vs implementation complexity balance.V1 Success: Texture-based storage with spatial organization
V2 Considerations: How to adapt V1's principles to V2's 4-layer systemDesign Questions:
Should V2 layers share V1's texture organization approach?
How do V2's physics requirements affect data layout needs?
Will V2's active region system benefit from V1's spatial locality patterns?
Personal Assessment: V2 should consider adapting V1's spatial organization principles.V1 Limitations: Fixed sizes and hardcoded limits
V2 Opportunities: More flexible systems while preserving V1's efficiencyResearch Areas:
Dynamic data allocation vs V1's pre-allocation approach
Configurable complexity limits vs V1's hardcoded maximums
Runtime data modification vs V1's compile-time rule baking
Team Input Needed: V2's flexibility requirements vs performance constraints.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These data architecture recommendations need team review before consideration.
Spatial data organization for GPU cache efficiency
Batch data access to minimize memory bandwidth
Default value strategies for robust error handling
Bit-level packing where density justifies complexity Layer-aware organization for V2's 4-layer tile system
Active region integration with V1's spatial locality principles
Flexible scaling beyond V1's fixed limits
Simplified packing for easier development while preserving core efficiency Dynamic allocation instead of V1's fixed texture sizes
Configurable complexity instead of hardcoded limits
Development tools for debugging complex data structures
Performance monitoring for data access pattern optimization
Status: All recommendations need team evaluation and data architecture planning.Personal Suggestions (not discussed with team):
Prototype V2 bit-packing using lessons from V1's techniques
Benchmark data access patterns comparing V1 approaches with V2 requirements Design data validation tools to avoid V1's debugging complexity
Plan scalability testing for V2's data structures under various load scenarios
Status: All suggestions need team review and core engine architecture planning.]]></description><link>legacy/v1-data-strategies.html</link><guid isPermaLink="false">legacy/v1-data-strategies.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[v1-gpu-patterns]]></title><description><![CDATA[This document captures GPU optimization strategies from V1 to inform V2 compute shader design. V1's reaction compute shader contained sophisticated optimization patterns that V2 developers should understand when designing the core engine's GPU architecture.Source: Analysis of V1 compute shader (src/graphics/shaders/reaction.wgsl)
Status: Reference material for V2 GPU architecture decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 GPU code and hasn't been reviewed by the team.V1 Pattern Observed: Sophisticated neighborhood caching systemWorkgroup size: 8×8 threads (64 total)
Cache dimensions: 12×12 tiles (144 total)
Border padding: 2 tiles in each direction
Memory layout: array&lt;array&lt;u32, 12&gt;, 12&gt;
Caching Algorithm:
Each thread loads multiple cache pixels (144 pixels ÷ 64 threads = ~2.25 pixels per thread)
Linear cache index distribution across threads
Wrap-around coordinate calculation for world boundaries
Workgroup barrier synchronization before shared memory reads
Personal Assessment: This eliminated redundant texture reads for neighbor checks, likely providing significant performance benefits.My Interpretation: The 2-tile border allowed checking neighbors at distance 1 and 2 without additional texture fetches.V1 Coordinate Calculation Pattern:Global origin: workgroup_id * workgroup_size - cache_offset
Linear thread mapping: local_id.y * workgroup_size_x + local_id.x Wrap-around handling: (coord % tex_dims + tex_dims) % tex_dims
Personal Observation: This avoided branching and handled torus world topology efficiently.Cache Access Pattern:Cache position: local_coordinate + cache_offset + relative_neighbor_offset
No bounds checking: Relied on cache being large enough for all valid accesses
My Assessment: This trusted the cache dimensions to handle all possible neighbor accesses within the 2-tile radius.V1 Pattern: Dual texture approach for race condition prevention
Input texture: Read-only during compute pass
Output texture: Write-only during compute pass Swap textures between frames
Personal Note: This matches V2's planned ping-ponging strategy, validating the approach.Contributor: Claude Status: Individual analysis of GPU optimizationPersonal Addition: These observations from V1's data access patterns haven't been discussed with the team.V1 Approach: Minimize texture reads through strategic batchingRule data chunks: 3 texture reads for 9 leaf conditions (3 conditions per u32)
Chunk storage: array&lt;u32, 3&gt; for indexed access
Pre-computation: All rule data loaded before tree evaluation
Personal Interpretation: This reduced GPU memory bandwidth usage by batching related data.My Assessment: V2's rule compilation should consider similar data locality optimization.V1 Pattern: Efficient tree traversal without recursionNode results array: Fixed-size array for all tree nodes
Bottom-up evaluation: Leaves first (indices 7-15), then internal nodes (6 down to 0)
Loop-based traversal: Avoided GPU recursion limitations
Personal Note: This was a clever solution to GPU architectural constraints.My Concern: V2's JSON compilation needs similar tree evaluation efficiency.V1 Optimization: Early exit on symmetry successSymmetry loop: 8 iterations (rotations and reflections)
Early termination: Break immediately when any symmetry evaluates true
Result aggregation: OR operation across all symmetries
Personal Assessment: This reduced unnecessary computation when patterns matched early.What I Don't Know: Whether V2's compiled rules will include similar short-circuit optimizations.Contributor: Claude Status: Individual analysis of GPU synchronizationPersonal Addition: These synchronization observations need team consideration for V2.V1 Processing Phases:
Cache Loading Phase: All threads cooperatively load neighborhood data
Synchronization Barrier: workgroupBarrier() ensures cache completion
Independent Processing Phase: Each thread processes its assigned tile
Personal Observation: Clear separation between cooperative and independent work.My Interpretation: This maximized GPU efficiency by aligning with hardware capabilities.V1 Cache Loading Strategy:Work distribution: (cache_pixels + num_threads - 1) / num_threads // Ceiling division
Load balancing: Each thread loads 0-3 cache pixels depending on position
Bounds checking: Prevents threads from loading beyond cache dimensions
Personal Assessment: This ensured even work distribution across the workgroup.My Note: V2 should consider similar load balancing for any cooperative operations.V1 Synchronization Points:
Single workgroupBarrier() after cache loading
No additional barriers during tree evaluation
Independent tile processing without cross-thread communication
Personal Interpretation: Minimal synchronization overhead while ensuring data consistency.Personal Question: Will V2's active region system require additional synchronization?Contributor: Claude Status: Individual assessment needing team discussionPersonal Addition: These performance observations haven't been validated with actual measurements.V1 Work per Tile:
Reaction evaluation: Up to 8 reactions per tile type
Condition evaluation: Up to 16 conditions per reaction Symmetry testing: 8 geometric transformations per condition
Tree traversal: 7 internal nodes + 8 leaf evaluations
Personal Calculation: Worst case ~8×16×8×15 = 15,360 operations per tileMy Assessment: This suggests V1 could handle very complex environmental behaviors, but at computational cost.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations.V1 Memory Footprint per Workgroup:
Shared cache: 144 × 32-bit = 576 bytes
Node results array: 16 × 1-bit = 2 bytes (negligible)
Rule data cache: 3 × 32-bit = 12 bytes per condition
Personal Note: Shared memory usage was well within typical GPU limits.What I Don't Know: How V2's bit-packed tile format will affect memory access patterns.V1 Texture Access Patterns:
Input texture reads: 1 per cache pixel (coalesced across workgroup)
Rules texture reads: 4 per tile (base + 3 condition chunks)
Output texture writes: 1 per tile
Neighbor access: From cache (no additional texture reads)
Personal Assessment: Well-optimized memory access pattern with minimal bandwidth waste.My Concern: V2's 4-layer system may increase memory bandwidth requirements.Identified by: Claude Status: Team input neededPersonal Assessment: V1 patterns suggest specific GPU architecture considerations for V2.V1 Evidence: 8×8 workgroups with 12×12 cache worked well for 2-tile radius operationsResearch Questions for V2:
Should V2 use similar workgroup dimensions?
How does V2's active region system (32×32 chunks) align with workgroup sizes?
Will V2's tile operations require different neighbor access patterns?
Team Discussion Needed: Workgroup sizing based on V2's specific requirements.V1 Strategy: Heavy use of workgroup shared memory for cachingV2 Considerations:
Does V2's 4-layer system benefit from similar caching?
Should V2 cache active region metadata in shared memory?
How do V2's bit-packed tiles affect cache efficiency?
Research Needed: Performance testing of V2 memory access patterns.V1 Evidence: Minimal synchronization (single barrier) provided good performanceV2 Questions:
Will V2's physics integration require additional synchronization?
Does V2's active region updating need workgroup coordination?
Should V2 pipeline different processing phases differently?
Personal Assessment: V2 may need more complex synchronization than V1.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These design recommendations need team review before consideration.
Workgroup shared memory caching for neighbor access optimization
Phase-based processing with clear synchronization points Early exit optimizations where applicable
Texture ping-ponging (already planned for V2) Scale caching strategy for V2's 4-layer tile system
Integrate active region optimization with V1's workgroup patterns
Consider rule compilation targeting similar GPU optimization patterns Complexity vs Performance: V1 handled very complex rules - should V2 target similar capability?
Memory vs Computation: V1 used memory to reduce computation - is this optimal for V2?
Synchronization Overhead: Will V2's additional systems require more GPU barriers?
Status: All recommendations need team evaluation and design discussion.Personal Suggestions (not discussed with team):
Prototype V2 compute shaders using V1 optimization patterns as starting point
Benchmark memory access patterns for V2's bit-packed 4-layer system
Design active region processing to leverage V1's workgroup coordination strategies
Test synchronization requirements for V2's multi-system integration
Status: All suggestions need team review and implementation planning.]]></description><link>legacy/v1-gpu-patterns.html</link><guid isPermaLink="false">legacy/v1-gpu-patterns.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[v1-reference]]></title><description><![CDATA[This document captures fundamental concepts and mathematical algorithms from the V1 rules engine to inform V2 development. V1 contained sophisticated rule evaluation systems that V2 developers should understand when designing the JSON compilation pipeline.Source: Analysis of V1 legacy codebase (archived)
Status: Reference material for V2 design considerationContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 code and hasn't been reviewed by the team.V1 Approach: Rules were evaluated across 8 geometric transformations (4 rotations × 2 reflections) to create symmetric environmental behaviors.Mathematical Pattern Observed:Rotation calculation: (symmetry &gt;&gt; 1u) &lt;&lt; 1u // Even number rotations
Reflection: select(1, -1, (symmetry &amp; 1u) != 0u) // Flip on odd symmetries
Final position: scale * flip * base_direction_vector
My Assessment: This created natural-looking environmental effects where fire spreading, water flow, etc. worked consistently in all directions.Personal Concern: V2's JSON compilation needs to handle similar geometric transformations or environmental effects may look artificial.V1 Pattern: Complex conditions organized as binary trees with packed evaluation:
7 internal nodes (operators: AND, OR, NOR, NAND)
8 leaf nodes (spatial conditions)
Bottom-up evaluation from leaves to root
Data Packing Observed:
Internal node modes: 2 bits each, packed into 14 bits total
Leaf conditions: 9 bits each (5-bit tile type, 3-bit direction, 1-bit distance)
Evaluation results: Boolean array with indices mapping to tree structure
My Interpretation: This allowed arbitrarily complex logical conditions while maintaining GPU efficiency.Personal Question: How will V2's JSON compilation achieve similar complexity without runtime memory overhead?V1 Bias System:
Base reaction bias: signed 5-bit value (-16 to +15)
Condition contributions: signed values added when conditions met
Winning rule: highest total score after all conditions evaluated
Personal Observation: This created emergent behaviors where multiple environmental effects competed naturally (e.g., fire spreading vs water extinguishing).What I Don't Know: Whether V2's competitive scoring will replicate this mathematical sophistication.Contributor: Claude Status: Individual analysis of compute shaderPersonal Addition: These observations from V1's GPU implementation haven't been discussed with the team.V1 Pattern: 12×12 shared memory cache for 8×8 workgroup with 2-tile border
Each thread loads multiple cache pixels to fill neighborhood
Workgroup barrier synchronization before condition evaluation
Eliminates redundant texture reads for neighbor checks
My Assessment: This optimization was sophisticated and likely provided significant performance benefits.Personal Concern: V2 GPU shader design should consider similar caching strategies.V1 Approach: Pre-computed direction offset arrays with wrap-around handlingDirection offsets: 8 compass directions as vec2i
Wrap-around: (global_coord % tex_dims + tex_dims) % tex_dims
Cache position: local_coord + cache_offset + relative_position
Personal Note: This handled world boundaries elegantly while maintaining cache efficiency.V1 Pattern: Batch-loaded rule data chunks before evaluation
3 texture reads for all 9 possible leaf conditions
Stored in array for indexed access during tree evaluation
Minimized GPU texture bandwidth usage
My Interpretation: This was a carefully optimized memory access pattern.Contributor: Claude Status: Questions identified from V1 analysisPersonal Assessment: These issues need team discussion based on V1 complexity:Question: How will V2's JSON compilation handle the mathematical sophistication of V1's binary tree evaluation and 8-fold symmetry?V1 Evidence: Rules could express conditions like "fire spreads if 2+ fire neighbors AND no water within 2 tiles AND not in NW/NE corners"My Concern: V2 JSON format may need significant complexity to match V1 expressiveness.Question: Will V2 replicate V1's shared memory optimizations or use different strategies?V1 Evidence: Complex workgroup coordination and cache management in compute shaderPersonal Assessment: V2 might benefit from studying V1's memory access patterns before designing new shaders.Question: How will V2 ensure deterministic evaluation order that V1 achieved?V1 Evidence: Strict tile-by-tile processing with consistent neighbor checking orderWhat I Don't Know: Whether V2's approach will maintain this level of determinism.Identified by: Claude Status: Team input neededPersonal Assessment: V1 performance characteristics need measurement, but patterns suggest optimization priorities.
128×128 texture for rules (16,384 × 32-bit values = 64KB rule storage)
Workgroup shared memory: 144 × 32-bit values per workgroup
Dual texture ping-ponging: 2× map memory usage
My Interpretation: V1 traded memory for computational efficiency.Research Needed: Actual performance measurements and comparison with V2 targets.
8 symmetry evaluations per condition
Binary tree evaluation with up to 7 internal nodes
16 conditions maximum per reaction
8 reactions maximum per tile type
Personal Note: This suggests V1 could handle very complex environmental behaviors.Team Discussion Needed: Whether V2 should target similar complexity or accept limitations for simplicity.Personal Recommendations (not discussed with team):
Study V1's mathematical patterns before finalizing JSON compilation approach
Consider V1's GPU optimization strategies for V2 shader architecture Evaluate whether V2 competitive scoring can achieve V1's sophistication
Plan for complexity testing to ensure V2 can handle intricate environmental behaviors
Status: All recommendations need team review and discussion.]]></description><link>legacy/v1-reference.html</link><guid isPermaLink="false">legacy/v1-reference.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[v1-visual-effects]]></title><description><![CDATA[This document captures visual rendering techniques from V1 to inform V2 renderer design. V1's render shader contained sophisticated visual effects that created distinct, animated appearances for different tile types.Source: Analysis of V1 render shader (src/graphics/shaders/render.wgsl)
Status: Reference material for V2 visual design decisionsContributor: Claude Status: Individual analysis, not discussed with teamPersonal Addition: This entire analysis represents my individual examination of V1 rendering code and hasn't been reviewed by the team.V1 Water Effect: Complex wave system using multiple sine functionsWave components (observed):
- Wave 1: sin(worldUV.x * 3.2 + time * 1.03) * 0.5 (primary horizontal)
- Wave 2: sin(worldUV.y * 14.0 - time * 1.3) * 0.25 (vertical fine)
- Wave 3: sin(worldUV.y * 8.3 + time * 1.5) * 0.25 (vertical medium)
- Wave 4: sin((worldUV.x + worldUV.y) * 13.7 - time * 0.8) * 0.15 (diagonal)
- Wave 5: sin((2.43 * worldUV.x + 3.0 * worldUV.y) * 15.5 - time * 1.2) * 0.12 (complex)
- Wave 6: sin((worldUV.x - 1.3 * worldUV.y) * 16.7 - time * 0.7) * 0.1 (counter-diagonal)
Personal Assessment: This created realistic water movement with multiple overlapping wave patterns.Color Blending System:Base colors: Deep blue (#0099CC) to cyan (#33CCFF)
Height mapping: Wave height influences color interpolation
Highlight system: White foam on wave peaks using smoothstep
My Interpretation: The multi-wave approach created natural-looking water with depth variation.Personal Note: V2 should consider similar layered animation techniques for environmental immersion.V1 Grass Blade Technique: Individual blade rendering within each tileBlade positioning: Offset by sine(time + worldUV.y * 2) for wind effect
Blade dimensions: Triangle-based blade shapes with height variation
Dual blade system: Two offset blade patterns per tile for density
Blade Generation Algorithm:Blade coordinate mapping: (worldUV * 10) % 1 for repeating pattern
Blade shape: 1 - abs(bladepos.x - 0.5) * 2 (triangle profile)
Height variation: bladepos.y-based cutting for blade tips
Wind animation: X-offset by sine function creates swaying
Personal Assessment: This created convincing grass appearance at the tile level.Color System:Base colors: Dark green (#1A4D33) to bright green (#19FF19)
Height-based mixing: Taller blade portions lighter
Highlight integration: White highlights on blade tips
My Interpretation: The procedural approach provided detailed grass without requiring texture assets.V1 Lava Effect: Similar wave system to water but with different parametersWave pattern: Subset of water waves (4 components instead of 6)
Color palette: Orange-red (#FF3300) to yellow-orange (#FFCC80)
Highlight system: Pink-magenta highlights (#FF80FF) on wave peaks
Personal Observation: Lava reused water's animation framework with different visual parameters.My Assessment: This suggests V2 could use unified animation systems with material-specific parameters.V1 Noise Functions: Multiple noise layers for various effectsBasic Perlin: Standard 2D Perlin noise with gradient interpolation
Fractal Brownian Motion (FBM): 4 octaves of layered noise
Hash function: Deterministic pseudo-random for gradient generation
Noise Applications Observed:
Mountain height maps with contour effects
Terrain distortion for organic tile boundaries
Texture variation within tile types
Personal Note: V2 should consider noise as a fundamental rendering primitive.V1 Distortion System: World UV coordinates modified by noiseDistortion calculation: Perlin noise at multiple scales
Application: UV += distortion_vector before tile sampling
Effect: Organic, non-grid-aligned visual boundaries
Personal Assessment: This helped disguise the underlying grid structure.Tile Edge Softening:Distance calculation: max(abs(tileUV.x-0.5), abs(tileUV.y-0.5)) * 2 - 0.2
Falloff function: 1 - pow(square_dist, 6.0)
Application: Multiply final color by falloff
My Interpretation: This created soft tile boundaries and visual cohesion.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These material observations need team consideration for V2 visual design.V1 Material Definitions:
Water: Blue spectrum with white foam highlights
Lava: Orange-red spectrum with magenta highlights
Magic: Purple-green spectrum (similar animation to water)
Grass: Green spectrum with procedural blade geometry
Void: Animated mountain texture with brown/purple palette
Personal Observation: Each material had distinct color relationships and animation characteristics.My Assessment: V2 should define similar material systems for consistent visual identity.V1 Color Blend Patterns:Height-based interpolation: mix(deepColor, lightColor, height_factor)
Highlight overlays: mix(baseColor, highlightColor, highlight_strength)
Time-based variation: Colors influenced by animation state
Personal Note: This created natural-looking material variation without texture sampling.Material Property System (inferred):
Base color ranges per material type
Animation amplitude and frequency per material
Highlight color and trigger thresholds per material
My Interpretation: V2 could benefit from similar parameterized material systems.V1 Shader Efficiency Patterns:
Switch statement for tile type selection (GPU-friendly branching)
Shared mathematical functions across material types
Single-pass rendering with material-specific logic branches
Personal Assessment: V1 balanced visual complexity with rendering performance.Mathematical Function Reuse:
Perlin noise used across multiple material types
Wave functions shared between water, lava, and magic
Color interpolation patterns repeated across materials
My Note: V2 should consider similar function reuse for consistency and performance.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.V1 Evidence: Complex mathematical calculations per pixel (6-wave water system, procedural grass, multi-octave noise)Personal Questions for V2:
Should V2 target similar visual complexity?
How will V2's 4-layer system affect rendering performance?
Will V2 support material-specific animation systems?
Research Needed: Performance testing of V1-style effects with V2's architecture.V1 Approach: Hardcoded material properties in shader switch statementsV2 Considerations:
Should V2 use similar hardcoded materials or data-driven systems?
How do V2's layers interact visually (transparency, blending)?
Will V2 support runtime material customization?
Personal Assessment: V2 might benefit from more flexible material systems than V1's hardcoded approach.V1 Time Usage: Global time parameter for synchronized animations across all tilesV2 Questions:
How will V2 handle time synchronization across distributed processing?
Should V2 support per-tile animation offsets for variety?
Will V2's physics system affect visual animation timing?
Team Discussion Needed: Integration between V2's physics timing and visual animation.Identified by: Claude Status: Team input neededPersonal Assessment: V1's visual complexity suggests performance considerations for V2.V1 Per-Pixel Calculations (observed):
Water: 6 sine function evaluations + color interpolation
Grass: Blade geometry generation + multiple conditional branches
Noise: 4-octave fractal calculation + hash function evaluations
Personal Calculation: Potentially 10-20 mathematical operations per pixel for complex materialsResearch Questions:
What are V2's target performance characteristics?
Should V2 support multiple detail levels for different devices?
How does V1's performance compare to V2's goals?
Team Discussion Needed: Visual quality vs performance trade-offs for V2.V1 Approach: Procedural generation without texture assets
No texture memory usage for material appearance
All effects generated mathematically in shader
Time and UV coordinates as only inputs
V2 Implications:
Should V2 continue the fully-procedural approach?
How do V2's bit-packed tiles affect rendering pipeline?
Will V2's 4-layer system require additional rendering passes?
Personal Assessment: V1's procedural approach was memory-efficient but computationally intensive.Contributor: Claude Status: Individual suggestions not discussed with teamPersonal Addition: These visual design recommendations need team review before consideration.
Multi-wave animation systems for natural-looking environmental movement
Procedural material generation for memory efficiency
Perlin noise integration for organic visual variation
Material-specific color palettes for visual distinction Layer-aware rendering for V2's 4-layer tile system
Material property systems for easier customization than V1's hardcoded approach
Performance scaling for different device capabilities
Animation synchronization with V2's physics and reaction systems Visual complexity scaling - V1 effects were computationally expensive
Material variety - V1 had limited material types compared to V2's ambitions
Layer interaction - V1 was single-layer, V2 needs multi-layer visual compositing
Status: All recommendations need team evaluation and visual design discussion.Personal Suggestions (not discussed with team):
Prototype V2 materials using V1 techniques as starting point
Test rendering performance with V2's 4-layer system and V1-style effects
Design material property systems that provide V1's visual quality with more flexibility
Plan animation integration with V2's physics and reaction timing
Status: All suggestions need team review and renderer architecture planning.]]></description><link>legacy/v1-visual-effects.html</link><guid isPermaLink="false">legacy/v1-visual-effects.md</guid><pubDate>Mon, 13 Oct 2025 20:57:42 GMT</pubDate></item><item><title><![CDATA[DOCUMENTATION_STRUCTURE]]></title><description><![CDATA[Documentation should function as a navigational search tree where each level provides just enough information to guide readers to the right destination.Parent nodes are signposts, not encyclopedias
Overview documents help readers navigate to specifics
Include enough detail to make informed navigation choices
Avoid comprehensive coverage at high levels
No redundant information
Each piece of information has one authoritative location
Link to sources rather than copying content
Update links when information moves
Hierarchical information flow
Overview → Category → Implementation Details
General concepts → Specific examples
Architecture → Component details
Overview Documents
List what's covered and where to find it
Provide context for understanding relationships
Include links to detailed documentation
Don't duplicate content from linked pages
Category Documents
Explain concepts specific to that category
Direct readers to implementation details
Show how pieces relate within the category
Link to related categories when relevant
Detail Documents
Contain complete implementation information
Reference but don't duplicate architectural context
Link back to parent concepts when helpful
Focus on specific, actionable content
Top-Down Discovery
Start with high-level goals or concepts
Follow links to increasingly specific information
Each level adds detail without repeating previous levels
Cross-ReferencingThe documentation uses two types of links to distinguish hierarchical structure from references:Regular Links - Use standard wiki-link syntax for direct parent-child relationships:[[child-document|Display Name]]
Cross-Reference Links - Use cross-reference syntax for non-hierarchical links:[cross-reference:: [[other-document|Display Name]]]
When to use cross-reference syntax:
Linking to files that are NOT direct children of the current document
Referencing related concepts at the same level or in different branches
Linking to authoritative sources for shared information
Any link that represents a reference rather than a structural parent-child relationship
Purpose: The cross-reference syntax allows Obsidian's graph view to filter out reference links, displaying only the hierarchical documentation tree structure. This makes it easier to visualize and maintain the documentation organization.Guidelines:
Use regular links to show "this document contains these sub-topics"
Use cross-reference links to show "see this other document for more information"
Avoid circular documentation dependencies regardless of link type
Maintenance
When information changes, update it in one place
Check that navigation paths remain clear
Remove or redirect broken internal links
Ensure new content fits the existing hierarchy
Documentation files use YAML frontmatter to track document status, categorization, and task management. This metadata integrates with Dataview for automated task tracking and status monitoring.Tracks document lifecycle and implementation state:
stub - Placeholder document that needs content
draft - Being actively written, incomplete
proposed - Complete proposal awaiting team approval
approved - Approved design ready for implementation
implemented - Code exists matching this documentation
outdated - Document needs updating to match current state
deprecated - Obsolete but kept for historical reference
Example:---
status: proposed
---
Categorizes document type for filtering and organization:
Navigation - Index, overview, or parent pages
Architecture - System architecture and design
Implementation - Detailed implementation specifications
Reference - API references, data formats, constants
Development - Development process and workflow
Testing - Testing strategies and requirements
Performance - Performance analysis and optimization
Security - Security considerations and requirements
Multiplayer - Multiplayer-specific systems
Legacy - Version 1 reference material
TaskList - Special: automated task aggregator pages
Example:---
tags: - Architecture - Performance
---
Task tracking with subcategories using tagged items. Each todo item can have an optional [category] tag at the start:Categories:
[implementation] - Code needs to be written
[testing] - Tests need to be written
[discussion] - Requires team discussion/decision
[research] - Requires investigation or research
[documentation] - Documentation needs to be written
[review] - Needs code or design review
(no tag) - General uncategorized task
Example:---
todo: - "[implementation] Detailed performance benchmarking of time slice overhead" - "[testing] Cross-platform determinism validation suite" - "[discussion] Optimal slice count (current proposal: 8 slices)" - "[research] Alternative scheduling algorithms" - "[documentation] Complete API reference section" - "General task without category"
---
Tracks concerns, proposals, and issues requiring attention. Each warning can have an optional [type] tag:Types:
[proposed] - Proposed system or architectural decision
[outdated] - Content is outdated and needs updating
[breaking] - Breaking change to existing implementations
[performance] - Performance concern or bottleneck
[security] - Security concern or vulnerability
[debt] - Technical debt that should be addressed
(no tag) - General warning
Example:---
warnings: - "[proposed] Time slice scheduling system enables variable timing" - "[performance] High memory usage with 300 snapshot buffer" - "[breaking] API changes required for state management" - "[debt] Inefficient memory allocation in snapshot system"
---
---
status: proposed
tags: - Architecture - Multiplayer
todo: - "[implementation] Performance benchmarking of snapshot creation" - "[testing] Network bandwidth testing with delta compression" - "[discussion] Snapshot retention policy (current: 5 seconds)"
warnings: - "[proposed] Unified state management serves single and multiplayer" - "[performance] Snapshot creation overhead needs measurement"
---
The subcategorized todo and warning items allow Dataview queries to filter by specific types. See cross-reference<a rel="noopener nofollow" class="internal-link" href="development/tasklist.html" data-href="tasklist" aria-label="tasklist" data-tooltip-position="top" target="_self">Task List</a> for automated queries that collect and organize these items across all documentation.
Use status to track document maturity through its lifecycle
Apply tags for broad categorization (multiple tags allowed)
Subcategorize todo items to help with task filtering and prioritization
Subcategorize warnings to identify types of concerns at a glance
Update status as documents progress from draft → proposed → approved → implemented
Mark documents as outdated when code diverges from documentation
The goal is that readers can efficiently find exactly what they need without encountering duplicate or outdated information.]]></description><link>development/documentation_structure.html</link><guid isPermaLink="false">development/DOCUMENTATION_STRUCTURE.md</guid><pubDate>Mon, 13 Oct 2025 19:47:30 GMT</pubDate></item><item><title><![CDATA[legacy]]></title><description><![CDATA[Analysis of V1 system concepts and algorithms to inform V2 development decisions.
<a class="internal-link" data-href="v1-reference.md" href="legacy/v1-reference.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Rules Engine Reference - Mathematical algorithms and GPU optimization from rules system
<br><a class="internal-link" data-href="v1-environmental-examples.md" href="legacy/v1-environmental-examples.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Environmental Examples - Terrain interaction patterns and emergent behaviors
<br><a class="internal-link" data-href="v1-gpu-patterns.md" href="legacy/v1-gpu-patterns.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 GPU Optimization Patterns - Compute shader strategies and memory management
<br><a class="internal-link" data-href="v1-visual-effects.md" href="legacy/v1-visual-effects.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Visual Effects - Rendering techniques and material systems
<br><a class="internal-link" data-href="v1-data-strategies.md" href="legacy/v1-data-strategies.html" target="_self" rel="noopener nofollow"><strong></strong></a>V1 Data Packing Strategies - Data organization and bit-packing techniques
Reference material extracted from V1 codebase to ensure V2 developers understand the complexity and sophistication of systems being replaced. ]]></description><link>legacy/legacy.html</link><guid isPermaLink="false">legacy/legacy.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[v1-environmental-examples]]></title><description><![CDATA[This document captures environmental interaction patterns from V1 to inform V2 rule design. These examples demonstrate the complexity and emergent behaviors that V2's JSON compilation system should be capable of expressing.Source: Analysis of V1 game logic examples (src/game.ts lines 48-158)
Status: Reference patterns for V2 rule creationContributor: Claude Status: Individual analysis of V1 examplesPersonal Addition: This analysis of V1's environmental behaviors hasn't been discussed with the team.V1 Pattern Observed: Complex water behavior through multiple condition typesWater Flow Detection:Condition: Water north (distance 1) AND Water north (distance 2) AND NOT (Water northwest OR Water northeast)
Personal Interpretation: This created directional water flow by detecting "channels" without side branching.Water Pooling Detection:Condition: (Water north distance 1 OR 2) AND (Water east distance 1 OR 2) AND (Water south distance 1 OR 2)
My Assessment: This detected water collecting in corners or depressions.Water Pressure/Volume Detection:Condition: Water north AND Water east AND Water northeast AND (Water northwest OR Water southeast)
Personal Note: This seemed to detect "enough water pressure" for certain transformations.V1 Grass-to-Mud Pattern:
Trigger: Close to water (bias: +4, total reaction bias: -3)
Result: Net positive when water adjacent
Behavior: Grass becomes mud near water sources
V1 Mud-to-Water Pattern:
Multiple conditions: Water flow (+2), surrounded by water (+2), close to water (+5), close to sand (+2)
Base bias: -6 (requires multiple conditions to trigger)
Behavior: Mud liquefies under water pressure
V1 Mud-to-Grass Recovery:
Negative conditions: Close to water (-2), kind of close to water (-1), close to mud (-1)
Base bias: +2
Behavior: Mud dries to grass when water recedes
Personal Observation: This created realistic seasonal or drought cycles in terrain.V1 Water-to-Sand Pattern:
Negative scoring: All water-related conditions had negative values
Base bias: -1
Interpretation: Water became sand only when "water pressure" was low
V1 Sand-to-Water Pattern:
Condition: Surrounded by water (+2)
Base bias: -1
Behavior: Sand eroded when completely surrounded
V1 Sand-to-Grass Colonization:
Condition: Lots of grass nearby (+3)
Base bias: -2
Behavior: Vegetation gradually reclaimed sandy areas
Personal Assessment: This created believable geological processes.V1 Lava Spread Pattern:Condition: Lava northwest AND Lava northeast AND Lava north Pattern: Required 3 adjacent lava tiles in a row formation
Target: Grass tiles (turning them to lava)
Base bias: -1 (requiring the specific pattern to overcome)
Personal Interpretation: This created lava "fronts" that advanced in lines rather than randomly.Contributor: Claude Status: Individual analysis not yet discussedPersonal Addition: These behavioral observations need team discussion for V2 design.Multiple Transformations per Tile Type: V1 allowed each tile type to have multiple possible reactions with different conditions.Example - Grass Tile Transformations:
Grass → Mud (when near water)
Grass → Lava (when in lava line formation) Grass → Sand (when conditions met - though this was commented out)
Personal Observation: This created realistic environmental competition where multiple forces could affect the same terrain.Observed Pattern: Mud ↔ Grass ↔ Sand cycles
Wet seasons: Grass → Mud → Water
Dry seasons: Water → Sand, Mud → Grass
Vegetation recovery: Sand → Grass (slow colonization)
Personal Assessment: V1's bias system created natural environmental cycles without explicit seasonal programming.Pattern: Many transformations required specific neighbor counts or arrangements
Water flow: Exactly the right configuration
Lava spread: 3-tile line formation required
Vegetation growth: Multiple grass neighbors needed
My Interpretation: This prevented chaotic transformations and created stable intermediate states.Contributor: Claude Status: Questions raised from V1 analysisPersonal Addition: These design considerations haven't been discussed with the team.Observed V1 Complexity:
Conditions checking multiple directions and distances
Logical combinations with AND, OR, NOT operators
Negative scoring for inhibitory effects
Distance-based neighbor detection (1 and 2 tiles away)
Personal Question: Can V2's JSON format express this level of spatial complexity?Example V1 Rule Expressed in Potential V2 JSON:{ "grass": [ { "id": "WaterFlow_Erosion", "action": {"type": "SetType", "new_type": "mud"}, "score_calculation": { "type": "Add", "children": [ {"type": "Constant", "value": -3}, { "type": "BooleanToValue", "condition": { "type": "AND", "children": [ {"type": "TileAt", "tile": "water", "direction": "N", "distance": 1}, {"type": "TileAt", "tile": "water", "direction": "N", "distance": 2}, { "type": "NOT", "child": { "type": "OR", "children": [ {"type": "TileAt", "tile": "water", "direction": "NW", "distance": 1}, {"type": "TileAt", "tile": "water", "direction": "NE", "distance": 1} ] } } ] }, "value_if_true": 4, "value_if_false": 0 } ] } } ]
}
Personal Concern: This JSON is already complex for a single V1 condition. V1 reactions had up to 16 conditions.V1 Optimization Evidence: Rules were pre-compiled into GPU textures
Complex conditions evaluated in parallel across all tiles
Shared memory caching for neighbor access
Personal Assessment: V2 needs comparable optimization strategies for similar environmental complexity.Research Needed: Performance testing of JSON compilation vs V1's direct GPU implementation.Identified by: Claude Status: Team input neededPersonal Assessment: V1 examples suggest specific environmental behavior goals that V2 should validate.
Geological cycles: Water erosion, sediment deposition, vegetation recovery
Competitive dynamics: Multiple environmental forces affecting same areas
Threshold stability: Avoiding chaotic oscillations between states
Directional flow: Water and lava following realistic propagation patterns
Team Discussion Needed: Should V2 target similar environmental realism?
How important are complex multi-condition interactions?
What level of rule complexity should V2 support?
V1 Evidence: Creating realistic environmental behaviors required intricate condition combinations and careful bias tuning.Personal Question: Will V2's visual editor be capable of creating rules of similar sophistication?Research Needed: UI/UX design for complex rule creation without overwhelming users.Personal Recommendations (not discussed with team):
Use V1 patterns as test cases for V2 JSON compilation system
Create V2 equivalents of key V1 environmental behaviors
Validate rule complexity limits early in V2 development
Design rule editor to handle spatial complexity observed in V1
Status: All recommendations need team review and design discussion.]]></description><link>legacy/v1-environmental-examples.html</link><guid isPermaLink="false">legacy/v1-environmental-examples.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[gameplay]]></title><description><![CDATA[Core game mechanics, rules, and design philosophy for Reaction v2.
<a class="internal-link" data-href="core-mechanics.md" href="gameplay/core-mechanics.html" target="_self" rel="noopener nofollow"><strong></strong></a>Core Mechanics - Victory conditions, timing, and elimination rules
Genre: Real-time PvP grid-based spellcasting game
Victory: Last player standing (avatar tile elimination)
Core Loop: Cast spells → Place runes → Transform environment → Tactical positioningNon-Turn-Based: Continuous simulation without traditional turns
Pre-Planning: Players can queue actions in advance
Dynamic Speed: Movement controlled by time delays between position updatesReactive World: Spells transform terrain according to rule-based systems
Terrain Types: Different tile types provide tactical advantages
Evolving World: Continuous world changes create evolving opportunitiesNo Scarcity: Unlimited mana regeneration - focus on timing over conservation
Recharge Timing: 3-turn recharge cycle provides natural rhythm
Allocation Choice: Specialization vs. flexibility in mana allocation]]></description><link>gameplay/gameplay.html</link><guid isPermaLink="false">gameplay/gameplay.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[building-documentation]]></title><description><![CDATA[The documentation system uses Obsidian for authoring (in docs/) and exports to HTML for GitHub Pages deployment via git subtree.
Obsidian with "Webpage HTML Export" plugin installed
Git command line tools Open the docs/ folder as a vault in Obsidian
Either: Click the "Export as HTML" button (added by Webpage HTML Export plugin)
Or run command "Webpage HTML Export: Export using previous settings" Ensure export target is set to build/docs
After exporting, commit and push the changes in the worktree:cd build/docs
git add .
git commit -m "Update documentation"
git push
cd ../.. Documentation source files (Markdown) live in docs/ on the main branch
Built HTML files are in build/docs/ which is a git worktree of the gh-pages branch
The worktree allows direct commits to gh-pages without switching branches
Changes to documentation require rebuilding and redeploying
]]></description><link>development/building-documentation.html</link><guid isPermaLink="false">development/building-documentation.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[ui]]></title><description><![CDATA[Status: 🚧 Stub - This system documentation needs completionUser interface system for game controls, HUD elements, and player interaction.TODO: Add links to UI components when implemented:
Interface layout and component hierarchy
Input handling and interaction patterns
HUD elements and game overlays
Menu systems and navigation
TODO: Document UI system responsibilities:
Game HUD: Mana flowers, spell hand, player status indicators
Game Controls: Spell casting interface, movement controls, action queuing
Menu Systems: Main menu, settings, deck building, game lobby
Visual Feedback: Action confirmations, error states, loading indicators
TODO: Define major UI components:
Mana Flower Display: Visual representation of mana types and recharge status
Spell Hand Interface: Spell selection and casting controls
Grid Overlay: Tile highlighting, targeting cursors, range indicators
Action Queue Visualization: Preview of queued player actions
Game Status: Timer, player health, elimination status
TODO: Add design guidelines:
Clarity: Clear visual hierarchy and information priority
Responsiveness: Immediate feedback for all player actions
Accessibility: Keyboard navigation, screen reader support, color accessibility
Scalability: Support for different screen sizes and resolutions
TODO: Document system integrations:
Input System: Mouse, keyboard, and touch input handling
Renderer: UI rendering pipeline and performance considerations
Game State: Real-time updates from game simulation
Spell System: Integration with spell casting and mana management
🚧 This file is a stub and needs completion]]></description><link>architecture/systems/ui/ui.html</link><guid isPermaLink="false">architecture/systems/ui/ui.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[DEVELOPMENT_PRINCIPLES]]></title><description><![CDATA[
Never fabricate performance numbers, statistics, or benchmarks
Mark personal ideas as such - don't present speculation as team decisions
Say "I don't know" when you don't know
Uncertainty is better than false confidence Code should explain itself through naming and structure
If you need extensive comments to explain what code does, rewrite it
Magic numbers and unclear constants are tech debt
Optimize for the next person who reads your code Distinguish between your ideas and team decisions
Make it easy for others to understand and build on your work
Ask questions when design decisions aren't clear
Share context behind your choices Use descriptive names for functions, variables, and files
Handle error cases explicitly - don't ignore or hide failures
Prefer simple, obvious solutions over clever optimizations
Document the "why" behind non-obvious business logic Be honest about what's decided vs. what you're proposing
Include enough context for someone to understand and challenge your reasoning
Avoid inventing performance claims or user behavior assumptions
Note when something needs team input or further research Understand the problem before jumping to solutions
Consider the person who will maintain this code in 6 months
Choose consistency with existing patterns over personal preference
Measure performance claims rather than guessing Write clear, descriptive commit messages that explain the "why" not just the "what"
Make atomic commits - each commit should represent one logical change
Never commit broken code or failing tests to main branch
Use branches for feature development and merge via pull requests
Review your own changes before committing - check diffs carefully
Keep commits focused - avoid mixing unrelated changes
Test your changes locally before pushing
Before committing work, ask:
Can someone else understand this without asking me questions?
Am I making any claims I can't back up?
Is this the simplest solution that solves the actual problem?
Have I clearly indicated what needs team discussion?
Are my commit messages clear and descriptive?
Have I tested my changes locally?
The goal is sustainable development where team members can confidently build on each other's work.]]></description><link>development/development_principles.html</link><guid isPermaLink="false">development/DEVELOPMENT_PRINCIPLES.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[tools]]></title><description><![CDATA[Status: Incomplete documentation The Tools system provides development utilities and visual editing capabilities for Reaction v2.The tools system includes:
Visual rule editor for creating and testing transformation rules
Development debugging utilities
Performance profiling tools
Asset management utilities
Documentation incomplete - editor interface and functionality to be detailedDocumentation incomplete - debugging and profiling tools to be documentedDocumentation incomplete - asset processing and management tools to be added]]></description><link>architecture/systems/tools/tools.html</link><guid isPermaLink="false">architecture/systems/tools/tools.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[rendering]]></title><description><![CDATA[Status: Incomplete documentationThe Renderer system handles visual display and UI rendering for Reaction v2.The renderer is responsible for:
GPU-based visual display of the game grid
UI rendering and interface elements
Frame coordination with other systems
Visual effects and animations
Documentation incomplete - details to be added during implementationDocumentation incomplete - optimization details to be addedDocumentation incomplete - WebGPU implementation details to be added]]></description><link>architecture/systems/rendering/rendering.html</link><guid isPermaLink="false">architecture/systems/rendering/rendering.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[reactions]]></title><description><![CDATA[Rule-based environmental transformations through GPU shader compilation for complex tile interactions.Transform human-readable tile interaction rules into highly optimized GPU shaders for environmental transformations like fire spreading, water extinguishing flames, and magical interactions.Design Approach: Designed for ease of rule creation and modification during development, allowing rules to be defined in JSON and automatically converted to efficient GPU code. Alternative approaches may be considered during implementation.
JSON rule compilation to optimized GPU shaders
Competitive rule scoring and execution for deterministic behavior
Environmental pattern matching (fire spreading, water interactions, etc.)
Rule optimization pipeline (specific implementation TBD) <a class="internal-link" data-href="rule-compilation.md" href="architecture/systems/reactions/rule-compilation.html" target="_self" rel="noopener nofollow"><strong></strong></a>Rule Compilation - JSON to GPU shader pipeline
<br><a class="internal-link" data-href="rule-system.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Rule System - Competitive scoring model and execution
<br><a class="internal-link" data-href="visual-editor.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Visual Editor - Development tools and rule creation interface
<br><a class="internal-link" data-href="examples.md" href=".html" target="_self" rel="noopener nofollow"><strong></strong></a>Examples - Sample rules and common patterns
Problem: Multiple rules may apply to the same tile simultaneously.
Solution: Competitive evaluation where highest-scoring rule wins.Design Philosophy: Move all possible computational work to build time for minimal runtime overhead.Lower frequency than physics: Reactions may run less frequently for performance.
⚠️ Challenge: Coordination with physics timing is a major technical issue to solve.
Core Engine: Required for texture access and coordination
Build Toolchain: Rule compilation requires build-time processing
]]></description><link>architecture/systems/reactions/reactions.html</link><guid isPermaLink="false">architecture/systems/reactions/reactions.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[rule-compilation]]></title><description><![CDATA[Transform human-readable tile interaction rules into GPU shaders for environmental transformations like fire spreading, water extinguishing flames, and magical interactions.Design Approach: Designed for ease of rule creation and modification during development, allowing rules to be defined in JSON and automatically converted to GPU code. Alternative approaches may be considered during implementation.Offline Processing: Move computational work to build time for reduced runtime overhead. JSON Rule Definition Human-readable transformation rules
Visual editor exports structured rule data
Declarative condition and action specifications GLSL Code Generation Rust-based rule-to-shader compiler
Converts declarative rules to imperative GPU code
Generates helper functions for tile data access SPIR-V Compilation Standard glslangValidator compilation
Produces unoptimized intermediate representation
Platform-independent shader bytecode Optimization (⚠️ NEEDS DESIGN - specific tools TBD) Dead code elimination, function inlining
Constant folding, loop unrolling
Register allocation optimization WebGPU Conversion Convert to WebGPU-compatible shader format
Runtime loading and execution Problem: Multiple rules may apply to the same tile simultaneously.Solution: Competitive evaluation where highest-scoring rule wins.Characteristics:
Deterministic rule resolution
Priority-based rule ordering
Complex conditional logic support
Complex interaction behaviors
Logical Operators: AND, OR, NOT for complex conditions
Spatial Queries: Check neighboring tiles and patterns
Aggregate Functions: Count tiles in regions, calculate thresholds
Boolean Conversion: Transform true/false to numeric scoresBase Priority: Fixed score for rule importance
Environmental Bonuses: Dynamic scoring based on surroundings
Mandatory Conditions: Huge negative scores for rule violations
Threshold Logic: Activation based on neighbor countsTile Transformation: Change tile type and properties
Property Modification: Update velocity, health, timers
Force Application: Apply velocity changes
State Changes: Modify custom data fields{ "grass": [ { "id": "GrassIgnition", "action": { "type": "SetType", "new_type": "fire" }, "score_calculation": { "type": "Add", "children": [ { "type": "Constant", "value": 30 }, { "type": "BooleanToValue", "condition": { "type": "Aggregate", "region": "3x3", "tile_type": "fire", "comparison": "GreaterThan", "count": 0 }, "value_if_true": 0, "value_if_false": -10000 }, { "type": "Aggregate", "region": "3x3", "tile_type": "water", "expression": "count * -50" } ] } } ]
}
Lower frequency than physics: Reactions may run less frequently for performance.Challenge: Coordination with physics timing is a major technical issue to solve.
Rule Evaluation: Each tile evaluates all applicable rules
Score Calculation: Parallel computation of rule priorities Winner Selection: Deterministic highest-score selection
Action Application: Transform winning tiles Input: Read post-physics tile states
Processing: Local neighborhood sampling for conditions
Output: Write transformed tiles for next physics cycle
Integration: Seamless data flow with physics engine
⚠️ SUGGESTION: Potential editor features for future development:
Grid-based visual neighborhood editor
Point-and-click rule creation interface
Real-time rule testing and preview
Direct JSON generation for compilation
⚠️ SUGGESTION: Potential debugging capabilities:
Rule tracing: Debug which rules activated and why
Score visualization: See rule competition in real-time
Validation tools: Detect impossible or conflicting rules
Performance profiling: Shader execution timing
⚠️ SUGGESTION: Potential compilation optimizations:
Compile-time specialization for specific use cases
Dead code elimination for unused rule paths
Constant folding for pre-computed values
Loop unrolling for neighbor checks Rule Complexity: Handles arbitrary rule complexity through compilation
Rule Count: Compilation-time scaling, not runtime cost
Memory Efficiency: Optimized data access patterns
]]></description><link>architecture/systems/reactions/rule-compilation.html</link><guid isPermaLink="false">architecture/systems/reactions/rule-compilation.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[client-prediction]]></title><description><![CDATA[Local state prediction with rollback mechanisms for responsive gameplay despite network latency.⚠️ UPDATED SYSTEM: Client prediction now uses the unified Deterministic Time-Sliced Execution pipeline. See cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> for complete integration details.Single Engine: Same game engine used for single-player and multiplayer prediction.Deterministic Execution: Time-sliced pipeline ensures identical client/server results.Automatic State Management: Built-in snapshots and rollback through unified state system.Frame Synchronization: Time slice alignment with server for precise synchronization.
Local state prediction using identical simulation logic
Server state comparison with automatic mismrediction detection Rollback and re-execution through unified state management
Ghost simulation for action queue visualization
Purpose: Runs identical simulation logic for local prediction.Components:
Same GPU compute shaders as server
Physics and reaction processing
Tile state management with active regions
Deterministic frame execution pipeline
Key Differences:
Operates on unconfirmed inputs
Generates visual output during prediction
Maintains rollback state history
Handles prediction correction smoothly
Confirmed States: Server-validated game states stored every 5 frames
Prediction States: Local simulation results with input applied
Rollback Threshold: Maximum 10 frames (167ms at 60 FPS)
Server State Reception: Authoritative state update arrives
Local Comparison: Compare with predicted state at same frame
Divergence Analysis: Identify significant differences
Rollback Decision: Determine if correction is necessary State Restoration: Revert to last confirmed server state
Input Replay: Re-apply all inputs since that frame
Simulation Catch-up: Run physics/reactions to current frame
Visual Interpolation: Smooth transition to corrected state
Own Actions Only: Predict consequences of local player inputs
Physics Prediction: Tile movement and basic collisions
Spell Effects: Immediate visual feedback for cast spells
Avoid Complex Rules: Don't predict environmental transformationsAll Player Actions: Predict other players' likely actions
Rule Interactions: Attempt complex environmental predictions
Higher Rollback Risk: More frequent corrections needed
Better Responsiveness: Smoother gameplay when predictions succeedNetwork Quality Based: Adjust strategy based on connection stability
Misprediction History: Learn from previous prediction accuracy
Dynamic Threshold: Modify rollback sensitivity based on gameplay contextinterface PredictedInput { frameNumber: number; playerId: string; inputData: PlayerInput; timestamp: number; confirmed: boolean;
} Local Input Capture: Player action registration
Immediate Prediction: Apply to local simulation instantly
Server Transmission: Send input with frame number
Confirmation Tracking: Mark inputs as confirmed when server acknowledges
History Cleanup: Remove old confirmed inputs from buffer
Interpolation: Smooth transition between predicted and actual states
Temporal Blending: Gradual adjustment over multiple frames
Priority System: Prioritize corrections for player-controlled entitiesOptimistic Updates: Show immediate response to player actions
Uncertainty Indicators: Visual cues for unconfirmed actions
Rollback Masking: Hide jarring corrections with effectsSpatial Boundaries: Only predict within player's view range
Temporal Limits: Maximum prediction window of 10 frames
Complexity Filtering: Skip expensive calculations during predictionState Compression: Efficient storage of rollback snapshots
Garbage Collection: Automatic cleanup of old prediction data
GPU Resource Sharing: Reuse textures between prediction and renderingLatency Measurement: Dynamic adjustment of prediction window
Quality Scaling: Reduce prediction complexity on slow connections
Fallback Mode: Disable prediction on extremely poor connectionsDesync Recovery: Full state resynchronization when prediction fails
Input Loss: Request missing inputs from server
State Corruption: Fallback to last known good stateConnection Loss: Maintain prediction until reconnection
High Latency: Extend prediction window with quality reduction
Packet Loss: Request state recovery from serverFrame Drops: Reduce prediction complexity automatically
Memory Pressure: Cleanup old snapshots more aggressively
GPU Issues: Fallback to CPU-only prediction if necessaryThis system provides responsive gameplay while maintaining competitive integrity through authoritative server validation.]]></description><link>architecture/systems/multiplayer/client-prediction.html</link><guid isPermaLink="false">architecture/systems/multiplayer/client-prediction.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[texture-management]]></title><description><![CDATA[GPU texture coordination and ping-ponging system for race-condition prevention.Challenge: Prevent GPU read-after-write hazards when multiple systems access the same tile data simultaneously.Solution: Texture ping-ponging using paired textures for each layer.Each layer uses paired textures (layer_A, layer_B) enabling GPU modules to read from stable data while writing to separate textures, avoiding read-after-write hazards.
Read Phase: Modules read from texture set A
Write Phase: Modules write to texture set B Swap Phase: Texture roles switch for next frame
Barrier: GPU compute dispatch barriers ensure proper execution ordering
Format: r32uint for optimal GPU cache performance
Rationale: Single 32-bit channel matches bit-packed tile format2D Layout: Textures leverage GPU's optimized 2D memory access patterns
Spatial Locality: Neighboring tiles often accessed together benefit from cache prefetching
Input Processing: Reads from current texture set
Physics Pass: Writes to alternate texture set
Reaction Pass: Reads from physics output textures
Render Pass: Reads from stable texture set for display
Active Texture Tracking: Core Engine maintains current read/write texture assignments
Automatic Swapping: Texture roles alternate each frame automatically
Resource Cleanup: Proper GPU resource lifecycle management⚠️ NEEDS IMPLEMENTATION DETAIL: Specific WebGPU texture creation and binding patternsTrade-off: Double memory usage (2x textures per layer) for synchronization safety
Optimization: Memory layout optimized for GPU architecture⚠️ NEEDS DESIGN: GPU resource allocation failure handling and recovery strategies
Race Condition Prevention: Eliminates GPU synchronization hazards
Pipeline Operations: Allows overlapped read/write operations
Memory Layout: 2D texture layout for spatial access patterns Memory Overhead: 2x memory usage per layer
Texture Switching: Minimal GPU overhead for texture binding updates
⚠️ NEEDS SPECIFICATION: Core classes and methods for texture managementPlanned Classes:
TextureManager: Handles ping-ponging and synchronization TileStorage: Manages texture allocation and bit-packing
Integration with GameLoop for frame coordination
]]></description><link>architecture/systems/core/texture-management.html</link><guid isPermaLink="false">architecture/systems/core/texture-management.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[config]]></title><description><![CDATA[Status: 🚧 Stub - This system documentation needs completionSystem for managing game configuration, settings, and runtime parameters.TODO: Add links to configuration components when implemented:
Configuration file formats and schemas
Runtime configuration management
Environment-specific settings
Validation and error handling
TODO: Document configuration system responsibilities:
Game settings and parameters
Environment configuration (dev/test/prod)
Runtime parameter management
Configuration validation and defaults
TODO: Define configuration categories:
Game Settings: Tile limits, world parameters, gameplay constants
Performance Settings: GPU options, rendering quality, frame rate targets
Network Settings: Server endpoints, timeout values, retry policies
Development Settings: Debug flags, logging levels, profiling options
TODO: Add implementation details:
Configuration file loading and parsing
Hot-reloading of configuration changes
Configuration override hierarchy
Validation and schema enforcement
🚧 This file is a stub and needs completion]]></description><link>architecture/systems/config/config.html</link><guid isPermaLink="false">architecture/systems/config/config.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[variable-timing]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed time slice scheduling system that enables variable player action timing while maintaining deterministic 60 FPS execution.Variable Player Speeds: Different players can have different action timing based on status effects.Fixed Mana Timing: Mana recharge remains strategically consistent regardless of player speed changes.Smooth Physics: Maintain 60 FPS physics simulation for fluid movement.Deterministic Execution: All timing decisions must be reproducible for multiplayer.Frame Duration: 16.67ms (60 FPS)
Time Slices: 8 slices per frame
Slice Duration: 2.08ms per sliceRationale: 8 slices provides sufficient granularity for speed effects (0.5x to 2x) while maintaining reasonable processing overhead.interface TimeSliceSchedule { // Base timing (normal speed) baseActionInterval: 8; // 8 slices = 1 action baseManaInterval: 24; // 24 slices = 3 actions // Physics runs every slice for smooth motion physicsInterval: 1; // Reactions run less frequently for performance reactionInterval: 4; // Every 4 slices
}
Speed Effects: Status effects modify player action timing immediately.Calculation: newInterval = baseInterval / speedMultiplierSpeed Ranges: Slowed: 0.5x (16 slices per action)
Normal: 1.0x (8 slices per action) Hasted: 2.0x (4 slices per action)
interface PlayerActionSchedule { playerId: string; currentInterval: number; // Current slices between actions nextActionSlice: number; // When next action executes queuedActions: PlayerAction[]; // 3 actions lookahead speedMultiplier: number; // Current speed effect
} class TimeSliceScheduler { private playerSchedules = new Map&lt;string, PlayerActionSchedule&gt;(); private currentSlice = 0; // Process all scheduled actions for this slice processSlice(sliceIndex: number) { this.currentSlice = sliceIndex; // Process players in deterministic order (by ID) const sortedPlayerIds = Array.from(this.playerSchedules.keys()).sort(); for (const playerId of sortedPlayerIds) { this.processPlayerSchedule(playerId, sliceIndex); } } private processPlayerSchedule(playerId: string, slice: number) { const schedule = this.playerSchedules.get(playerId); if (schedule.nextActionSlice === slice) { // Execute queued action const action = schedule.queuedActions.shift(); this.executePlayerAction(playerId, action); // Schedule next action schedule.nextActionSlice = slice + schedule.currentInterval; // Request new action for queue this.requestNextAction(playerId); } }
}
Independence: Mana timing unaffected by player speed changes.Strategic Consistency: Players can rely on consistent mana timing for tactical planning.Implementation: Separate timing system running parallel to player actions.class ManaRechargeScheduler { private readonly MANA_RECHARGE_INTERVAL = 24; // 3 base actions worth private nextRechargeSlice = 24; processSlice(sliceIndex: number) { if (sliceIndex === this.nextRechargeSlice) { this.rechargeManaFlowers(); this.nextRechargeSlice += this.MANA_RECHARGE_INTERVAL; } } private rechargeManaFlowers() { // Recharge all mana flowers regardless of player speeds for (const flower of this.getAllManaFlowers()) { flower.recharge(); } }
}
Timing Update: Speed effects immediately modify next action timing.Queue Preservation: Existing action queue remains valid but timing adjusts.Deterministic Application: Speed changes processed in consistent order.class StatusEffectManager { applySpeedEffect(playerId: string, newMultiplier: number) { const schedule = this.scheduler.getPlayerSchedule(playerId); const currentSlice = this.scheduler.getCurrentSlice(); // Calculate remaining time to next action const remainingSlices = schedule.nextActionSlice - currentSlice; // Apply speed change to remaining time const speedChange = newMultiplier / schedule.speedMultiplier; const newRemainingSlices = Math.ceil(remainingSlices / speedChange); // Update schedule schedule.speedMultiplier = newMultiplier; schedule.currentInterval = Math.ceil(8 / newMultiplier); // 8 = base interval schedule.nextActionSlice = currentSlice + newRemainingSlices; // Invalidate affected ghost predictions this.ghostSimulator.invalidatePlayerPredictions(playerId); }
}
Simultaneous Actions: When multiple players have actions scheduled for same slice, process in deterministic order (player ID).Queue Validation: Validate action legality when scheduled, not when executed.Timing Consistency: Ensure identical timing calculations across all clients and server.class SchedulingEdgeCases { // Handle sub-slice timing precision handleFractionalSlices(calculatedSlices: number): number { // Always round up to ensure actions don't execute too early return Math.ceil(calculatedSlices); } // Handle extreme speed changes clampSpeedMultiplier(multiplier: number): number { return Math.max(0.1, Math.min(10.0, multiplier)); } // Handle action queue overflow validateActionQueue(queue: PlayerAction[]): boolean { // Ensure queue never exceeds 3 actions return queue.length &lt;= 3; }
}
Sparse Processing: Only process slices with scheduled events.Batch Operations: Group similar operations within same slice.Memory Efficiency: Use circular buffers for timing data.Consistent Frequency: Physics processes every slice for smooth motion.Interpolation: Visual interpolation between physics updates for display.State Synchronization: Ensure physics state consistency with action timing.Lookahead: Simulate 3 queued actions for each player.Timing Prediction: Account for current speed effects in predictions.Invalidation: Update predictions when speed effects change.class GhostTimingPredictor { predictActionTiming(playerId: string, actionCount: number): number[] { const schedule = this.scheduler.getPlayerSchedule(playerId); const predictions: number[] = []; let nextSlice = schedule.nextActionSlice; for (let i = 0; i &lt; actionCount; i++) { predictions.push(nextSlice); nextSlice += schedule.currentInterval; } return predictions; }
}
Determinism Tests: Verify identical timing across multiple runs.Edge Case Coverage: Test extreme speed values and rapid changes.Synchronization Validation: Ensure client-server timing consistency.Slice Processing Overhead: Measure time slice processing cost.Memory Usage: Monitor scheduling data structure efficiency.Scalability: Test with varying player counts and speed effects.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/deterministic-execution.html" data-href="deterministic-execution" aria-label="deterministic-execution" data-tooltip-position="top" target="_self">Deterministic Execution</a> - Execution order and consistency
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/state-management.html" data-href="state-management" aria-label="state-management" data-tooltip-position="top" target="_self">State Management</a> - Integration with state snapshots
⚠️ NEEDS TEAM DISCUSSION:
Optimal slice count (current proposal: 8 slices per frame)
Speed multiplier ranges (current proposal: 0.1x to 10x)
Ghost prediction complexity vs performance trade-offs
⚠️ NEEDS IMPLEMENTATION:
Detailed performance benchmarking of time slice overhead
Integration testing with existing Core Engine texture management
Multiplayer synchronization validation
]]></description><link>architecture/general/variable-timing.html</link><guid isPermaLink="false">architecture/general/variable-timing.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item><item><title><![CDATA[ghost-simulation]]></title><description><![CDATA[⚠️ PROPOSED SYSTEM: This document describes the proposed predictive action visualization system that shows players their queued actions and their likely outcomes without affecting the main game simulation.Action Preview: Show visual representation of 3 queued player actions.Spell Effect Prediction: Display where runes will be placed and their likely effects.Movement Prediction: Show future player positions based on queued movement.Performance Constraint: Ghost simulation must not impact main game performance.Simplified Rules: Use fast approximations instead of full physics/reaction simulation.Position-Only Physics: Predict movement without complex collision interactions.Basic Spell Effects: Show rune placement without full environmental predictions.Selective Simulation: Only simulate aspects visible to players.interface GhostPrediction { actionIndex: number; // Which queued action (0, 1, 2) playerPosition: Position; // Predicted player position spellEffects: RunePlacement[]; // Predicted rune placements confidence: number; // Prediction confidence (0-1) timestamp: number; // When prediction was generated
} class GhostSimulator { private predictionCache = new Map&lt;string, GhostPrediction[]&gt;(); private simulationComplexity: 'minimal' | 'basic' | 'detailed' = 'basic'; updatePlayerGhosts(playerId: string): GhostPrediction[] { const cacheKey = this.generateCacheKey(playerId); // Check cache validity if (this.isCacheValid(cacheKey)) { return this.predictionCache.get(cacheKey); } // Generate new predictions const predictions = this.simulatePlayerActions(playerId); this.predictionCache.set(cacheKey, predictions); return predictions; }
}
Minimal: Position-only prediction with no interaction simulation.
Movement vectors applied directly
Spell targeting shown without environmental effects
Fastest performance, lowest accuracy
Basic: Position + simple spell effects prediction.
Basic collision detection for movement
Rune placement validation
Simple environmental effects (obvious barriers, holes)
Balanced performance and accuracy
Detailed: Full simulation using simplified rules.
Complete physics simulation with reduced precision
Environmental rule evaluation with fast heuristics
Complex spell interactions predicted
Higher accuracy, potential performance impact
class MovementPredictor { predictMovement(player: PlayerState, action: MovementAction): Position { let currentPos = player.position; const moveVector = this.calculateMoveVector(action); // Simple collision detection for ghost prediction const targetPos = { x: currentPos.x + moveVector.x, y: currentPos.y + moveVector.y }; // Check for obvious barriers if (this.isPositionBlocked(targetPos)) { return currentPos; // No movement if blocked } return targetPos; } private isPositionBlocked(position: Position): boolean { // Simplified collision detection for performance const tile = this.getTileAt(position); return tile?.type === TileType.SOLID || tile?.type === TileType.WALL; }
}
class SpellEffectPredictor { predictSpellCast(player: PlayerState, spell: SpellAction): RunePlacement[] { const placements: RunePlacement[] = []; // Validate mana requirements if (!this.hasRequiredMana(player, spell)) { return []; // No effect if insufficient mana } // Calculate rune placements const pattern = this.getSpellPattern(spell.spellId); const targetPos = spell.targetPosition; for (const offset of pattern.runeOffsets) { const runePos = { x: targetPos.x + offset.x, y: targetPos.y + offset.y }; // Basic placement validation if (this.canPlaceRune(runePos)) { placements.push({ position: runePos, runeType: pattern.runeType, delay: pattern.delay, confidence: this.calculatePlacementConfidence(runePos) }); } } return placements; }
}
Cache Keys: Based on player state hash and action queue hash.Invalidation: Cache invalidated when player state or world state changes significantly.Selective Updates: Only update ghosts for players whose state changed.class GhostCacheManager { private readonly CACHE_DURATION = 100; // ms generateCacheKey(playerId: string): string { const player = this.getPlayer(playerId); const actionQueueHash = this.hashActionQueue(player.actionQueue); const playerStateHash = this.hashPlayerState(player); const worldStateHash = this.getRelevantWorldStateHash(player.position); return `${playerId}-${actionQueueHash}-${playerStateHash}-${worldStateHash}`; } isCacheValid(cacheKey: string): boolean { const cached = this.predictionCache.get(cacheKey); if (!cached) return false; const age = performance.now() - cached.timestamp; return age &lt; this.CACHE_DURATION; } invalidatePlayerCache(playerId: string): void { // Remove all cache entries for this player for (const [key, _] of this.predictionCache) { if (key.startsWith(playerId)) { this.predictionCache.delete(key); } } }
}
Performance Monitoring: Adjust simulation complexity based on frame rate.Player Count Scaling: Reduce complexity when many players are active.Network Condition Adaptation: Simplify predictions on slow connections.class AdaptiveGhostManager { private performanceMonitor = new PerformanceMonitor(); updateSimulationComplexity(): void { const currentFPS = this.performanceMonitor.getCurrentFPS(); const playerCount = this.getActivePlayerCount(); if (currentFPS &lt; 55 || playerCount &gt; 6) { this.ghostSimulator.setComplexity('minimal'); } else if (currentFPS &lt; 58 || playerCount &gt; 4) { this.ghostSimulator.setComplexity('basic'); } else { this.ghostSimulator.setComplexity('detailed'); } }
}
Player Ghosts: Translucent player sprites at predicted positions.Action Indicators: Visual cues showing queued action types.Spell Previews: Targeting lines and rune placement previews.Confidence Visualization: Alpha/color coding based on prediction confidence.interface GhostVisual { playerId: string; actionIndex: number; position: Position; alpha: number; // Transparency based on confidence actionIndicator: ActionType; spellPreview?: SpellPreview;
} class GhostRenderer { renderPlayerGhosts(predictions: GhostPrediction[]): void { for (let i = 0; i &lt; predictions.length; i++) { const prediction = predictions[i]; const alpha = this.calculateAlpha(prediction.confidence, i); this.renderGhostPlayer({ playerId: prediction.playerId, actionIndex: i, position: prediction.playerPosition, alpha: alpha, actionIndicator: prediction.actionType, spellPreview: prediction.spellEffects }); } } private calculateAlpha(confidence: number, actionIndex: number): number { // Closer actions are more opaque, further actions more transparent const timeAlpha = 1.0 - (actionIndex * 0.2); const confidenceAlpha = 0.3 + (confidence * 0.7); return timeAlpha * confidenceAlpha; }
}
Prediction Timing: Account for variable action timing in predictions.Speed Effect Integration: Update predictions when player speed changes.Action Queue Synchronization: Maintain predictions synchronized with action queue.class GhostTimingIntegration { updateGhostTimingForSpeedChange(playerId: string, newSpeedMultiplier: number): void { // Recalculate prediction timing based on new speed const predictions = this.ghostSimulator.getPlayerPredictions(playerId); for (const prediction of predictions) { const newTiming = this.recalculateActionTiming( prediction.actionIndex, newSpeedMultiplier ); prediction.expectedExecutionSlice = newTiming; } // Invalidate cache to force regeneration this.ghostCacheManager.invalidatePlayerCache(playerId); } private recalculateActionTiming(actionIndex: number, speedMultiplier: number): number { const baseInterval = 8; // 8 time slices per action at normal speed const adjustedInterval = Math.ceil(baseInterval / speedMultiplier); return this.currentSlice + (adjustedInterval * (actionIndex + 1)); }
}
Invalid Actions: Show warning indicators for actions that can't be executed.Resource Conflicts: Display mana insufficiency or other blocking conditions.Simulation Errors: Graceful degradation to simpler prediction methods.class GhostErrorHandler { handlePredictionError(playerId: string, error: PredictionError): GhostPrediction { console.warn(`Ghost prediction error for ${playerId}:`, error); switch (error.type) { case 'insufficient-mana': return this.createManaWarningGhost(playerId, error.actionIndex); case 'invalid-target': return this.createTargetWarningGhost(playerId, error.actionIndex); case 'simulation-timeout': return this.fallbackToPositionOnlyPrediction(playerId, error.actionIndex); default: return this.createErrorGhost(playerId, error.actionIndex); } }
}
Accuracy Metrics: Track how often predictions match actual outcomes.Performance Benchmarks: Monitor ghost simulation performance impact.User Experience Testing: Validate that ghost feedback improves gameplay.Action Queue Edge Cases: Test ghost behavior with rapidly changing queues.Speed Effect Interactions: Verify ghost timing updates with status effects.Network Lag Simulation: Test ghost behavior under various network conditions.
cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/data-flow.html" data-href="data-flow" aria-label="data-flow" data-tooltip-position="top" target="_self">Data Flow Architecture</a> - Parent pipeline architecture
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/general/variable-timing.html" data-href="variable-timing" aria-label="variable-timing" data-tooltip-position="top" target="_self">Variable Timing System</a> - Integration with action scheduling
<br>cross-reference<a rel="noopener nofollow" class="internal-link" href="architecture/systems/rendering/rendering.html" data-href="rendering" aria-label="rendering" data-tooltip-position="top" target="_self">Renderer System</a> - Visual rendering integration
⚠️ NEEDS TEAM DISCUSSION:
Default simulation complexity level (minimal/basic/detailed)
Ghost prediction accuracy vs performance trade-offs
Visual design for ghost representation (transparency, colors, indicators)
⚠️ NEEDS IMPLEMENTATION:
Performance benchmarking of different complexity levels
User experience testing of ghost feedback effectiveness
Integration testing with action queue and timing systems
]]></description><link>architecture/general/ghost-simulation.html</link><guid isPermaLink="false">architecture/general/ghost-simulation.md</guid><pubDate>Mon, 13 Oct 2025 18:35:06 GMT</pubDate></item></channel></rss>